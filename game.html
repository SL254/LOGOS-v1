<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOGOS ORGANON</title>

    <style>
      @font-face {
        font-family: "font"; /* CSSì—ì„œ ì‚¬ìš©í•  í°íŠ¸ ì´ë¦„ì„ ì§€ì • */
        src: url("assets/font.ttf") format("truetype"); /* í°íŠ¸ íŒŒì¼ì˜ ê²½ë¡œì™€ í˜•ì‹ */
      }
      body {
        font-family: "font", "Malgun Gothic", "Segoe UI", sans-serif;
        background-color: #f4f7f9;
        color: #333;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        font-size: 15px;
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/images/sky.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        grid-template-rows: auto auto 1fr auto;
        row-gap: 0;
        column-gap: 0px;
        width: 100%;
        max-width: 1400px;
        height: 90vh;
        visibility: hidden; /* Initially hidden until language is selected */
        position: relative;
        z-index: 1;
      }
      .container.ready {
        visibility: visible;
      }
      #player-a-area,
      .game-board {
        margin-right: -1px;
      }
      header {
        grid-column: 1 / -1;
        text-align: center;
        padding: 25px 15px;
        color: black;
        margin: 0 -40px;
        background-image: url("assets/images/roof.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      header h1 {
        color: transparent;
        margin: 0;
        font-size: 42px;
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
      }

      #info-box {
        padding: 15px 55px;
        grid-column: 1 / -1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        margin: 0 -40px;
        background-image: url("assets/images/roo.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .header-buttons-left,
      .header-buttons-right {
        display: flex;
        gap: 10px;
      }
      .header-buttons-left button,
      .header-buttons-right button {
        padding: 4px 8px;
        border: none;

        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 1em;
      }
      #new-game-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/new.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #new-game-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/new_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #fullscreen-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/full.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #fullscreen-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/full_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      #main-menu-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #main-menu-btn:hover {
        border-image-source: url("assets/images/full_hover.png");
      }
      #tutorial-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #tutorial-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #puzzle-mode-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #puzzle-mode-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .mode-selector button {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      .mode-selector button:not(.active):hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      #exit-game-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #exit-game-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      .round-display {
        /* position, left, transform ì†ì„± ì œê±° */
        font-size: 1.7em;
        font-weight: bold;
        color: #9a4b37;
      }
      .player-area {
        background-color: #b15139;
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        transition: opacity 0.3s, box-shadow 0.3s;
        border: 4px solid transparent;
      }
      .player-area.disabled {
        background-color: #b15139;
      }

      .player-area h3 {
        font-weight: normal;
        margin: 0;
      }
      .hand {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        height: 400px; /* ì›í•˜ëŠ” ê³ ì • ë†’ì´ê°’ (ì¡°ì • ê°€ëŠ¥) */
        overflow-y: auto; /* ë‚´ìš©ì´ ë„˜ì¹  ê²½ìš° ìŠ¤í¬ë¡¤ ìƒì„± */

        padding: 10px 4px;
        box-sizing: border-box; /* paddingì´ ë†’ì´ ê³„ì‚°ì— í¬í•¨ë˜ë„ë¡ ì„¤ì • */
        background-color: rgba(238, 218, 165, 0.65); /* ë°˜íˆ¬ëª… í°ìƒ‰ ë°°ê²½ */
      }
      .card {
        padding: 10px 12px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .card.ai-hand {
        cursor: default;
      }
      .card-white {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        background-color: #edebe6;
        border-radius: 14px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/card_white.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
      }
      .card-white:hover:not(.ai-hand) {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/card_white_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
      }
      .card-black {
        color: white;
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        background-color: #453f32;
        border-radius: 14px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/card_black.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        image-rendering: pixelated;
      }
      .card-black:hover:not(.ai-hand) {
        color: white;
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/card_black_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
      }
      .game-board {
        display: flex;
        flex-direction: column;
        gap: 0px;
        min-height: 0;
        position: relative;
      }
      #current-proposition {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 7px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/papiru.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
      }
      #current-proposition {
        min-height: 120px;
        display: flex;
        flex-direction: column;
      }

      #background-box {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 300px; /* ğŸ‘ˆ ë†’ì´ë¥¼ ê³ ì •ê°’ìœ¼ë¡œ ì§ì ‘ ì§€ì • */
        z-index: -1;
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/images/cloud.png"); /* ğŸ‘ˆ ì—¬ê¸°ì— íŒŒì¼ ê²½ë¡œë¥¼ ì…ë ¥í•˜ì„¸ìš” */
        background-size: 340px 340px; /* ğŸ‘ˆ 64pxì—ì„œ 128pxë¡œ 2ë°° í™•ëŒ€ */
        image-rendering: pixelated; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì„ ëª…í•˜ê²Œ ìœ ì§€í•˜ëŠ” í•µì‹¬ ì†ì„± */

        background-repeat: repeat; /* ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ë°”ë‘‘íŒì‹ìœ¼ë¡œ ë°˜ë³µ */
      }
      #proposition-display {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 50px;
        flex-grow: 1;
        align-items: center;
      }
      #proposition-controls {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }
      #complete-btn {
        color: white;
        padding: 0;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/complete.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #complete-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/complete_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #undo-btn {
        color: white;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/undo.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #undo-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/undo_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #end-turn-btn {
        color: white;
        margin-left: auto;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/end.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #end-turn-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/end_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }
      #true-propositions {
        /* ì¹´ë“œ ë‚´ìš©ë¬¼ì„ ìœ„í•œ ì•ˆìª½ ì—¬ë°± */
        padding: 15px;

        /* border-imageë¥¼ ìœ„í•œ ì„¤ì • */
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/papiru_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        image-rendering: pixelated;

        /* --- ìˆ˜ì •ëœ ë¶€ë¶„ --- */
        flex-grow: 1; /* ë‚¨ëŠ” ê³µê°„ì„ ì°¨ì§€í•˜ë ¤ëŠ” ì„±ì§ˆ */
        flex-shrink: 1; /* ê³µê°„ì´ ë¶€ì¡±í•  ë•Œ ì¤„ì–´ë“¤ë ¤ëŠ” ì„±ì§ˆ */
        flex-basis: 0; /* í•µì‹¬: ë‚´ìš©ë¬¼ í¬ê¸°ë¥¼ ë¬´ì‹œí•˜ê³  0ì—ì„œë¶€í„° ê³µê°„ì„ ê³„ì‚°í•˜ë„ë¡ ì„¤ì • */
        /* ------------------ */

        overflow-y: auto;
        min-height: 0;
      }

      #true-propositions h3 {
        margin-top: 0;
      }
      #true-propositions ul {
        padding-left: 0;
        list-style-type: none;
        margin: 0;
      }
      #true-propositions li {
        margin-bottom: 8px;
        padding: 8px;
        background-color: #fff;

        border-left: 4px solid #3498db;
      }
      #true-propositions li.victory-condition {
        border-left-color: #f1c40f;
        font-weight: normal;
        background-color: #fef9e7;
      }
      #true-propositions li.axiom-wrapper {
        padding: 0;
        border-left: none;
      }
      #true-propositions li.theorem {
        border-left-color: #8e44ad;
        font-style: italic;
        background-color: #f5eef8;
      }
      #true-propositions li.plato-theorem {
        border-left: 4px solid #8e44ad;
        font-style: italic;
        background-color: #fff;
      }
      #true-propositions li.nietzsche-theorem {
        border-left: 4px solid #8e44ad; /* í”Œë¼í†¤ê³¼ ë™ì¼í•œ ìƒ‰ìƒ */
        font-style: italic; /* ì´íƒ¤ë¦­ì²´ */
        background-color: #fff;
      }
      #true-propositions li.socrates-disabled {
        background-color: #e0e0e0; /* íšŒìƒ‰ ë°°ê²½ */
        color: #888;
        border-left-color: #95a5a6;
        font-style: italic;
      }
      #true-propositions li.wittgenstein-theorem {
        border-left: 4px solid #8e44ad; /* í”Œë¼í†¤ê³¼ ë™ì¼í•œ ìƒ‰ìƒ */
        font-style: italic; /* ì´íƒ¤ë¦­ì²´ */
        background-color: #fff;
      }
      #true-propositions li.derrida-theorem {
        border-left: 4px solid #8e44ad; /* í”Œë¼í†¤ê³¼ ë™ì¼í•œ ìƒ‰ìƒ */
        font-style: italic; /* ì´íƒ¤ë¦­ì²´ */
        background-color: #fff;
      }
      #true-propositions li.hume-theorem {
        border-left: 4px solid #8e44ad; /* í”Œë¼í†¤ê³¼ ë™ì¼í•œ ìƒ‰ìƒ */
        font-style: italic; /* ì´íƒ¤ë¦­ì²´ */
        background-color: #fff;
      }
      #true-propositions li.kuhn-theorem {
        border-left: 4px solid #8e44ad; /* í”Œë¼í†¤ê³¼ ë™ì¼í•œ ìƒ‰ìƒ */
        font-style: italic; /* ì´íƒ¤ë¦­ì²´ */
        background-color: #fff;
      }
      #true-propositions li.kant-theorem {
        border-left: 4px solid #8e44ad;
        font-style: italic;
        background-color: #fff;
      }
      #true-propositions li.victory-condition.marx-victory-condition {
        background-color: #fdf2f2; /* ì˜…ì€ ë¶‰ì€ìƒ‰ ë°°ê²½ */
        border-left-color: #c0392b; /* ë” ì§„í•œ ë¶‰ì€ìƒ‰ í…Œë‘ë¦¬ */
      }
      .word-a {
        color: #7f8c8d;
      }
      .word-b {
        color: #2c3e50;
      }
      details {
        background-color: #fff;

        margin-bottom: 8px;
      }
      summary {
        padding: 5px;
        cursor: pointer;
        font-weight: normal;
      }
      .axiom-list {
        padding: 5px 15px 15px 35px;
        background-color: #fafafa;
        border-top: 1px solid #eee;
      }
      .axiom-list p {
        margin: 4px 0;
        font-size: 14px;
      }
      .status-bar {
        height: 46px; /* ê³ ì • ë†’ì´ ë¶€ì—¬ (ê°’ì€ ì ì ˆíˆ ì¡°ì ˆ) */
        display: flex; /* ë‚´ë¶€ ìš”ì†Œë¥¼ flexboxë¡œ ì •ë ¬ */
        align-items: center; /* ì„¸ë¡œ ì¤‘ì•™ ì •ë ¬ */
        justify-content: center; /* ê°€ë¡œ ì¤‘ì•™ ì •ë ¬ */
        grid-column: 1 / -1;
        text-align: center;
        padding: 15px;
        font-weight: normal;
        font-size: 1.2em;
        background-color: transparent;
        margin: 0 -40px;
        min-height: 40px; /* Give it some default height */
        background-image: url("assets/images/bottom.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      /* ì´ ì½”ë“œë¥¼ style íƒœê·¸ ì•ˆì— ì¶”ê°€í•˜ì„¸ìš” */
      .player-title-box {
        padding: 10px; /* ë‚´ë¶€ ì—¬ë°± */
        text-align: center; /* í…ìŠ¤íŠ¸ ê°€ìš´ë° ì •ë ¬ */
        background-image: url("assets/images/player.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: contain; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .player-title-box.active-turn {
        background-image: url("assets/images/player_active.png"); /* í„´ì´ í™œì„±í™”ëì„ ë•Œì˜ ì´ë¯¸ì§€ */
      }
      .eureka-btn {
        margin-top: auto;
        padding: 10px 15px;
        border: none;
        font-size: 1.7em;
        cursor: pointer;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/eureka.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .eureka-btn:hover:not(:disabled) {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/eureka_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .eureka-btn:disabled {
        cursor: not-allowed;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/eureka_disabled.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .ability-btn {
        margin-top: 10px; /* ìœ ë ˆì¹´ ë²„íŠ¼ê³¼ì˜ ê°„ê²© */
        padding: 10px 15px;
        border: none;
        font-size: 1.1em;
        cursor: pointer;
        transition: background-color 0.2s;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        /* ê³ ìœ  ëŠ¥ë ¥ ë²„íŠ¼ìš© ì´ë¯¸ì§€ë¥¼ ì¤€ë¹„í•˜ì„¸ìš” (ì˜ˆ: ability.png) */
        border-image-source: url("assets/images/eureka.png"); /* ì„ì‹œë¡œ ìœ ë ˆì¹´ ì´ë¯¸ì§€ ì‚¬ìš© */
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }

      .ability-btn:hover:not(:disabled) {
        border-image-source: url("assets/images/eureka_1.png"); /* ì„ì‹œë¡œ ìœ ë ˆì¹´ í˜¸ë²„ ì´ë¯¸ì§€ ì‚¬ìš© */
      }

      .ability-btn:disabled {
        cursor: not-allowed;
        border-image-source: url("assets/images/eureka_disabled.png"); /* ì„ì‹œë¡œ ìœ ë ˆì¹´ ë¹„í™œì„± ì´ë¯¸ì§€ ì‚¬ìš© */
      }
      #proposition-controls button:disabled {
        color: #464646;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/disabled.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        cursor: not-allowed;
      }
      .modal {
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .modal.visible {
        display: flex;
      }
      .modal-content {
        padding: 25px;
        box-sizing: border-box;
        border-width: 30px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/por.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        position: relative;

        width: 80%;
        max-width: 800px;
        position: relative;
      }
      .modal-content-small {
        box-sizing: border-box;
        border-width: 15px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/por_small.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        position: relative;

        padding: 30px;
        text-align: center;
        max-width: 500px;
        width: 90%;
      }
      .close-button {
        position: absolute;
        padding: 15px;
        top: 17px;
        right: 50px;
        cursor: pointer;
        background-image: url("assets/images/close.png"); /* ğŸ‘ˆ ì•„ì´ì½˜ì€ background-imageë¡œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì•„ì´ì½˜ì´ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì„¤ì • */
        background-size: contain; /* ğŸ‘ˆ ë²„íŠ¼ í¬ê¸°ì— ë§ì¶° ì•„ì´ì½˜ í¬ê¸° ì¡°ì ˆ */
        background-position: center; /* ğŸ‘ˆ ì•„ì´ì½˜ì„ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        border: none; /* í…Œë‘ë¦¬ ì œê±° */
        z-index: 10;
      }
      .close-button:hover {
        background-image: url("assets/images/close_hover.png"); /* ğŸ‘ˆ ì•„ì´ì½˜ì€ background-imageë¡œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤. */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì•„ì´ì½˜ì´ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì„¤ì • */
        background-size: contain; /* ğŸ‘ˆ ë²„íŠ¼ í¬ê¸°ì— ë§ì¶° ì•„ì´ì½˜ í¬ê¸° ì¡°ì ˆ */
        background-position: center; /* ğŸ‘ˆ ì•„ì´ì½˜ì„ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        border: none; /* í…Œë‘ë¦¬ ì œê±° */
        color: black;
      }
      .proof-container {
        background-color: #f5db97;
        display: flex;
        gap: 20px;
        padding-top: 44px;
      }
      .premise-selection {
        flex: 1;
        background-color: #f5db97;
        padding: 0px 15px;

        height: 52vh;
        overflow-y: auto;
      }
      .premise-selection ul {
        list-style-type: none;
        padding: 0;
      }
      .premise-selection li {
        margin-bottom: 5.5px;
        padding: 8px;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/pre_li.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        width: 80%;
        max-width: 800px;
        position: relative;

        cursor: pointer;
      }

      .premise-selection li.assumption-dependent {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/pre_li_assu.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        font-style: italic;
      }
      .premise-selection li.assumption-itself {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/pre_li_assu.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        font-style: italic;
      }
      .premise-selection li:hover {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/pre_li_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .premise-selection li.assumption-dependent:hover {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/pre_li_assu_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        font-style: italic;
      }
      .premise-selection li.assumption-itself:hover {
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/pre_li_assu_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        font-style: italic;
      }
      .premise-selection li span[class^="tag-"] {
        font-weight: bold;
        margin-right: 4px;
      }

      .premise-selection li.selected {
        border-image-source: url("assets/images/pre_li_selected.png");
      }

      /* ê°€ì • ì˜ì¡´ í•­ëª©ì´ ì„ íƒëì„ ë•Œì˜ ìŠ¤íƒ€ì¼ */
      .premise-selection li.assumption-dependent.selected,
      .premise-selection li.assumption-itself.selected {
        border-image-source: url("assets/images/pre_li_assu_selected.png");
      }

      .tag-victory {
        color: #c9a518;
      }
      .tag-theorem,
      .tag-assumption {
        color: #8e44ad;
      }
      .tag-assumption {
        color: #8f2c21; /* ì§„í•œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
      }
      .tag-proposition {
        color: #3498db;
      }
      .tag-axiom {
        color: #7f8c8d;
      }
      #modal-confirm-btn {
        color: white;
        margin-top: 20px;
        padding: 12px 25px;
        font-size: 1.2em;
        border-width: 7px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/modal_confirm.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #modal-confirm-btn:hover {
        border-width: 7px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/modal_confirm_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #workbench-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      #apply-rule-btn {
        color: black;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/full.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #apply-rule-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/full_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #add-assumption-btn {
        color: black;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      #add-assumption-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #add-assumption-btn:disabled {
        display: none;
        cursor: not-allowed;
      }
      #cancel-assumption-btn {
        color: black;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/undo.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #cancel-assumption-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/undo_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #thinking-time-controls {
        /* ë ˆì´ì•„ì›ƒ ë° ìœ„ì¹˜ ì„¤ì • */
        position: absolute; /* ê²¹ì¹˜ë„ë¡ ì„¤ì • */
        inset: 0; /* ğŸ‘ˆ ë¶€ëª¨ ìš”ì†Œë¥¼ ê½‰ ì±„ìš°ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²• (top:0; left:0; right:0; bottom:0;) */
        /* width, height, margin ì†ì„±ì€ ì œê±°í•´ë„ ë©ë‹ˆë‹¤. */
        z-index: 2; /* ë‹¤ë¥¸ ìš”ì†Œë“¤ ìœ„ì— í‘œì‹œ */

        /* ë‚´ìš©ì„ ì¤‘ì•™ì— ë°°ì¹˜í•˜ê¸° ìœ„í•œ Flexbox ì„¤ì • (ì´ ë¶€ë¶„ì€ ê·¸ëŒ€ë¡œ ë‘¡ë‹ˆë‹¤.) */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;

        /* ê¸°ì¡´ ë°°ê²½ ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ ìœ ì§€ */
        padding: 15px;
        border-width: 20px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/papiru_1.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        text-align: center;
      }
      /* JavaScriptì—ì„œ ì‚¬ìš©í•  .hidden í´ë˜ìŠ¤ ê·œì¹™ ì¶”ê°€ */
      #thinking-time-controls.hidden {
        display: none;
      }

      #prompt-input {
        width: 100%;
        padding: 8px;
        margin-top: 15px;
        margin-bottom: 15px;
      }
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }
      .modal-buttons button {
        padding: 8px 16px;

        border: none;
        cursor: pointer;
        font-weight: normal;
      }

      #alert-ok-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #alert-ok-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-confirm-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-confirm-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-cancel-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #prompt-cancel-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      #close-eureka-modal-btn {
        right: 20px;
      }
      #tutorial-modal .modal-content {
        max-width: 800px;
        height: 70vh;
        overflow-y: auto;
      }
      #tutorial-modal h3 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
        margin-top: 20px;
      }
      #tutorial-modal ul {
        list-style-position: inside;
        padding-left: 10px;
      }
      #tutorial-modal li {
        margin-bottom: 10px;
        line-height: 1.6;
      }
      #tutorial-modal code {
        background-color: #e9ecef;
        padding: 2px 6px;
      }
      /* Modal Styles */
      #language-modal .modal-content-small,
      #character-select-modal .modal-content-small {
        border-width: 20px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/por_small.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .selection-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 25px;
      }
      .selection-buttons button {
        padding: 15px 30px;
        font-size: 1.2em;
        font-weight: normal;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */

        cursor: pointer;
      }
      .selection-buttons button:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      /* Tutorial Styles */
      .tutorial-highlight {
        box-shadow: 0 0 0 4px #639bff, 0 0 20px #6da2ff; /* ğŸ‘ˆ íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½ */

        transition: box-shadow 0.3s ease-in-out;
        position: relative;
        z-index: 101; /* Ensure it's above other elements */
      }
      #tutorial-guide,
      #puzzle-goal-box {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(44, 62, 80, 0.9);
        color: white;
        padding: 20px;
        width: 80%;
        max-width: 800px;
        text-align: left; /* í…ìŠ¤íŠ¸ëŠ” ì¢Œì¸¡ ì •ë ¬ ìœ ì§€ */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        z-index: 200;
        display: flex;
        flex-direction: column;
        align-items: flex-start; /* ê¸°ë³¸ ì •ë ¬ì€ ì¢Œì¸¡ìœ¼ë¡œ ìœ ì§€ */
        gap: 15px;
        transition: top 0.3s ease-in-out, bottom 0.3s ease-in-out;
      }

      #tutorial-guide button {
        align-self: center; /* ë²„íŠ¼ ìê¸° ìì‹ ë§Œ ì¤‘ì•™ìœ¼ë¡œ ì •ë ¬ */
      }
      #tutorial-guide.top,
      #puzzle-goal-box {
        top: 20px;
        bottom: auto;
      }
      #tutorial-guide p,
      #puzzle-goal-box p {
        margin: 0;
        font-size: 1.1em;
        line-height: 1.6;
      }
      #puzzle-goal-box p {
        z-index: 9999;
      }
      #tutorial-guide button {
        padding: 10px 25px;
        font-size: 1em;
        font-weight: normal;
        border: none;

        cursor: pointer;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        transform: translateY(-3px);
        color: #2c3e50;

        display: flex;
        align-items: center;
      }
      #tutorial-guide button:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      .hidden {
        display: none !important;
      }

      #tutorial-guide button::after {
        content: "";
        display: inline-block;
        width: 32px; /* ì•„ì´ì½˜ ë„ˆë¹„ */
        height: 20px; /* ì•„ì´ì½˜ ë†’ì´ */
        margin-left: 3px; /* í…ìŠ¤íŠ¸ì™€ì˜ ê°„ê²© */
        background-image: url("assets/images/next_icon.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ì•„ì´ì½˜ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-size: contain;
        background-repeat: no-repeat;
      }

      .turn-indicator {
        display: inline-block;
        padding: 8px 20px; /* ë‚´ë¶€ ì—¬ë°± *
              transition: all 0.3s ease; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼ */
        text-align: center; /* í…ìŠ¤íŠ¸ ê°€ìš´ë° ì •ë ¬ */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/indi.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }

      button,
      select {
        font-family: inherit;
      }
      #info-box > div {
        position: relative; /* ìœ„ì¹˜ë¥¼ ìƒëŒ€ì ìœ¼ë¡œ ì¡°ì •í•˜ë„ë¡ ì„¤ì • */
        top: 6px; /* ğŸ‘ˆ ì›ë˜ ìœ„ì¹˜ì—ì„œ 5px ì•„ë˜ë¡œ ì´ë™ */
      }
      .header-buttons-left,
      .header-buttons-right {
        flex: 1; /* ì–‘ìª½ ì»¨í…Œì´ë„ˆê°€ ë™ì¼í•œ ë„ˆë¹„ë¥¼ ê°–ë„ë¡ ì„¤ì • */
      }

      /* ì˜¤ë¥¸ìª½ ë²„íŠ¼ë“¤ì„ ì˜¤ë¥¸ìª½ ëìœ¼ë¡œ ì •ë ¬ */
      .header-buttons-right {
        justify-content: flex-end;
      }
      /* ìŠ¹ë¦¬ ì¡°ê±´ í…ìŠ¤íŠ¸ì˜ strong íƒœê·¸ ë³¼ë“œì²´ ì œê±° */
      #true-propositions li.victory-condition strong {
        font-weight: normal;
      }
      /* ê¸°ì¡´ ì½”ë“œ */
      #proposition-controls button {
        padding: 8px 15px;
        cursor: pointer;
        font-size: 14px;
        font-weight: normal;
        transition: background-color 0.2s;
        /* ğŸ‘‡ ì•„ë˜ ì†ì„± ì¶”ê°€ */
        min-width: 100px; /* ì›í•˜ëŠ” ìµœì†Œ ë„ˆë¹„ë¡œ ì¡°ì ˆ (ì˜ˆ: 100px) */
        box-sizing: border-box; /* paddingì„ ë„ˆë¹„ì— í¬í•¨ì‹œì¼œ ê³„ì‚° */
      }
      /* íŠœí† ë¦¬ì–¼ ëŒ€í™”ì°½ì„ ê°•ì œë¡œ ìµœìƒë‹¨ì— í‘œì‹œí•˜ê¸° ìœ„í•œ ê·œì¹™ */
      #tutorial-guide {
        z-index: 9999 !important;
      }
      /* ìƒˆë¡œ ì¶”ê°€: í„´ì´ ì•„ë‹ ë•Œ ì¹´ë“œì— ì§ì ‘ íë¦¼ ë° ë°˜íˆ¬ëª… íš¨ê³¼ ì ìš© */
      /* í„´ì´ ì•„ë‹ ë•Œ ì¹´ë“œì˜ ë°ê¸°ì™€ ëŒ€ë¹„ë¥¼ ì¡°ì ˆ */
      .player-area.disabled .card {
        filter: brightness(0.8) contrast(0.8);
      }
      .card.unplayable {
        filter: brightness(0.8) contrast(0.8);
        cursor: not-allowed;
      }
      #workbench-controls select,
      #workbench-controls button {
        font-size: 14px; /* ê¸€ì í¬ê¸°ë¥¼ 14pxì—ì„œ 16pxë¡œ í‚¤ì›ë‹ˆë‹¤ */
        padding: 10px 20px; /* ë²„íŠ¼ì˜ ìƒí•˜, ì¢Œìš° ì—¬ë°±ì„ ëŠ˜ë¦½ë‹ˆë‹¤ */
      }

      /* ë§ì”Œìš¸ ì´ë¯¸ì§€ë“¤ì„ ë‹´ëŠ” ì»¨í…Œì´ë„ˆ */
      #overlay-container {
        position: absolute; /* ë¶€ëª¨ ìœ„ì— ê²¹ì¹˜ë„ë¡ ì„¤ì • */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* ë§ì”Œìš¸ ê°œë³„ ì´ë¯¸ì§€ */
      .overlay-image {
        position: absolute; /* ì»¨í…Œì´ë„ˆ ìœ„ì— ê²¹ì¹˜ë„ë¡ ì„¤ì • */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      /* ì´ë¯¸ì§€ë¥¼ ìˆ¨ê¸°ëŠ” í•µì‹¬ í´ë˜ìŠ¤ */
      .hidden {
        display: none !important; /* â˜…â˜…â˜…â˜…â˜… ê°€ì¥ ì¤‘ìš”! */
      }
      #socrates-wise-overlay,
      #socrates-foolish-overlay,
      #socrates-good-overlay,
      #socrates-evil-overlay,
      #plato-wise-overlay,
      #plato-foolish-overlay,
      #plato-good-overlay,
      #plato-evil-overlay,
      #socrates-bird-overlay,
      #socrates-fish-overlay,
      #plato-bird-overlay,
      #plato-fish-overlay,
      #socrates-win-overlay,
      #plato-win-overlay {
        z-index: 1;
      }
      #socrates-dog-overlay,
      #plato-dog-overlay {
        z-index: 2;
      }

      #player-a-area {
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/images/paper_1.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }

      #player-b-area {
        /* 1. ì´ë¯¸ì§€ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° */
        background-image: url("assets/images/paper.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      /* style íƒœê·¸ ì•ˆ, ê°€ì¥ ì•„ë˜ìª½ì— ì¶”ê°€ */
      body::after {
        position: absolute;
        width: 0;
        height: 0;
        overflow: hidden;
        z-index: -1; /* í™”ë©´ì— ë³´ì´ì§€ ì•Šê²Œ ì²˜ë¦¬ */
        content:
      /* ê¸°ë³¸ UI ë° ë°°ê²½ ì´ë¯¸ì§€ */ url("assets/images/sky.png")
          url("assets/images/title.png") url("assets/images/roof.png")
          url("assets/images/roo.png") url("assets/images/roo_2.png")
          url("assets/images/bottom.png") url("assets/images/paper.png")
          url("assets/images/paper_1.png") url("assets/images/player.png")
          url("assets/images/player_active.png") url("assets/images/papiru.png")
          url("assets/images/rendom_hover.png")
          url("assets/images/papiru_1.png") url("assets/images/sel.png")
          url("assets/images/por.png") url("assets/images/por_small.png")
          url("assets/images/pre_li.png") url("assets/images/pre_li_assu.png")
          url("assets/images/pre_li_assu_selected.png")
          url("assets/images/pre_li_selected.png") url("assets/images/indi.png")
          url("assets/images/close.png") /* ë²„íŠ¼ ê¸°ë³¸ ì´ë¯¸ì§€ */
          url("assets/images/new.png") url("assets/images/full.png")
          url("assets/images/tuto.png") url("assets/images/complete.png")
          url("assets/images/undo.png") url("assets/images/end.png")
          url("assets/images/eureka.png") url("assets/images/disabled.png")
          url("assets/images/eureka_disabled.png") /* ë²„íŠ¼ í˜¸ë²„(Hover) ì´ë¯¸ì§€ */
          url("assets/images/new_hover.png") url("assets/images/full_hover.png")
          url("assets/images/tuto_hover.png")
          url("assets/images/level_hover.png") url("assets/images/level.png")
          url("assets/images/level_cleared_hover.png")
          url("assets/images/level_cleared.png")
          url("assets/images/complete_hover.png")
          url("assets/images/undo_hover.png") url("assets/images/end_hover.png")
          url("assets/images/eureka_1.png") url("assets/images/close_hover.png")
          url("assets/images/pre_li_hover.png")
          url("assets/images/pre_li_assu_hover.png") /* ì¹´ë“œ ì´ë¯¸ì§€ */
          url("assets/images/card_white.png")
          url("assets/images/card_black.png")
          url("assets/images/card_white_hover.png")
          url("assets/images/card_black_hover.png")
          /* ì² í•™ì ì´ˆìƒí™” ë° ì•„ì´ì½˜ (JavaScriptì— ì •ì˜ëœ ê²½ë¡œ í¬í•¨) */
          url("assets/images/ari_p1.png") url("assets/images/ari_p2.png")
          url("assets/images/ari_icon.png") url("assets/images/socrat_p1.png")
          url("assets/images/socrat_p2.png") url("assets/images/socra_icon.png")
          url("assets/images/pl_p1.png") url("assets/images/pl_p2.png")
          url("assets/images/pl_icon.png") url("assets/images/de_p1.png")
          url("assets/images/de_p2.png") url("assets/images/de_icon.png")
          url("assets/images/hu_p1.png") url("assets/images/hu_p2.png")
          url("assets/images/hu_icon.png") url("assets/images/ka_p1.png")
          url("assets/images/ka_p2.png") url("assets/images/ka_icon.png")
          url("assets/images/ni_p1.png") url("assets/images/ni_p2.png")
          url("assets/images/ni_icon.png") url("assets/images/ma_p1.png")
          url("assets/images/ma_p2.png") url("assets/images/ma_icon.png")
          url("assets/images/wi_p1.png") url("assets/images/wi_p2.png")
          url("assets/images/wi_icon.png") url("assets/images/ku_p1.png")
          url("assets/images/ku_p2.png") url("assets/images/ku_icon.png")
          url("assets/images/der_p1.png") url("assets/images/der_p2.png")
          url("assets/images/der_icon.png");
      }

      /* ...existing code... */
      .main-center-bg {
        position: absolute;
        inset: 0; /* top:0; right:0; bottom:0; left:0; */
        width: 95%;
        height: 95%;
        background: transparent;
        z-index: 1; /* ë°°ê²½ ì—­í•  */
        pointer-events: auto;
        border-width: 17px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/papiru_1.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column; /* ì„¸ë¡œë¡œ ë°°ì¹˜ */
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column;
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .mode-selector {
        display: flex;
        flex-direction: column; /* ë²„íŠ¼ì„ ì„¸ë¡œë¡œ ë°°ì¹˜ */
        gap: 30px; /* ë²„íŠ¼ ì‚¬ì´ ë„‰ë„‰í•˜ê²Œ */
        width: 100%;
      }

      .mode-selector button,
      #exit-game-btn,
      #tutorial-btn,
      #puzzle-mode-btn {
        min-width: 0;
        width: 100%;
        max-width: 1000px;
        padding: 8px 50px; /* ìœ„ì•„ë˜ ì¢ê²Œ, ì¢Œìš° ë„“ê²Œ */
        font-size: 1.5em;
        box-sizing: border-box;
      }

      .main-center-bg.hidden {
        display: none !important;
      }

      /* Add these CSS rules inside the <style> tag */

      #character-selection-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 40px;
        box-sizing: border-box;
      }

      #character-selection-screen.hidden {
        display: none !important;
      }

      .player-display-area {
        width: 28%;
        height: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 22px;
        box-sizing: border-box;
        border-width: 25px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/por.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        position: relative;
      }

      .portrait-area {
        width: 100%;
        height: 50%;
        background-color: #b19c6f;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        image-rendering: pixelated;
        border: 6px solid #9a4b37;
      }

      .philosopher-name {
        font-size: 2.5em;
        color: #9a4b37;
        margin-top: 20px;
        font-weight: bold;
      }

      .skill-area {
        width: 100%;
        margin-top: 20px;
        text-align: left;
      }

      .skill-title {
        font-size: 1.5em;
        color: #333;
        border-bottom: 2px solid #b95941;
        padding-bottom: 5px;
        margin-bottom: 10px;
      }

      #p1-skill-desc,
      #p2-skill-desc {
        font-size: 1.1em;
        line-height: 1.6;
      }

      .ready-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: transparent;
        color: transparent;
        font-size: 8em;
        display: none; /* Initially hidden */
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }

      .ready-overlay.visible {
        display: flex;
      }

      .shared-selection-area {
        width: 40%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        padding: 22px;
        box-sizing: border-box;
        border-width: 27px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/sel.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }

      .char-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr); /* 4ì—´ ê·¸ë¦¬ë“œ, í•„ìš”ì‹œ ì¡°ì • */
        gap: 15px;
        width: 100%;
        padding: 20px;
        background-color: transparent;
      }

      .char-icon {
        aspect-ratio: 1 / 1;
        background-size: cover;
        background-position: center;
        border: 4px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
        image-rendering: pixelated;
      }

      .char-icon:hover {
        border-color: #f1cf0f;
        transform: scale(1.05);
      }

      .char-icon.selected {
        border-color: #e74c3c;
        box-shadow: 0 0 15px #e74c3c;
      }

      #confirm-selection-btn {
        padding: 15px 50px;
        font-size: 1.8em;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/complete.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
        cursor: pointer;
        background-color: transparent;
        color: white;
      }

      #confirm-selection-btn:hover:not(:disabled) {
        background-color: transparent;
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/complete_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
      }

      #confirm-selection-btn:disabled {
        color: #7f8c8d; /* ë¹„í™œì„±í™”ëœ ë²„íŠ¼ì˜ ê¸€ììƒ‰ */
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        border-color: transparent;

        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/disabled.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
        image-rendering: pixelated;
        background-color: transparent;
        cursor: not-allowed;
      }

      #turn-order-modal .modal-content-small h2 {
        font-size: 1.8em;
        margin-bottom: 25px;
      }
      #character-select-indicator {
        font-size: 20px;
        position: fixed; /* í™”ë©´ì— ê³ ì • */
        bottom: 30px; /* í•˜ë‹¨ì—ì„œì˜ ê±°ë¦¬ (ê¸°ì¡´ status-barì™€ ë¹„ìŠ·í•˜ê²Œ) */
        left: 50%; /* ì¢Œìš° ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ì„¤ì • */
        transform: translateX(-50%); /* ì¢Œìš° ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ì„¤ì • */
        z-index: 501; /* ìºë¦­í„° ì„ íƒ í™”ë©´(z-index: 500)ë³´ë‹¤ ìœ„ì— í‘œì‹œ */
      }
      .philosopher-portrait {
        width: 180px;
        height: 180px;
        margin: 8px auto;
        border: 4px solid #e2965c;
        background-color: #eedaa5;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        image-rendering: pixelated;
      }

      #back-to-main-from-char-select-btn {
        top: 25px;
        right: 25px;
        width: 32px;
        height: 32px;
        padding: 0;
        z-index: 502; /* ë‹¤ë¥¸ ìš”ì†Œë“¤ë³´ë‹¤ ìœ„ì— í‘œì‹œë˜ë„ë¡ z-index ì„¤ì • */
      }
      #bottom-overlay-box {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 150px;
        background-image: url("assets/images/roo_2.png");
        background-repeat: no-repeat;
        background-size: cover;
        background-position: center;
        image-rendering: pixelated;
        background-color: transparent;
        z-index: 5;
      }

      .true-propositions-wrapper {
        position: relative; /* â˜… ì˜¤ë²„ë ˆì´ì˜ ìƒˆë¡œìš´ ê¸°ì¤€ì  */
        flex-grow: 1;
        flex-shrink: 1;
        flex-basis: 0;
        min-height: 0;
        display: flex; /* ë‚´ë¶€ ìš”ì†Œë“¤ì„ ì±„ìš°ê¸° ìœ„í•¨ */
      }
      #game-container,
      .card,
      button,
      .modal-content,
      .player-display-area,
      .shared-selection-area,
      #current-proposition,
      #true-propositions,
      .main-center-bg {
        -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
        backface-visibility: hidden;
        transform: translateZ(0); /* GPU ë Œë”ë§ ë ˆì´ì–´ ìƒì„± ìœ ë„ */
      }
      .button-wrapper {
        display: flex; /* í•µì‹¬: ë‚´ë¶€ ì•„ì´í…œì„ ê°€ë¡œë¡œ ë‚˜ë€íˆ ë°°ì¹˜ */
        width: 100%;
        gap: 8px; /* ë²„íŠ¼ ì‚¬ì´ì˜ ê°„ê²© */
        margin-top: auto; /* í”Œë ˆì´ì–´ ì˜ì—­ì˜ ë§¨ ì•„ë˜ì— ë²„íŠ¼ë“¤ì„ ìœ„ì¹˜ì‹œí‚´ */
      }

      /* 2. ê¸°ì¡´ ë²„íŠ¼ ìŠ¤íƒ€ì¼ì— flex ì†ì„± ì¶”ê°€ */
      .eureka-btn,
      .ability-btn {
        flex: 1; /* í•µì‹¬: ì»¨í…Œì´ë„ˆ ì•ˆì—ì„œ ê°€ëŠ¥í•œ ê³µê°„ì„ ê· ë“±í•˜ê²Œ ì°¨ì§€ */

        /* ê¸€ìê°€ ì˜ë¦¬ì§€ ì•Šë„ë¡ íŒ¨ë”©ì´ë‚˜ í°íŠ¸ í¬ê¸° ë¯¸ì„¸ ì¡°ì • */
        padding: 8px;
        font-size: 1em;
        min-width: 0; /* ë²„íŠ¼ì´ ì‘ì•„ì§ˆ ìˆ˜ ìˆë„ë¡ ìµœì†Œ ë„ˆë¹„ ì œí•œ í•´ì œ */
      }
      #ability-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      #ability-list li {
        margin-bottom: 5px;
        padding: 8px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/pre_li.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      #ability-list li:hover {
        border-image-source: url("assets/images/pre_li_hover.png");
      }

      #ability-list input[type="radio"] {
        margin-right: 10px;
      }

      /* ë²”ìš© ëŠ¥ë ¥ ëª¨ë‹¬ í™•ì¸ ë²„íŠ¼ ìŠ¤íƒ€ì¼ (ëˆ„ë½ë˜ì—ˆë˜ ë¶€ë¶„) */
      #ability-confirm-btn {
        color: white;
        margin-top: 20px;
        padding: 10px 15px;
        font-size: 1.2em;
        border-width: 7px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/modal_confirm.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
        cursor: pointer;
      }

      #ability-confirm-btn:hover {
        border-image-source: url("assets/images/modal_confirm_hover.png");
      }

      /* ëª¨ë‹¬ ì œëª©ì˜ ìƒ‰ìƒì´ ì§€ì •ë˜ì§€ ì•Šì•˜ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ì½”ë“œ */
      #plato-ability-title {
        color: #333; /* ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
        margin-bottom: 20px;
      }

      #kant-ability-modal .modal-content {
        display: flex;
        flex-direction: column;
        height: 80vh;
      }

      /* 1. í…Œë‘ë¦¬ì™€ ë°°ê²½ ì œê±°, flex-growë¥¼ í†µí•´ ìƒí•˜ ê³µê°„ ë¶„í•  */
      #kant-proposition-area,
      #kant-hand-area {
        padding: 10px;
        margin-bottom: 15px;
        display: flex; /* ë‚´ë¶€ ìš”ì†Œ(ì œëª©, ì¹´ë“œ ì»¨í…Œì´ë„ˆ)ë¥¼ ì •ë ¬í•˜ê¸° ìœ„í•´ flexë¡œ ì„¤ì • */
        flex-direction: column;
        flex: 1; /* í•µì‹¬: ë‘ ì„¹ì…˜ì´ 1:1 ë¹„ìœ¨ë¡œ ê³µê°„ì„ ì°¨ì§€ */
        min-height: 0; /* flex ìì‹ ìš”ì†Œê°€ ë¶€ëª¨ë¥¼ ë„˜ì¹˜ì§€ ì•Šë„ë¡ ì„¤ì • */
      }

      #kant-proposition-area h3,
      #kant-hand-area h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #9a4b37;
        border-bottom: 1px solid #d3b88b;
        padding-bottom: 5px;
        flex-shrink: 0; /* ì œëª©ì˜ í¬ê¸°ê°€ ì¤„ì–´ë“¤ì§€ ì•Šë„ë¡ ê³ ì • */
      }

      #kant-proposition-display {
        min-height: 80px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      #kant-hand-display {
        flex-grow: 1; /* ë‚¨ì€ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        overflow-y: auto;
      }

      /* 2. í˜¸ë²„ íš¨ê³¼ ì‚­ì œë¨ (í•´ë‹¹ ì„ íƒì ì œê±°) */

      #kant-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
        flex-shrink: 0; /* ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ì˜ì—­ í¬ê¸° ê³ ì • */
      }

      #kant-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
      }

      /* ê¸°ì¡´ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì¬í™œìš© */
      #kant-undo-btn,
      #kant-confirm-btn {
        padding: 8px 25px;
        font-size: 1.1em;
        min-width: 120px;
      }
      #kant-undo-btn {
        color: white;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/undo.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #kant-undo-btn:hover {
        border-image-source: url("assets/images/undo_hover.png");
      }
      #kant-confirm-btn {
        color: white;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/complete.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #kant-confirm-btn:hover {
        border-image-source: url("assets/images/complete_hover.png");
      }

      #ai-summary-ok-btn {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #ai-summary-ok-btn:hover {
        border-width: 5px; /* í…Œë‘ë¦¬ë¡œ ì‚¬ìš©í•  ì´ë¯¸ì§€ ì˜ì—­ì˜ ë‘ê»˜ */
        border-style: solid;
        /* 9ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆŒ ì´ë¯¸ì§€ (ë°°ê²½ íŒ¨í„´ í¬í•¨) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* ì´ë¯¸ì§€ë¥¼ 10px ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê³ , ê°€ìš´ë° ë¶€ë¶„ìœ¼ë¡œ ë°°ê²½ì„ ì±„ì›€ */
        border-image-slice: 6 fill; /* ğŸ‘ˆ fill í‚¤ì›Œë“œ ì¶”ê°€ê°€ í•µì‹¬! */

        /* ë„ˆë¹„ë‚˜ ë†’ì´ê°€ ë³€í•´ë„ ê¹¨ì§€ì§€ ì•Šë„ë¡ ì„¤ì • */
        border-image-repeat: stretch;
        background-color: transparent; /* ë²„íŠ¼ì˜ ë°°ê²½ìƒ‰ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • */
      }
      #settings-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        /* ì„ì‹œë¡œ ì „ì²´í™”ë©´ ë²„íŠ¼ ì´ë¯¸ì§€ë¥¼ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤.
             ë‚˜ì¤‘ì— settings.png, settings_hover.png ê°™ì€ ì „ìš© ì´ë¯¸ì§€ë¡œ êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. */
        border-image-source: url("assets/images/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #settings-btn:hover {
        border-image-source: url("assets/images/full_hover.png");
      }

      /* ì„¤ì • ëª¨ë‹¬ ë‚´ë¶€ ìŠ¤íƒ€ì¼ */
      .settings-group {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        width: 100%;
        max-width: 350px;
        margin-left: auto;
        margin-right: auto;
      }
      .settings-group label {
        font-size: 1.2em;
        margin-right: 15px;
      }
      .settings-group input[type="range"] {
        flex-grow: 1; /* ë‚¨ëŠ” ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
      }
      .settings-group span {
        font-size: 1.2em;
        margin-left: 15px;
        width: 50px; /* ë„ˆë¹„ë¥¼ ê³ ì •í•˜ì—¬ ì •ë ¬ì„ ë§ì¶¤ */
        text-align: right;
      }
      button:focus,
      select:focus {
        outline: none;
      }
      #credits-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        /* ì„ì‹œë¡œ ì „ì²´í™”ë©´ ë²„íŠ¼ ì´ë¯¸ì§€ë¥¼ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤.
             ë‚˜ì¤‘ì— settings.png, settings_hover.png ê°™ì€ ì „ìš© ì´ë¯¸ì§€ë¡œ êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. */
        border-image-source: url("assets/images/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #credits-btn:hover {
        border-image-source: url("assets/images/full_hover.png");
      }
      #vs-ai-test-btn,
      #vs-ai-battle-btn,
      #tutorial-puzzle-btn,
      #exit-game-btn {
        display: none;
      }

      #random-char-btn {
        background-image: url("assets/images/random_hover.png"); /* ì´ë¯¸ì§€ ê²½ë¡œ ì§€ì • */
        background-size: contain; /* ì´ë¯¸ì§€ê°€ ì˜ë¦¬ì§€ ì•Šê³  ë¹„ìœ¨ì— ë§ê²Œ ì±„ì›Œì§ */
        background-repeat: no-repeat; /* ì´ë¯¸ì§€ê°€ ë°˜ë³µë˜ì§€ ì•Šë„ë¡ ì„¤ì • */
        background-position: center; /* ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        transition: background-image 0.4s; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼ (ì„ íƒ ì‚¬í•­) */

        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
      }
      #random-char-btn:hover {
        background-image: url("assets/images/random_hover.png");
        transform: none !important; /* í™•ëŒ€ íš¨ê³¼ë¥¼ ì œê±°í•©ë‹ˆë‹¤ */
        transition: none !important;
        border-color: transparent; /* í˜¸ë²„ ì‹œ í…Œë‘ë¦¬ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•Šë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤ */
      }
      .hand,
      #true-propositions,
      .premise-selection,
      #kant-hand-display,
      #credits-content {
        /* í•¸ë“¤ ìƒ‰ìƒ, íŠ¸ë™ ìƒ‰ìƒ */
        scrollbar-color: #b15139 transparent;
        scrollbar-width: thin;
      }

      /* 2. Chrome, Safari, Edge ë“± Webkit ë¸Œë¼ìš°ì €ë¥¼ ìœ„í•œ ìƒì„¸ ìŠ¤íƒ€ì¼ */
      ::-webkit-scrollbar {
        width: 14px; /* ìŠ¤í¬ë¡¤ë°” ë„ˆë¹„ */
        height: 14px; /* ê°€ë¡œ ìŠ¤í¬ë¡¤ë°” ë†’ì´ (í•„ìš”ì‹œ) */
      }

      ::-webkit-scrollbar-track {
        background-color: transparent; /* hand ì˜ì—­ ë°°ê²½ê³¼ ìœ ì‚¬í•œ ë°˜íˆ¬ëª… ìƒ‰ìƒ */
      }

      ::-webkit-scrollbar-thumb {
        background-color: #b15139; /* í”Œë ˆì´ì–´ ì˜ì—­ ë°°ê²½ìƒ‰ */
        border: 2px solid #9a4b37; /* í…Œë‘ë¦¬ë¥¼ ì£¼ì–´ ì…ì²´ê° ë¶€ì—¬ */
      }

      ::-webkit-scrollbar-thumb:hover {
        background-color: #9a4b37; /* ë§ˆìš°ìŠ¤ ì˜¬ë¦¬ë©´ ë” ì§„í•œ ìƒ‰ìœ¼ë¡œ */
      }

      /* ìŠ¤í¬ë¡¤ë°”ì˜ ì–‘ ë í™”ì‚´í‘œ ë²„íŠ¼ (ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ìˆ¨ê¹€) */
      ::-webkit-scrollbar-button {
        display: none;
      }
      #emergency-exit-tutorial-btn {
        /* ìœ„ì¹˜ ë° z-indexëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€í•©ë‹ˆë‹¤ */
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;

        /* í…ìŠ¤íŠ¸ì™€ í…Œë‘ë¦¬ ìŠ¤íƒ€ì¼ì„ ì¶”ê°€í•©ë‹ˆë‹¤ */
        padding: 4px 12px;
        font-size: 15px; /* body ê¸°ë³¸ í°íŠ¸ í¬ê¸°ì™€ ë§ì¶¤ */
        color: #333; /* ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
        cursor: pointer;

        /* ì¸í¬ë°•ìŠ¤ ë²„íŠ¼ ìŠ¤íƒ€ì¼ (border-image)ì„ ì ìš©í•©ë‹ˆë‹¤ */
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/tuto.png"); /* íŠœí† ë¦¬ì–¼ ë²„íŠ¼ ì´ë¯¸ì§€ ì¬í™œìš© */
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }

      /* í˜¸ë²„ íš¨ê³¼ë„ ìˆ˜ì •í•©ë‹ˆë‹¤ */
      #emergency-exit-tutorial-btn:hover {
        border-image-source: url("assets/images/tuto_hover.png");
      }
      .op-not {
        color: #e74c3c; /* ë¹¨ê°„ìƒ‰ */
        font-weight: bold;
      }
      .op-if {
        color: #27ae60; /* ì´ˆë¡ìƒ‰ */
        font-weight: bold;
      }
      .op-or {
        color: #2876aa; /* íŒŒë€ìƒ‰ */
        font-weight: bold;
      }
      .op-and {
        color: #f39c12; /* ë…¸ë€ìƒ‰/ì£¼í™©ìƒ‰ ê³„ì—´ */
        font-weight: bold;
      }
      #info-box button[style*="visibility: hidden"] {
        display: none;
      }
      #mode-description {
        position: absolute; /* ë²„íŠ¼ ì»¨í…Œì´ë„ˆë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìœ„ì¹˜ ì§€ì • */
        left: 100%; /* ë²„íŠ¼ ì»¨í…Œì´ë„ˆì˜ ì˜¤ë¥¸ìª½ ëì— ë¶™ì„ */
        top: 0; /* ì´ˆê¸° top ìœ„ì¹˜ (JSê°€ ë²„íŠ¼ì— ë§ì¶° ë³€ê²½) */
        transform: translate(
          25px,
          -50%
        ); /* ì˜¤ë¥¸ìª½ìœ¼ë¡œ 25px ì´ë™í•˜ê³ , ìˆ˜ì§ ì¤‘ì•™ ì •ë ¬ */

        width: 280px; /* ì„¤ëª… ë°•ìŠ¤ ë„ˆë¹„ */
        padding: 15px;
        font-size: 17px; /* ì‘ì€ ê¸€ì”¨ í¬ê¸° */
        color: #333;
        text-align: left;
        line-height: 1.6;

        /* 9ì¡°ê° ì´ë¯¸ì§€ë¡œ ë°°ê²½ ì„¤ì • (ê¸°ì¡´ UIì™€ í†µì¼ê°) */
        border-width: 15px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/por_long.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;

        /* í‰ì†Œì—ëŠ” ë³´ì´ì§€ ì•Šë„ë¡ ì„¤ì • */
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ì— ë°˜ì‘í•˜ì§€ ì•Šë„ë¡ ì„¤ì • */
      }

      #puzzle-level-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr); /* í•œ ì¤„ì— 5ê°œì˜ ë ˆë²¨ */
        gap: 20px; /* ë ˆë²¨ ê°„ ê°„ê²© */
        width: 100%;
        padding: 20px;
        margin-top: 20px;
        box-sizing: border-box;
        max-height: 50vh; /* ëª¨ë‹¬ ë†’ì´ê°€ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šë„ë¡ ì œí•œ */
        overflow-y: auto; /* ë ˆë²¨ì´ ë§ì•„ì§€ë©´ ìŠ¤í¬ë¡¤ */
      }

      /* ìºë¦­í„° ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ì„ ì¬í™œìš©í•˜ì—¬ ë ˆë²¨ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì§€ì • */
      .puzzle-level-btn {
        aspect-ratio: 1 / 1;
        background-image: url("assets/images/level.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
        image-rendering: pixelated;

        /* ë ˆë²¨ ë²ˆí˜¸ë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•œ Flexbox ì„¤ì • */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2em;
        font-weight: bold;
        background-color: transparent;
      }

      .puzzle-level-btn:hover {
        background-image: url("assets/images/level_hover.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      .puzzle-level-btn.cleared {
        aspect-ratio: 1 / 1;
        background-image: url("assets/images/level_cleared.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
        image-rendering: pixelated;

        /* ë ˆë²¨ ë²ˆí˜¸ë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•œ Flexbox ì„¤ì • */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2em;
        font-weight: bold;
        background-color: transparent;
      }
      .puzzle-level-btn.cleared:hover {
        background-image: url("assets/images/level_cleared_hover.png"); /* ğŸ‘ˆ ì‚¬ìš©í•  ë‹¨ì¼ ì´ë¯¸ì§€ ê²½ë¡œ */
        background-repeat: no-repeat; /* ğŸ‘ˆ ì´ë¯¸ì§€ ë°˜ë³µ ì•ˆ í•¨ */
        background-size: cover; /* ğŸ‘ˆ ë°•ìŠ¤ë¥¼ ë®ë„ë¡ í¬ê¸° ì¡°ì ˆ (ë˜ëŠ” contain) */
        background-position: center; /* ğŸ‘ˆ ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ë°°ì¹˜ */
        image-rendering: pixelated;
      }
      #puzzle-level-select-modal .shared-selection-area {
        width: 60%; /* ëª¨ë‹¬ì— ì í•©í•˜ë„ë¡ ë„ˆë¹„ë¥¼ 60%ë¡œ ì¡°ì • */
        max-width: 900px; /* ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šë„ë¡ ìµœëŒ€ ë„ˆë¹„ ì„¤ì • */
      }

      /* ë‹«ê¸° ë²„íŠ¼ ìœ„ì¹˜ ë¯¸ì„¸ ì¡°ì • */
      #puzzle-level-select-modal .close-button {
        top: 35px;
        right: 45px;
      }
      #conclusion-preview {
        margin-top: 5px; /* 15pxì—ì„œ ìˆ˜ì • */
        padding: 12px 15px; /* ìƒí•˜ ì—¬ë°±ì„ 15pxì—ì„œ 8pxë¡œ ìˆ˜ì • */
        box-sizing: border-box;
      }
      #conclusion-preview-title {
        margin: 0 0 8px 0;
        font-size: 1.2em;
        font-weight: normal;
      }
      #conclusion-preview-text {
        font-size: 1.2em;
        font-weight: normal;
      }
      #conclusion-preview-text i {
        font-style: italic;
        color: #7f8c8d;
      }
      /* 1. ëª¨ë‹¬ ì½˜í…ì¸  ì˜ì—­ì„ ìì‹ ìš”ì†Œì˜ 'position: absolute' ê¸°ì¤€ì ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. */
      #eureka-modal .modal-content {
        position: relative;
      }

      /* 2. ê²°ë¡  ë¯¸ë¦¬ë³´ê¸° ì„¹ì…˜ì„ ì¼ë°˜ì ì¸ íë¦„ì—ì„œ ì œì™¸í•˜ê³ , ìœ„ì¹˜ë¥¼ ì§ì ‘ ì§€ì •í•©ë‹ˆë‹¤. */
      #conclusion-preview {
        position: absolute;
        top: 135px; /* ì œëª©ê³¼ ì›Œí¬ë²¤ì¹˜ ì»¨íŠ¸ë¡¤ì˜ ë†’ì´ì— ë§ì¶° ì¡°ì •ëœ ê°’ì…ë‹ˆë‹¤. */
        left: 25px; /* ë¶€ëª¨ ìš”ì†Œì˜ ì¢Œì¸¡ íŒ¨ë”©ê³¼ ë™ì¼í•œ ê°’ì…ë‹ˆë‹¤. */
        width: calc(
          100% - 50px
        ); /* ë¶€ëª¨ ìš”ì†Œì˜ ì¢Œìš° íŒ¨ë”©ì„ ì œì™¸í•œ ë„ˆë¹„ì…ë‹ˆë‹¤. */
        z-index: 10; /* ë‹¤ë¥¸ ìš”ì†Œë“¤ ìœ„ì— í‘œì‹œë˜ë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤. */
        background-color: #f5db97; /* ë°°ê²½ìƒ‰ì„ ì¶”ê°€í•˜ì—¬ ì•„ë˜ í…ìŠ¤íŠ¸ê°€ ë¹„ì¹˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤. */
      }
      #main-menu-title-img {
        width: 80%; /* ì´ë¯¸ì§€ ë„ˆë¹„ */
        max-width: 500px; /* ìµœëŒ€ ë„ˆë¹„ */
        height: auto; /* ë†’ì´ëŠ” ë¹„ìœ¨ì— ë§ê²Œ ìë™ ì¡°ì ˆ */
        margin-bottom: 40px; /* ë²„íŠ¼ê³¼ì˜ ì•„ë˜ìª½ ê°„ê²© */
        image-rendering: pixelated; /* í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼ ìœ ì§€ */
      }

      /* ì²´í¬ë°•ìŠ¤ ë¹„í™œì„±í™” ì‹œ ìƒ‰ìƒ ìœ ì§€ */
      input[type="checkbox"]:disabled {
        opacity: 1 !important;
        filter: none !important;
        -webkit-filter: none !important;

        /* --- ì¶”ê°€ëœ ë¶€ë¶„ --- */
        /* ë°°ê²½ìƒ‰ì„ ê°•ì œë¡œ ë°ì€ ìƒ‰ìœ¼ë¡œ ì§€ì • */
        background-color: #f0f0f0 !important;
        /* í…Œë‘ë¦¬ ìƒ‰ì„ ì—°í•œ íšŒìƒ‰ìœ¼ë¡œ ì§€ì • */
        border-color: #cccccc !important;
      }
    </style>
  </head>
  <body>
    <button id="emergency-exit-tutorial-btn" class="hidden"></button>
    <audio id="main-menu-music" src="assets/sounds/main_theme.flac"></audio>
    <audio
      id="character-select-music"
      src="assets/sounds/char_select_theme.flac"
    ></audio>
    <audio id="game-play-music" src="assets/sounds/game_music.wav"></audio>
    <audio
      id="thinking-time-music"
      src="assets/sounds/thinking_music.wav"
    ></audio>
    <!-- Language Selection Modal -->
    <div id="background-box"></div>
    <div id="background-box_1"></div>
    <div id="bottom-overlay-box"></div>
    <div id="character-select-indicator" class="turn-indicator hidden"></div>
    <div id="language-modal" class="modal visible">
      <div class="modal-content-small">
        <h2>Choose Language / ì–¸ì–´ ì„ íƒ</h2>
        <div id="language-buttons" class="selection-buttons">
          <button id="lang-en">English</button>
          <button id="lang-ko">í•œêµ­ì–´</button>
        </div>
      </div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <button
        id="back-to-main-from-char-select-btn"
        class="close-button"
      ></button>
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="philosopher-name" id="p1-philosopher-name"></div>
        <div class="skill-area" id="p1-skill">
          <h3 class="skill-title" id="p1-skill-title"></h3>
          <p id="p1-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p1-ready-overlay">READY</div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>í™• ì¸</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="philosopher-name" id="p2-philosopher-name"></div>
        <div class="skill-area" id="p2-skill">
          <h3 class="skill-title" id="p2-skill-title"></h3>
          <p id="p2-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p2-ready-overlay">READY</div>
      </div>
    </div>

    <div id="turn-order-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="turn-order-title"></h2>
        <div id="turn-order-buttons" class="selection-buttons">
          <button id="select-first-player"></button>
          <button id="select-second-player"></button>
        </div>
      </div>
    </div>

    <div class="container" id="container">
      <header>
        <h1 id="main-title">LOGOS ORGANON</h1>
      </header>

      <div id="info-box">
        <div class="header-buttons-left">
          <button id="new-game-btn"></button>
          <button id="credits-btn" class="hidden"></button>
        </div>
        <div class="round-display" id="round-display"></div>
        <div class="header-buttons-right">
          <button id="main-menu-btn"></button>
          <button id="fullscreen-btn"></button>
          <button id="settings-btn"></button>
        </div>
      </div>

      <div class="player-area" id="player-a-area">
        <div class="player-title-box">
          <h3 id="player-a-title"></h3>
        </div>

        <div id="player-a-portrait" class="philosopher-portrait"></div>
        <div class="hand" id="player-a-hand"></div>
        <div class="button-wrapper">
          <button class="ability-btn" id="ability-a"></button>
          <button class="eureka-btn" id="eureka-a"></button>
        </div>
      </div>

      <div class="game-board">
        <div class="main-center-bg">
          <img
            id="main-menu-title-img"
            src="assets/images/title.png"
            alt="Logos Title"
          />
          <div class="main-center-buttons">
            <div class="mode-selector">
              <button id="vs-player-btn"></button>
              <button id="vs-ai-btn"></button>
              <button id="vs-ai-test-btn">AI Test Mode</button>
              <button id="vs-ai-battle-btn"></button>
            </div>

            <button id="puzzle-mode-btn"></button>
            <button id="tutorial-btn"></button>
            <button id="tutorial-puzzle-btn"></button>
            <button id="exit-game-btn"></button>
            <div id="mode-description"></div>
          </div>
        </div>

        <div id="current-proposition">
          <h3 id="current-proposition-title"></h3>
          <div id="proposition-display"></div>
          <div id="proposition-controls">
            <button id="complete-btn"></button>
            <button id="undo-btn"></button>
            <button id="end-turn-btn"></button>
          </div>
        </div>
        <div class="true-propositions-wrapper">
          <div id="true-propositions">
            <h3 id="true-propositions-title"></h3>
            <ul id="true-list"></ul>
          </div>

          <div id="thinking-time-controls" class="hidden">
            <h2 id="thinking-time-title"></h2>
            <p id="thinking-time-desc"></p>
          </div>
        </div>
      </div>

      <div class="player-area" id="player-b-area">
        <div class="player-title-box">
          <h3 id="player-b-title"></h3>
        </div>

        <div id="player-b-portrait" class="philosopher-portrait"></div>
        <div class="hand" id="player-b-hand"></div>
        <div class="button-wrapper">
          <button class="ability-btn" id="ability-b"></button
          ><button class="eureka-btn" id="eureka-b"></button>
        </div>
      </div>

      <div class="status-bar" id="status"></div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="skill-area" id="p1-skill">
          <h3>ìŠ¤í‚¬ ì„¤ëª…</h3>
          <p id="p1-skill-desc"></p>
        </div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>í™•ì¸</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="skill-area" id="p2-skill">
          <h3>ìŠ¤í‚¬ ì„¤ëª…</h3>
          <p id="p2-skill-desc"></p>
        </div>
      </div>
    </div>

    <!-- Main Eureka Modal -->
    <div id="eureka-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-eureka-modal-btn"></button>
        <h2 id="eureka-title"></h2>

        <div id="workbench-controls">
          <select id="inference-rule-select"></select>
          <button id="apply-rule-btn"></button>
          <button id="add-assumption-btn"></button>
          <button id="cancel-assumption-btn"></button>
        </div>

        <div id="conclusion-preview">
          <h3 id="conclusion-preview-title"></h3>
          <div id="conclusion-preview-text"></div>
        </div>

        <div class="proof-container">
          <div class="premise-selection">
            <h3 id="premise-selection-title"></h3>
            <ul id="premise-list"></ul>
          </div>
        </div>
        <button id="modal-confirm-btn"></button>
      </div>
    </div>

    <div id="ability-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-ability-modal-btn"></button>
        <h2 id="ability-title"></h2>
        <div class="premise-selection" id="ability-premise-selection">
          <ul id="ability-list"></ul>
        </div>
        <div class="modal-buttons">
          <button id="ability-confirm-btn"></button>
        </div>
      </div>
    </div>

    <div id="kant-ability-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-kant-modal-btn"></button>
        <h2 id="kant-ability-title"></h2>

        <div id="kant-proposition-area">
          <h3 id="kant-current-proposition-title">êµ¬ì„±ì¤‘ì¸ ëª…ì œ</h3>
          <div id="kant-proposition-display"></div>
        </div>

        <div id="kant-controls">
          <button id="kant-undo-btn"></button>
          <button id="kant-confirm-btn"></button>
        </div>

        <div id="kant-hand-area">
          <h3 id="kant-hand-title">ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë“œ</h3>
          <div id="kant-hand-display"></div>
        </div>
      </div>
    </div>

    <!-- Tutorial Modal (previously Rules Modal) -->
    <div id="tutorial-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-tutorial-modal-btn"></button>
        <h2 id="tutorial-modal-title"></h2>
        <div id="tutorial-content">
          <!-- Tutorial content will be generated here by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="modal">
      <div class="modal-content-small">
        <p id="alert-message"></p>
        <div class="modal-buttons">
          <button id="alert-ok-btn"></button>
        </div>
      </div>
    </div>

    <!-- Custom Prompt Modal -->
    <div id="prompt-modal" class="modal">
      <div class="modal-content-small">
        <p id="prompt-message"></p>
        <input type="text" id="prompt-input" />
        <div class="modal-buttons">
          <button id="prompt-confirm-btn"></button>
          <button id="prompt-cancel-btn"></button>
        </div>
      </div>
    </div>

    <!-- Tutorial Guide UI -->
    <div id="tutorial-guide" class="hidden">
      <p id="tutorial-text"></p>
      <button id="tutorial-next-btn"></button>
    </div>

    <div id="puzzle-goal-box" class="hidden">
      <p id="puzzle-goal-text"></p>
    </div>

    <div id="ai-turn-summary-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="ai-summary-title"></h2>
        <div id="ai-summary-content"></div>
        <div class="modal-buttons">
          <button id="ai-summary-ok-btn"></button>
        </div>
      </div>
    </div>

    <div id="settings-modal" class="modal">
      <div class="modal-content-small">
        <button class="close-button" id="close-settings-modal-btn"></button>
        <h2 id="settings-title"></h2>
        <div class="settings-group">
          <label for="bgm-volume-slider" id="bgm-label"></label>
          <input
            type="range"
            id="bgm-volume-slider"
            min="0"
            max="1"
            step="0.05"
          />
          <span id="bgm-volume-value">50%</span>
        </div>
        <div class="settings-group">
          <label for="sfx-volume-slider" id="sfx-label"></label>
          <input
            type="range"
            id="sfx-volume-slider"
            min="0"
            max="1"
            step="0.05"
          />
          <span id="sfx-volume-value">100%</span>
        </div>
      </div>
    </div>

    <div id="credits-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-credits-modal-btn"></button>
        <h2 id="credits-title"></h2>
        <div
          id="credits-content"
          style="
            text-align: left;
            margin-top: 15px;
            line-height: 1.7;
            font-size: 14px;
            max-height: 50vh;
            overflow-y: auto;
            padding-right: 15px;
          "
        >
          <p><strong>Game Design & Development</strong><br />Shin Jeonghyeon</p>

          <p><strong>Graphics</strong><br />Shin Jeonghyeon, Lee Joeun</p>

          <hr
            style="border: 0; border-top: 1px solid #d3b88b; margin: 15px 0"
          />

          <p><strong>SFX</strong></p>
          <p>
            <i>"Menu Selection Click"</i><br />
            Sound by NenadSimic<br />
            Licensed under CC BY 3.0<br />
            <a
              href="https://opengameart.org/content/menu-selection-click"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p><strong>Music</strong></p>
          <p>
            <i>"Contemplation" & "Contemplation 2 (Variation) & Another Me"</i
            ><br />
            Music by EstÃºdio Cafofo<br />
            Licensed under CC BY 3.0<br />
            <a
              href="http://estudiocafofo.com"
              target="_blank"
              rel="noopener noreferrer"
              >estudiocafofo.com</a
            ><br />
            <a
              href="https://opengameart.org/content/unreleased-game-music-pack"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p>
            <i>"Briefing Theme"</i><br />
            Music by Alexandr Zhelanov<br />
            Licensed under CC BY 3.0<br />
            <a
              href="https://soundcloud.com/alexandr-zhelanov"
              target="_blank"
              rel="noopener noreferrer"
              >soundcloud.com</a
            ><br />
            <a
              href="https://opengameart.org/content/unused-music"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p>
            <i>"Fanfare"</i><br />
            Music by Ted Kerr (2015)<br />
            Licensed under CC BY 3.0<br />
            <a
              href="https://opengameart.org/content/fanfare-0"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p><strong>Font</strong></p>
          <p>
            Pretendard Â© 2021 Kil Hyung-jin<br />
            Licensed under SIL Open Font License 1.1<br />
            <a
              href="https://github.com/orioncactus/pretendard"
              target="_blank"
              rel="noopener noreferrer"
              >github.com/orioncactus/pretendard</a
            >
          </p>

          <hr
            style="border: 0; border-top: 1px solid #d3b88b; margin: 15px 0"
          />

          <p>Developed by maemgames, 2025</p>
        </div>
      </div>
    </div>

    <div id="puzzle-level-select-modal" class="modal">
      <div class="shared-selection-area">
        <button class="close-button" id="close-puzzle-modal-btn"></button>
        <h2 id="puzzle-modal-title"></h2>
        <div id="puzzle-level-grid"></div>
      </div>
    </div>

    <script>
      // --- MULTILINGUAL TEXT DATA ---
      const TEXTS = {
        ko: {
          langCode: "ko",
          ui: {
            title: "LOGOS ORGANON",
            tutorialButton: "íŠœí† ë¦¬ì–¼",
            tutorialPuzzleButton: "íŠœí† ë¦¬ì–¼ í¼ì¦",
            exitGameButton: "ê²Œì„ ì¢…ë£Œ",
            creditsButton: "í¬ë ˆë”§",
            endTutorialButton: "íŠœí† ë¦¬ì–¼ ì¢…ë£Œ",
            newGameButton: "ìƒˆ ê²Œì„",
            vsAIButton: "1ì¸ ëŒ€ì „",
            vsPlayerButton: "2ì¸ ëŒ€ì „",
            puzzleButton: "í¼ì¦",
            fullscreenButton: "ì „ì²´í™”ë©´",
            settingsButton: "í™˜ê²½ì„¤ì •",
            settingsTitle: "í™˜ê²½ì„¤ì •",
            bgmLabel: "ë°°ê²½ìŒì•…",
            sfxLabel: "íš¨ê³¼ìŒ",
            playerAName: "ì†Œí¬ë¼í…ŒìŠ¤",
            playerAColor: "âšªï¸ ë°±",
            playerBName: "í”Œë¼í†¤",
            playerBColor: "âš«ï¸ í‘",
            currentPropositionTitle: "í˜„ì¬ ëª…ì œ",
            completeButton: "ëª…ì œ ì™„ì„±",
            undoButton: "ë˜ëŒë¦¬ê¸°",
            endTurnButton: "í„´ ì¢…ë£Œ",
            truePropositionsTitle: "ì°¸ ëª…ì œ ëª©ë¡",
            eurekaButton: "ìœ ë ˆì¹´!",
            addTheoremButton: "ì •ë¦¬ ì¶”ê°€ â•",
            roundDisplay: "ì œ {round} ë¼ìš´ë“œ",
            axiomTitle: "ê¸°ë³¸ ê³µë¦¬ (í¼ì³ë³´ê¸°)",
            statusTurn: "ì˜ í„´ì…ë‹ˆë‹¤.",
            statusAITurn: "AIê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤...",
            thinkingTimeStatus: "ì‚¬ìœ  ì‹œê°„ì…ë‹ˆë‹¤. ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë„ì¶œí•˜ì„¸ìš”.",
            thinkingTimeTitle: "ì‚¬ìœ (æ€æƒŸ) ì‹œê°„",
            thinkingTimeDesc:
              "ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë„ì¶œí•˜ê³  'ì •ë¦¬ ì¶”ê°€' ë²„íŠ¼ìœ¼ë¡œ ëª©ë¡ì— ë°˜ì˜í•˜ì„¸ìš”.",
            endThinkingTimeButton: "ì‚¬ìœ  ì‹œê°„ ì¢…ë£Œ & ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘",
            victoryMessage: "í”Œë ˆì´ì–´ì˜ ìŠ¹ë¦¬!",
            victorySubMessage: "ë…¼ë¦¬ì ì¸ ì¦ëª…ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤!",
            okButton: "í™•ì¸",
            cancelButton: "ì·¨ì†Œ",
            nextButton: "ë‹¤ìŒ",
            yesButton: "ì˜ˆ",
            noButton: "ì•„ë‹ˆì˜¤",
            cancelAssumptionButton: "ê°€ì • ì·¨ì†Œ",
            selectP1Philosopher: "1P, ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”",
            selectP2Philosopher: "2P, ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”",
            selectYourPhilosopher: "ë‹¹ì‹ ì˜ ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”",
            selectAIPhilosopher: "AIì˜ ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”",
            gameStartingSoon: "ê³§ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤...",
            turnOrderTitle: "ëŒ€ì „ ìˆœì„œë¥¼ ì„ íƒí•˜ì„¸ìš”",
            selectFirstPlayer: "ì„ ê³µ",
            selectSecondPlayer: "í›„ê³µ",
            skillTitle: "ê³ ìœ  ëŠ¥ë ¥",
            thinkingTimeTurnMessage: "ì˜ ì‚¬ìœ  ì‹œê°„ì…ë‹ˆë‹¤.",
            useAbilityButton: "ëŠ¥ë ¥ ì‚¬ìš©",
            platoAbilityTitle: "ì´ë°ì•„ íšŒìƒ",
            platoConfirmButton: "ì´ ëª…ì œë¥¼ ë³´í¸í™”í•˜ê¸°",
            socratesAbilityTitle: "ë¬´ì§€ì˜ ìê°",
            socratesConfirmButton: "ì´ ëª…ì œë¥¼ ë‹¤ìŒ ë¼ìš´ë“œê¹Œì§€ ì œì™¸",
            wittgensteinAbilityTitle: "ì‚¬ë‹¤ë¦¬ ê±·ì–´ì°¨ê¸°",
            wittgensteinConfirmButton: "ì •ë¦¬ ë„ì¶œ ë° ì „ì œ ì‚­ì œ",
            vsAIBattleButton: "AI ëŒ€ì „", // AI ëŒ€ì „ ë²„íŠ¼
            selectAIP1Philosopher: "AI 1P, ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”", // AI 1P ì„ íƒ ì•ˆë‚´
            selectAIP2Philosopher: "AI 2P, ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”", // AI 2P ì„ íƒ ì•ˆë‚´
            aiSummaryTitleDefault: "AIì˜ í„´ ê²°ê³¼",
            aiSummaryTitleTheorem: "AIê°€ ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë„ì¶œí–ˆìŠµë‹ˆë‹¤.",
            aiSummaryTitleAbility: "AIê°€ ëŠ¥ë ¥ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.",
            abilityLabel: "[ëŠ¥ë ¥]",
            theoremLabel: "[ì •ë¦¬]",
            platoAbilityDescription:
              "[ì´ë°ì•„ íšŒìƒ] ëŠ¥ë ¥ìœ¼ë¡œ '{proposition}' ëª…ì œë¥¼ ë„ì¶œí–ˆìŠµë‹ˆë‹¤.",
            socratesAbilityDescription:
              "[ë¬´ì§€ì˜ ìê°] ëŠ¥ë ¥ìœ¼ë¡œ '{proposition}' ëª…ì œë¥¼ ë‹¤ìŒ ë¼ìš´ë“œê¹Œì§€ ë…¼ì¦ì—ì„œ ì œì™¸í•©ë‹ˆë‹¤.",
            descartesAbilityDescription:
              "[ë°©ë²•ì  íšŒì˜] ëŠ¥ë ¥ìœ¼ë¡œ '{proposition}' ëª…ì œë¥¼ ì°¸ ëª©ë¡ì—ì„œ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.",
            humeAbilityDescription:
              "[ê·€ë‚©ì˜ ë¬¸ì œ] ëŠ¥ë ¥ìœ¼ë¡œ '{proposition}' ëª…ì œë¥¼ ì•½í™”ì‹œì¼°ìŠµë‹ˆë‹¤.",
            wittgensteinAbilityDescription:
              "[ì‚¬ë‹¤ë¦¬ ê±·ì–´ì°¨ê¸°] ëŠ¥ë ¥ìœ¼ë¡œ '{newTheorem}' ì •ë¦¬ë¥¼ ë„ì¶œí•˜ê³ , ì‚¬ìš©ëœ ì „ì œë“¤ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.",
            kuhnAbilityDescription:
              "[íŒ¨ëŸ¬ë‹¤ì„ ì „í™˜] ëŠ¥ë ¥ìœ¼ë¡œ ìƒˆë¡œìš´ íŒ¨ëŸ¬ë‹¤ì„ì¸ '{newParadigm}'ë¥¼ ìˆ˜ë¦½í–ˆìŠµë‹ˆë‹¤.",
            derridaAbilityDescription:
              "[í•´ì²´] ëŠ¥ë ¥ìœ¼ë¡œ '{proposition}' ëª…ì œë¥¼ í•´ì²´í–ˆìŠµë‹ˆë‹¤.",
            kantAbilityDescription:
              "[ì„ í—˜ì  ì¢…í•©íŒë‹¨] ëŠ¥ë ¥ìœ¼ë¡œ '{proposition}' ëª…ì œë¥¼ ë„ì¶œí–ˆìŠµë‹ˆë‹¤.",
            vsPlayerDesc: "ë‘ í”Œë ˆì´ì–´ê°€ í•œ ì»´í“¨í„° ì•ì— ì•‰ì•„<br>ëŒ€ê²°í•©ë‹ˆë‹¤.",
            vsAIDesc: "AIë¥¼ ìƒëŒ€í•˜ë©° ê²Œì„ì„ ì—°ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            tutorialDesc:
              "ê²Œì„ì˜ ê¸°ë³¸ ê·œì¹™ê³¼ ë…¼ë¦¬ì  ì¶”ë¡  ê·œì¹™ì„<br>ë°°ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            puzzleDesc:
              "ê²½ìŸ ì—†ì´, ë¯¸ë¦¬ ì¤€ë¹„ëœ ë…¼ë¦¬ ì¶”ë¡  í¼ì¦ì„<br>í’€ì–´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
          },
          modals: {
            characterSelectTitle: "ì² í•™ì ì„ íƒ",
            selectSocrates: "ì†Œí¬ë¼í…ŒìŠ¤ (ë°±) âšªï¸",
            selectPlato: "í”Œë¼í†¤ (í‘) âš«ï¸",
            eurekaTitleVictory: "ìœ ë ˆì¹´! ë…¼ì¦ êµ¬ì„±",
            eurekaTitleTheorem: "ì‚¬ìœ  ì‹œê°„: ì •ë¦¬ êµ¬ì„±",
            premiseSelectionTitle: "ì‚¬ìš© ê°€ëŠ¥í•œ ì „ì œ ëª©ë¡",
            applyRuleButton: "ê·œì¹™ ì ìš©",
            addAssumptionButton: "ê°€ì •í•˜ê¸°",
            confirmVictoryButton: "ì´ ë…¼ì¦ìœ¼ë¡œ ìŠ¹ë¦¬ ì¦ëª…!",
            confirmTheoremButton: "ì„ íƒí•œ ì •ë¦¬ë“¤ì„ ì°¸ ëª©ë¡ì— ì¶”ê°€ â•",
            tutorialTitle: "LOGOS ORGANON íŠœí† ë¦¬ì–¼",
            promptInputPlaceholder: "ëª…ì œë¥¼ ì…ë ¥í•˜ì„¸ìš”...",
            puzzleTitle: "ë ˆë²¨ ì„ íƒ",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "LOGOS ORGANONì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!",
              "ì‹œì‘í•˜ê¸° ì „ì—, ëª‡ ê°€ì§€ í•µì‹¬ ê·œì¹™ì„ ì•Œë ¤ë“œë¦´ê²Œìš”.",
              "<strong>ìŠ¹ë¦¬ ì¡°ê±´:</strong> ë§¤ ê²Œì„ ì‹œì‘ ì‹œ, ê°ì ë¬´ì‘ìœ„ë¡œ ì •í•´ì§„ <strong>ìŠ¹ë¦¬ ì¡°ê±´</strong>ì„ ë°›ìŠµë‹ˆë‹¤.</br><br>í•œ ë¼ìš´ë“œì— í•œ ë²ˆ ê°€ëŠ¥í•œ <strong>ìœ ë ˆì¹´!</strong>ì„ ì–¸ìœ¼ë¡œ <strong>ìì‹ ì˜ ìŠ¹ë¦¬</strong>ë¥¼ ì¦ëª…í•˜ê±°ë‚˜ <strong>ìƒëŒ€ì˜ íŒ¨ë°°</strong>ë¥¼ ì¦ëª…í•˜ë©´ ì´ê¹ë‹ˆë‹¤.<br><br>ì˜ˆë¥¼ ë“¤ì–´, ë‹¹ì‹ ì˜ ì² í•™ìê°€ ì†Œí¬ë¼í…ŒìŠ¤, ìƒëŒ€ì˜ ì² í•™ìê°€ í”Œë¼í†¤ì´ë¼ë©´<br><strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤</strong>ë‚˜ <strong>í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ì¦ëª…í•˜ë©´ ë©ë‹ˆë‹¤.",
              "<strong>ì²« í„´:</strong> ì²« ë¼ìš´ë“œëŠ” ì–¸ì œë‚˜ ë°± í”Œë ˆì´ì–´ê°€ ë¨¼ì € ì‹œì‘í•©ë‹ˆë‹¤.<br><br><strong>ì„ ê³µ êµëŒ€:</strong> ë¼ìš´ë“œê°€ ë°”ë€” ë•Œë§ˆë‹¤ ì„ ê³µí•˜ëŠ” í”Œë ˆì´ì–´ê°€ êµëŒ€ë©ë‹ˆë‹¤.",
              "ê·¸ëŸ¼, ê°€ì¥ ê¸°ë³¸ì¸ <strong>ëª…ì œ</strong>ë¥¼ ë§Œë“œëŠ” ë²•ë¶€í„° ë°°ì›Œë´…ì‹œë‹¤.",
              "ì´ê³³ì´ ë‹¹ì‹ ì˜ <strong>íŒ¨</strong>ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ë‹¨ì–´ ì¹´ë“œê°€ ìˆì£ .",
              "ì¹´ë“œë¥¼ ì´ê³³ìœ¼ë¡œ ì˜®ê²¨ <strong>ëª…ì œ</strong>ë¥¼ ë§Œë“¤ê²Œ ë©ë‹ˆë‹¤.",
              "ì¹´ë“œë¥¼ í´ë¦­í•´ì„œ <strong>í˜„ì¬ ëª…ì œ</strong> ì˜ì—­ìœ¼ë¡œ ì˜®ê²¨ë³´ì„¸ìš”.",
              "ì•„ì£¼ ì¢‹ìŠµë‹ˆë‹¤! <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ”</strong> ê°™ì€ <strong>ê³ ìœ  ëª…ì‚¬</strong>ëŠ” ë°”ë¡œ ëª…ì œë¥¼ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "í•˜ì§€ë§Œ <strong>ê°œëŠ”</strong>, <strong>ìƒˆëŠ”</strong>, <strong>ë¬¼ê³ ê¸°ëŠ”</strong> ê°™ì€ <strong>ê°œì²´</strong> ì¹´ë“œëŠ” 'ëª¨ë“  ìƒˆëŠ”', 'ì–´ë–¤ ìƒˆëŠ”'ê³¼ ê°™ì´ <strong>ëª¨ë“ </strong>ì´ë‚˜ <strong>ì–´ë–¤</strong>ê³¼ ê°™ì€ <strong>ì–‘í™”ì‚¬</strong> ì¹´ë“œ ë’¤ì—ë§Œ ë†“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br>ë˜í•œ, ê³ ìœ ëª…ì‚¬ ì¹´ë“œëŠ” ì–‘í™”ì‚¬ ë’¤ì— ë†“ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>'ëª¨ë“  ì†Œí¬ë¼í…ŒìŠ¤'ë‚˜ 'ì–´ë–¤ ì†Œí¬ë¼í…ŒìŠ¤'ë¼ëŠ” ë§ì€ ì§ê´€ì ìœ¼ë¡œë„, ê·œì¹™ ìƒìœ¼ë¡œë„ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.<br><br>ì´ ì ì„ ê¼­ ê¸°ì–µí•´ì£¼ì„¸ìš”!",
              "ê° í”Œë ˆì´ì–´ëŠ” í•œ í„´ì— ë°˜ë“œì‹œ í•œ ì¥ì˜ ì¹´ë“œë¥¼ ë‚´ì•¼ í•˜ë©°, ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œê°€ ìˆë‹¤ë©´ ë°˜ë“œì‹œ ë‚´ì•¼ í•©ë‹ˆë‹¤.<br><br>ì¹´ë“œë¥¼ ëƒˆìœ¼ë‹ˆ ì´ì œ í„´ì„ ë§ˆì³ë³¼ê¹Œìš”?.",
              "<strong>í„´ ì¢…ë£Œ</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ìƒëŒ€ì—ê²Œ í„´ì„ ë„˜ê²¨ì£¼ì„¸ìš”.",
              "ë‹¤ìŒìœ¼ë¡œ, ìƒëŒ€ë°©ì´ ë„˜ê²¨ì¤€ ëª…ì œì— ì–´ë–»ê²Œ ëŒ€ì‘í•˜ëŠ”ì§€ ë°°ì›Œë³´ê² ìŠµë‹ˆë‹¤.",
            ],
            // Stage 2 (Index 1)
            [
              "ìƒëŒ€ë°©ì˜ í„´ì´ ëë‚¬ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤.",
              "ìƒëŒ€ë°©ì´ ë§Œë“  ëª…ì œê°€ ë¬¸ë²•ì ìœ¼ë¡œ ì™„ê²°ë˜ì—ˆë„¤ìš”. ì´ë•Œ ì—¬ëŸ¬ í–‰ë™ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "<strong>ì²« ë²ˆì§¸ ì„ íƒ: ëª…ì œ ì™„ì„±.</strong> í˜„ì¬ ëª…ì œë¥¼ <strong>ì°¸</strong>ìœ¼ë¡œ ì¸ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì§€ê¸ˆì€ ì•„ë¬´ëŸ° ëª¨ìˆœì´ ì—†ìœ¼ë‹ˆ, <strong>ëª…ì œ ì™„ì„±</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ <strong>ì°¸ ëª…ì œ ëª©ë¡</strong>ì— ì¶”ê°€í•´ ë´…ì‹œë‹¤.",
              "ì°¸ ëª…ì œ ëª©ë¡ì— ëª…ì œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ëª…ì œê°€ ì¶”ê°€ë˜ë ¤ë©´ ë‘ ê°€ì§€ ì¤‘ìš”í•œ ì¡°ê±´ì´ ìˆìŠµë‹ˆë‹¤.",
              "ì²«ì§¸, ì™„ì „íˆ ê°™ì€ ëª…ì œê°€ ì´ë¯¸ ì¡´ì¬í•œë‹¤ë©´ ë‹¤ì‹œ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
              "ë‘˜ì§¸, ê¸°ì¡´ ì°¸ ëª©ë¡ì˜ ëª…ì œë“¤ê³¼ ëª¨ìˆœë˜ëŠ” ëª…ì œëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
              "ìƒëŒ€ë°©ì´ ë„˜ê²¨ì¤€ ëª…ì œë¥¼ ì™„ì„±í•˜ëŠ” ëŒ€ì‹ , ë‹¤ë¥¸ ì„ íƒë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
              "<strong>ë‘ ë²ˆì§¸ ì„ íƒ: í™•ì¥í•˜ê¸°.</strong> <strong>ê·¸ë¦¬ê³ </strong>, <strong>ë˜ëŠ”</strong>, <strong>ë¼ë©´</strong> ê°™ì€ <strong>ì—°ê²°ì‚¬</strong> ì¹´ë“œë¥¼ ì¶”ê°€í•˜ì—¬ ëª…ì œë¥¼ ë” ë³µì¡í•˜ê²Œ ë§Œë“¤ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.<br><br>ë‹¨, ì—°ê²°ì‚¬ëŠ” í•˜ë‚˜ì˜ ëª…ì œì— í•œ ë²ˆë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì„¸ìš”.",
              "<strong>ì„¸ ë²ˆì§¸ ì„ íƒ: ë¶€ì •í•˜ê¸°.</strong> ìì‹ ì—ê²Œ ë¶ˆë¦¬í•œ ëª…ì œë¼ë©´, ì†íŒ¨ì˜ <strong>ëŠ” ê±°ì§“ì´ë‹¤</strong> ì¹´ë“œë¥¼ ì¶”ê°€í•˜ì—¬ ëª…ì œë¥¼ ë¶€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>í•˜ì§€ë§Œ ì¡°ì‹¬í•˜ì„¸ìš”! ë§Œì•½ ìƒëŒ€ë°©ë„ ë¶€ì • ì¹´ë“œë¥¼ ë‚¸ë‹¤ë©´, <strong>ì´ì¤‘ ë¶€ì •</strong> ê·œì¹™ì— ë”°ë¼ ë‹¹ì‹ ì˜ ë¶€ì •ì´ ë°”ë¡œ ë¬´íš¨í™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><br>ë˜í•œ, ì—°ê²°ì‚¬ë¡œ ì—°ê²°ëœ ë¬¸ì¥ì— <strong>ëŠ” ê±°ì§“ì´ë‹¤</strong>ê°€ ë¶™ìœ¼ë©´, ë¬¸ì¥ ì „ì²´ê°€ ì•„ë‹Œ ì—°ê²°ì‚¬ê°€ ê²°í•©ëœ ìµœì†Œ ë‹¨ìœ„ ëª…ì œë§Œ ë¶€ì •ë©ë‹ˆë‹¤.<br><br>ì˜ˆë¥¼ ë“¤ì–´, <strong>ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤ ê·¸ë¦¬ê³  ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ì—ì„œ ë¶€ì •ë˜ëŠ” ë¶€ë¶„ì€ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤</strong> ë¿ì…ë‹ˆë‹¤.",
              "ì´ì œ ìƒëŒ€ì˜ ëª…ì œì— ëŒ€ì‘í•˜ëŠ” ì—¬ëŸ¬ ë°©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ, ë…¼ì¦ì˜ ê¸°ë°˜ìœ¼ë¡œ ì‚¼ì„ ìˆ˜ ìˆëŠ” <strong>ê¸°ë³¸ ê³µë¦¬</strong>ì— ëŒ€í•´ ì•Œì•„ë´…ì‹œë‹¤.",
            ],
            // Stage 3 (Index 2)
            [
              "ì°¸ ëª…ì œ ëª©ë¡ì—ëŠ” ìš°ë¦¬ê°€ ë§Œë“  ëª…ì œë¿ë§Œ ì•„ë‹ˆë¼, ëª¨ë“  ë…¼ì¦ì˜ ê¸°ë°˜ì´ ë˜ëŠ” <strong>ê¸°ë³¸ ê³µë¦¬</strong>ê°€ ë“¤ì–´ìˆìŠµë‹ˆë‹¤.",
              "ì´ í•­ëª©ì„ í´ë¦­í•´ì„œ ì–´ë–¤ ê³µë¦¬ë“¤ì´ ìˆëŠ”ì§€ í™•ì¸í•´ ë³´ì„¸ìš”.",
              "ê³µë¦¬ëŠ” ì¦ëª…í•  í•„ìš” ì—†ì´ ì°¸ìœ¼ë¡œ ë°›ì•„ë“¤ì—¬ì§€ëŠ” ëª…ì œë“¤ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 'ëª¨ë“  ê°œëŠ” ê°œì´ë‹¤' ì™€ ê°™ì€ ê²ƒë“¤ì´ì£ .",
              "ê³µë¦¬ì— ë”°ë¼, ë™ì¼í•œ ê°œì²´ê°€ 'ì„ í•˜ë‹¤'ì™€ 'ì•…í•˜ë‹¤'ì²˜ëŸ¼ <strong>ë‘ ê°€ì§€ ìƒë°˜ëœ ì†ì„±ì„ ë™ì‹œì— ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</strong>.<br><br>ë˜í•œ, <strong>ëª¨ë“  ê°œ</strong>ì™€ ê°™ì€ ì§‘ë‹¨ì€ <strong>ì–´ë–¤ ê°œ</strong>ì™€ ê°™ì€ ì¼ë¶€ì™€ ìƒë°˜ëœ ì†ì„±ì„ ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br><br>ì˜ˆë¥¼ ë“¤ì–´, <strong>ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤</strong>ì™€ <strong>ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤</strong>ëŠ” ë™ì‹œì— ì°¸ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
              "ë…¼ì¦ì„ êµ¬ì„±í•  ë•Œ, ì´ ê³µë¦¬ë“¤ì„ ì¤‘ìš”í•œ ì „ì œë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "ì´ì œ ê¸°ë³¸ì ì¸ ê³µë¦¬ë“¤ì„ í™•ì¸í–ˆìœ¼ë‹ˆ, ì¹´ë“œë¥¼ ë‚¼ ìˆ˜ ì—†ì„ ë•Œ ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤.",
            ],
            // Stage 4 (Index 3)
            [
              "ê²Œì„ì´ ì§„í–‰ë˜ë©´, í„´ì´ ëŒì•„ì˜¨ í”Œë ˆì´ì–´ê°€ ì¹´ë“œ ë‚´ê¸°ì™€ ëª…ì œ ì™„ì„± ëª¨ë‘ ë¶ˆê°€ëŠ¥í•œ ìƒí™©ì´ ì˜¤ê²Œ ë©ë‹ˆë‹¤.",
              "ì´ë•Œ ë¼ìš´ë“œê°€ ì¢…ë£Œë˜ê³  <strong>ì‚¬ìœ  ì‹œê°„</strong>ì´ ì‹œì‘ë©ë‹ˆë‹¤.",
              "ì‚¬ìœ  ì‹œê°„ í„´ì€ í•´ë‹¹ ë¼ìš´ë“œì˜ í›„ê³µ í”Œë ˆì´ì–´ë¶€í„° ê°ê° í•œ í„´ì”© ì§„í–‰í•˜ë©°, ì´ë¯¸ ì°¸ì¸ ëª…ì œë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ìƒˆë¡œìš´ <strong>ì •ë¦¬</strong>ë¥¼ ë„ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "ìƒëŒ€ë°©ì´ í„´ì„ ë„˜ê¸°ëŠ” ì¤‘ì…ë‹ˆë‹¤.",
              "ì´ì œ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤. <strong>ì •ë¦¬ ì¶”ê°€</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ë´…ì‹œë‹¤.",
              "ë…¼ì¦ êµ¬ì„±ì°½ì´ ì—´ë ¸ìŠµë‹ˆë‹¤. <strong>ë³´í¸ ì ìš©</strong> ê·œì¹™ì„ ì‚¬ìš©í•´ ê°€ë³ê²Œ ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë§Œë“¤ì–´ ë´…ì‹œë‹¤.<br><br>ì¶”ë¡  ê·œì¹™ë“¤ì˜ êµ¬ì²´ì ì¸ ìš©ë²•ì€ ì´í›„ì— ë°°ìš¸ ê²ƒì…ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤</strong>ì™€ <strong>ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ì¶”ë¡  ê·œì¹™ì—ì„œ <strong>ë³´í¸ ì ìš©</strong>ì„ ì„ íƒí•˜ê³ , <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              "<strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤</strong>ë¼ëŠ” ì •ë¦¬ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ì´ì œ ì´ ì •ë¦¬ë¥¼ ì„ íƒí•˜ê³  <strong>ì„ íƒí•œ ì •ë¦¬ë“¤ì„ ì°¸ ëª©ë¡ì— ì¶”ê°€</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ì¦ëª…ì„ ë§ˆì¹©ì‹œë‹¤.",
              "ìƒˆë¡œìš´ ì •ë¦¬ê°€ <strong>ì°¸ ëª…ì œ ëª©ë¡</strong>ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.<br>ì‚¬ìœ  ì‹œê°„ì—ëŠ” ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ë§Œë“œëŠ” ê²ƒ ì™¸ì—, ì² í•™ìì˜ <strong>ê³ ìœ  ëŠ¥ë ¥</strong>ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ëŠ¥ë ¥ì€ ê²Œì„ë‹¹ ì‚¬ìš© íšŸìˆ˜ê°€ ì œí•œë˜ì–´ ìˆì§€ë§Œ, ë¶ˆë¦¬í•œ ìƒí™©ì„ ë’¤ì§‘ê±°ë‚˜ ìœ ë¦¬í•œ ìƒí™©ì„ êµ³í ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ë¬´ê¸°ì…ë‹ˆë‹¤.",
              "ì´ì œ <strong>í„´ ì¢…ë£Œ</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‚¬ìœ  ì‹œê°„ì„ ë§ˆì¹˜ê³  ë‹¤ìŒ ë¼ìš´ë“œë¥¼ ì‹œì‘í•˜ì„¸ìš”.<br>ë¼ìš´ë“œê°€ ìƒˆë¡œ ì‹œì‘ë˜ë©´ ëƒˆë˜ ëª¨ë“  ì¹´ë“œë¥¼ ëŒë ¤ë°›ìœ¼ë©°, ì°¸ ëª…ì œ ëª©ë¡ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.",
            ],
            // Stage 5 (Index 4) - UPDATED & EXPANDED
            [
              "ì§€ê¸ˆê¹Œì§€ ê²Œì„ì˜ íë¦„ì„ ë°°ì› ìŠµë‹ˆë‹¤. ì´ì œ ë…¼ì¦ì„ êµ¬ì„±í•˜ëŠ” ë° ì“°ì¼ <strong>ì¶”ë¡  ê·œì¹™</strong>ë“¤ì„ í•˜ë‚˜ì”© ìµí˜€ë´…ì‹œë‹¤. <strong>ìœ ë ˆì¹´!</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ë…¼ì¦ êµ¬ì„±ì°½ì„ ì—¬ì„¸ìš”.",
              // 1. Modus Ponens
              "ë¨¼ì € <strong>ì „ê±´ ê¸ì •</strong>ì…ë‹ˆë‹¤. 'ë¼ë©´'ìœ¼ë¡œ ì—°ê²°ëœ ëª…ì œì˜ ì•ìª½ì´ ì°¸ì´ë©´ ë’¤ìª½ë„ ì°¸ì´ë¼ëŠ” ê°€ì¥ ì§ê´€ì ì¸ ê·œì¹™ì´ì£ .",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤</strong>ì™€ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì „ê±´ ê¸ì •</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 2. Modus Tollens
              "ì¢‹ìŠµë‹ˆë‹¤. <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤</strong>ëŠ” ê²°ë¡ ì´ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ì´ë²ˆì—ëŠ” <strong>í›„ê±´ ë¶€ì •</strong>ì„ ì—°ìŠµí•´ ë´…ì‹œë‹¤. 'ë¼ë©´'ìœ¼ë¡œ ì—°ê²°ëœ ëª…ì œì˜ ë’¤ìª½ì´ ê±°ì§“ì´ë¼ë©´, ì•ìª½ë„ ë°˜ë“œì‹œ ê±°ì§“ì…ë‹ˆë‹¤.<br>ì˜ˆë¥¼ ë“¤ì–´, 'ë¹„ê°€ ì˜¨ë‹¤ë©´ ë•…ì´ ì –ëŠ”ë‹¤'ì—ì„œ, ë•…ì´ ì –ì§€ ì•Šì•˜ë‹¤ë©´ ë¹„ê°€ ì˜¤ì§€ ì•Šì•˜ë‹¤ëŠ” ê²ƒì„ ì§ê´€ì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ì™€ <strong>í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>í›„ê±´ ë¶€ì •</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 3. Disjunctive Syllogism
              "<strong>í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¼ëŠ” ê²°ë¡ ì´ ë‚˜ì™”êµ°ìš”.<br><br>ë‹¤ìŒì€ <strong>ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì…ë‹ˆë‹¤.<br><strong>ë˜ëŠ”</strong>ìœ¼ë¡œ ì—°ê²°ëœ ëª…ì œ ì¤‘ í•˜ë‚˜ê°€ ê±°ì§“ì´ë©´, ë‚˜ë¨¸ì§€ í•˜ë‚˜ëŠ” ë°˜ë“œì‹œ ì°¸ì…ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ë˜ëŠ” ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤</strong>ì™€ <strong>ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 4. Hypothetical Syllogism
              "<strong>ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤</strong>ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ì´ë²ˆì—” <strong>ê°€ì„¤ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì…ë‹ˆë‹¤. ê¼¬ë¦¬ë¬¼ê¸°ì²˜ëŸ¼ ì´ì–´ì§€ëŠ” ë‘ ëª…ì œë¥¼ í•˜ë‚˜ë¡œ í•©ì³ë´…ì‹œë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>í”Œë¼í†¤ì€ ê°œì´ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ì™€ <strong>í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ê°€ì„¤ì  ì‚¼ë‹¨ë…¼ë²•</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 5. Conjunction Elimination (Simplification)
              "<strong>í”Œë¼í†¤ì€ ê°œì´ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤</strong>ë¼ëŠ” ë” ê°„ê²°í•œ ëª…ì œê°€ ë§Œë“¤ì–´ì¡ŒìŠµë‹ˆë‹¤. ë‹¤ìŒì€ <strong>ë‹¨ìˆœí™”</strong> ê·œì¹™ì…ë‹ˆë‹¤.",
              "<strong>ê·¸ë¦¬ê³ </strong>ë¡œ ì—°ê²°ëœ ëª…ì œëŠ” ê°ê°ì´ ì°¸ì…ë‹ˆë‹¤. ì „ì œ ëª©ë¡ì—ì„œ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤ ê·¸ë¦¬ê³  í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ë‹¨ìˆœí™”</strong>ë¥¼ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”. ë‘ ê°œì˜ ëª…ì œê°€ í•œ ë²ˆì— ë„ì¶œë  ê²ë‹ˆë‹¤.",
              // 6. Double Negation Elimination
              "ë³´ì‹œë‹¤ì‹œí”¼ ë‘ ëª…ì œê°€ ê°ê° ë¶„ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ì´ì œ <strong>ì´ì¤‘ ë¶€ì • ì œê±°</strong> ê·œì¹™ì„ ë°°ì›Œë´…ì‹œë‹¤. ë¶€ì •ì„ ë‘ ë²ˆ í•˜ë©´ ê¸ì •ì´ ë©ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì´ì¤‘ ë¶€ì • ì œê±°</strong>ë¥¼ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 7. Universal Application
              "ì›ë˜ì˜ ê¸ì • ëª…ì œë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.<br><br>ë‹¤ìŒì€ <strong>ë³´í¸ ì ìš©</strong> ê·œì¹™ì…ë‹ˆë‹¤. ë³´í¸ì ì¸ ê·œì¹™ì€ ê°œë³„ ì‚¬ë¡€ì—ë„ ì ìš©ë©ë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤</strong>ì™€ <strong>í”Œë¼í†¤ì€ ìƒˆì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ë³´í¸ ì ìš©</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // 8. Existential Instantiation
              "<strong>í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ë‹¤ìŒì€ <strong>ì¡´ì¬í™”</strong> ê·œì¹™ì…ë‹ˆë‹¤. 'ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤', 'ì–´ë–¤ ê°œëŠ” ê°œì´ë‹¤', 'ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ë¬¼ê³ ê¸°ì´ë‹¤' ê³µë¦¬ì— ì˜í•´ ìƒˆ, ê°œ, ë¬¼ê³ ê¸°ê°€ ì¡´ì¬í•œë‹¤ëŠ” ê²ƒì´ ë³´ì¥ë˜ë¯€ë¡œ, <strong>ëª¨ë“ </strong>ìœ¼ë¡œ ì„œìˆ ëœ ì†ì„±ì„ ê°€ì§„ <strong>ì–´ë–¤</strong> ì¼ë¶€ê°€ ì¡´ì¬í•œë‹¤ëŠ” ì‚¬ì‹¤ì„ ë„ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
              "ì „ì œ ëª©ë¡ì—ì„œ <strong>ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ì¡´ì¬í™”</strong>ë¥¼ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.",
              // End of Stage 5
              "<strong>ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤</strong>ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ë‹¤ìŒìœ¼ë¡œ ì—¬ëŸ¬ ê°œì˜ ëª…ì œë¥¼ í•œë²ˆì— ì¡°í•©í•˜ëŠ” ê°•ë ¥í•œ ê·œì¹™ì„ ë°°ì›Œë´…ì‹œë‹¤.",
            ],
            // Stage 6 (Index 5)
            [
              "ì´ë²ˆì— ë°°ìš¸ <strong>ê²½ìš° ë…¼ì¦</strong>ì€ ì—¬ëŸ¬ ê°ˆë˜ì˜ ê¸¸ì„ í•˜ë‚˜ì˜ ê²°ë¡ ìœ¼ë¡œ ëª¨ìœ¼ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.",
              "<strong>í”Œë¼í†¤ì€ ì„ í•˜ê±°ë‚˜ ì•…í•˜ë‹¤</strong>ëŠ” ë‘ ê°€ì§€ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ°ë° ì–´ëŠ ê²½ìš°ë“  <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ëŠ” ê²°ë¡ ì— ë„ë‹¬í•˜ëŠ”êµ°ìš”. ë¨¼ì €, í•„ìš”í•œ ì „ì œ ì„¸ ê°€ì§€ë¥¼ ëª¨ë‘ ì„ íƒí•´ì£¼ì„¸ìš”.",
              "ì´ì œ ì¶”ë¡  ê·œì¹™ ëª©ë¡ì—ì„œ <strong>ê²½ìš° ë…¼ì¦</strong>ì„ ì„ íƒí•˜ê³  <strong>ê·œì¹™ ì ìš©</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²°ë¡ ì„ ë„ì¶œí•˜ì„¸ìš”.",
              "<strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ëŠ” ê²°ë¡ ì´ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤.<br><br>ë‹¤ìŒì€ ë…¼ë¦¬í•™ì˜ ê½ƒì´ë¼ ë¶ˆë¦¬ëŠ” <strong>ê°€ì •</strong>ì„ ì‚¬ìš©í•˜ëŠ” ê·œì¹™ì…ë‹ˆë‹¤.",
            ],
            // Stage 7 (Index 6) - â˜…â˜…â˜… MODIFIED SECTION â˜…â˜…â˜…
            [
              "ë•Œë¡œëŠ” ì¦ëª…ì„ ìœ„í•´ ë¬´ì–¸ê°€ë¥¼ <strong>ë§Œì•½ ~ë¼ë©´</strong> í•˜ê³  ê°€ì •í•´ì•¼ í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” ë‘ ê°œì˜ ì „ì œë¥¼ ë…¼ë¦¬ì ìœ¼ë¡œ ì—°ê²°í•´ ë´…ì‹œë‹¤.",
              "<strong>ê°€ì •í•˜ê¸°</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤</strong>ë¥¼ ì…ë ¥í•´ ê°€ì •í•´ ë³´ì„¸ìš”.",
              "ì¢‹ìŠµë‹ˆë‹¤. ì´ì œ ê°€ì •ê³¼ ì²« ë²ˆì§¸ ì „ì œì¸ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ê°œì´ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "<strong>ì „ê±´ ê¸ì •</strong> ê·œì¹™ì„ ì ìš©í•´ ì¤‘ê°„ ê²°ë¡ ì„ ë„ì¶œí•˜ì„¸ìš”.",
              "ì´ì œ ë°©ê¸ˆ ì–»ì€ ì¤‘ê°„ ê²°ë¡ ê³¼ ë‘ ë²ˆì§¸ ì „ì œì¸ <strong>í”Œë¼í†¤ì€ ê°œì´ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ë‹¤ì‹œ <strong>ì „ê±´ ê¸ì •</strong> ê·œì¹™ì„ ì ìš©í•´ ìµœì¢… ê²°ë¡ ì„ ì´ëŒì–´ë‚´ì„¸ìš”.",
              "ìµœì¢… ê²°ê³¼ë¬¼ì¸ <strong>í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ë¥¼ ì„ íƒí•˜ì„¸ìš”.",
              "ë§ˆì§€ë§‰ìœ¼ë¡œ, <strong>ì¡°ê±´ë¬¸ ë„ì…</strong> ê·œì¹™ì„ ì ìš©í•˜ì„¸ìš”. ê·¸ëŸ¬ë©´ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì„ í•˜ë‹¤</strong>ë¼ëŠ” ìƒˆë¡œìš´ ì •ë¦¬ê°€ ì™„ì„±ë©ë‹ˆë‹¤.",
              "ì´ì œ ê·€ë¥˜ë²•ì— ëŒ€í•´ ì•Œì•„ë´…ì‹œë‹¤.",
            ],
            // Stage 8 (Index 7) - NEWLY ADDED
            [
              "<strong>ê·€ë¥˜ë²•</strong>ì€ ì¦ëª…í•˜ê³  ì‹¶ì€ ê²ƒì˜ <strong>ë°˜ëŒ€</strong>ë¥¼ ê°€ì •í•˜ì—¬ ëª¨ìˆœì„ ì´ëŒì–´ë‚´ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.",
              "ìš°ë¦¬ì˜ ëª©í‘œëŠ” <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤</strong>ë¥¼ ì¦ëª…í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. <strong>ê°€ì •í•˜ê¸°</strong>ë¡œ ê·¸ ë°˜ëŒ€ì¸ <strong>ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ë¥¼ ê°€ì •í•˜ì„¸ìš”.",
              "ê°€ì •ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì´ ê°€ì •ì„ ì´ìš©í•´ ëª…ë°±í•œ ëª¨ìˆœ, ì¦‰ 'P'ì™€ 'P ëŠ” ê±°ì§“ì´ë‹¤' í˜•íƒœì˜ í•œ ìŒì„ ë§Œë“¤ì–´ ë´…ì‹œë‹¤. ë°©ê¸ˆ ë§Œë“  ê°€ì •ê³¼ ë‹¤ë¥¸ ì „ì œë¥¼ ì„ íƒí•˜ê³  <strong>ì „ê±´ ê¸ì •</strong> ê·œì¹™ì„ ì ìš©í•´ ë³´ì„¸ìš”.",
              "<strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤</strong>ê°€ ë„ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ë¯¸ ì°¸ì¸ ëª…ì œ ëª©ë¡ì— <strong>í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤</strong>ê°€ ì¡´ì¬í•©ë‹ˆë‹¤. ì´ê²ƒì´ ë°”ë¡œ ëª¨ìˆœì…ë‹ˆë‹¤.",
              "ì´ì œ ëª¨ìˆœë˜ëŠ” ë‘ ëª…ì œë¥¼ ëª¨ë‘ ì„ íƒí•˜ê³  <strong>ê·€ë¥˜ë²•</strong> ê·œì¹™ì„ ì ìš©í•˜ì„¸ìš”.",
              "ìµœì´ˆì˜ ê°€ì •ì´ í‹€ë ¸ë‹¤ëŠ” ê²ƒì´ ì¦ëª…ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ë§ˆì§€ë§‰ìœ¼ë¡œ <strong>ì´ì¤‘ ë¶€ì • ì œê±°</strong> ê·œì¹™ì„ ì ìš©í•˜ì—¬ ìµœì¢… ê²°ë¡ ì„ ì–»ì–´ë‚´ì„¸ìš”.",
              "ì¢‹ìŠµë‹ˆë‹¤. ì´ì œ LOGOS ORGANONì˜ ëª¨ë“  ì¶”ë¡  ê·œì¹™ì„ ë°°ìš°ì…¨ìŠµë‹ˆë‹¤.<br><br>ì‚¬ìœ ì‹œê°„ ì™¸ ì–¸ì œë¼ë„ ìœ ë ˆì¹´! ë²„íŠ¼ì„ ëˆŒëŸ¬ ë…¼ì¦ êµ¬ì„± ì°½ì„ ì—´ê³ , ë°©ê¸ˆ ë°°ìš´ ì¶”ë¡  ê·œì¹™ë“¤ì„ í™œìš©í•´ ìì‹ ì˜ ìŠ¹ë¦¬ ë˜ëŠ” ìƒëŒ€ì˜ ìŠ¹ë¦¬ ë¶ˆê°€ëŠ¥ì„ ì¦ëª…í•˜ë©´ ì¦‰ì‹œ ê²Œì„ì—ì„œ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.",
            ],
            // Stage 9 (Index 8) - ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” ë¶€ë¶„
            [
              "ë§ˆì§€ë§‰ìœ¼ë¡œ ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ì¶”ë¡  ê·œì¹™ì„ í™œìš©í•´ ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ [ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° [í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]ë¥¼ ì¦ëª…í•´ ë³´ì„¸ìš”.",
            ],
          ],
          inferenceRules: {
            basic: "ê¸°ë³¸ ê·œì¹™",
            modusPonens: "ì „ê±´ ê¸ì • (P, P ë¼ë©´ Q âˆ´ Q)",
            modusTollens: "í›„ê±´ ë¶€ì • (Q ëŠ” ê±°ì§“ì´ë‹¤, P ë¼ë©´ Q âˆ´ P ëŠ” ê±°ì§“ì´ë‹¤)",
            hypotheticalSyllogism:
              "ê°€ì„¤ì  ì‚¼ë‹¨ë…¼ë²• (P ë¼ë©´ Q, Q ë¼ë©´ R âˆ´ P ë¼ë©´ R)",
            disjunctiveSyllogism:
              "ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²• (P ë˜ëŠ” Q, P ëŠ” ê±°ì§“ì´ë‹¤ âˆ´ Q)",
            universalApplication: "ë³´í¸ ì ìš© (AëŠ” Pë‹¤, ëª¨ë“  PëŠ” Që‹¤ âˆ´ AëŠ” Që‹¤)",
            existentialInstantiation: "ì¡´ì¬í™” (ëª¨ë“  PëŠ” Që‹¤ âˆ´ ì–´ë–¤ PëŠ” Që‹¤)",
            conjunctionElimination: "ë‹¨ìˆœí™” (P ê·¸ë¦¬ê³  Q âˆ´ P, Q)",
            doubleNegationElimination:
              "ì´ì¤‘ ë¶€ì • ì œê±° (P ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ âˆ´ P)",
            assumptionBased: "ê°€ì • ê¸°ë°˜ ê·œì¹™",
            conditionalIntroduction: "ì¡°ê±´ë¬¸ ë„ì… (P ê°€ì •, Q ë„ì¶œ âˆ´ P ë¼ë©´ Q)",
            reductioAdAbsurdum: "ê·€ë¥˜ë²• (P ê°€ì •, ëª¨ìˆœ ë„ì¶œ âˆ´ P ëŠ” ê±°ì§“ì´ë‹¤)",
            advanced: "ê³ ê¸‰ ê·œì¹™",
            proofByCases: "ê²½ìš° ë…¼ì¦ (P ë˜ëŠ” Q, P ë¼ë©´ R, Q ë¼ë©´ R âˆ´ R)",
          },

          alerts: {
            invalidCard: "ê·œì¹™ì— ë§ì§€ ì•ŠëŠ” ì¹´ë“œì…ë‹ˆë‹¤!",
            incompleteProposition:
              "ì™„ì„±ë˜ì§€ ì•Šì€ ëª…ì œì´ê±°ë‚˜ íŒŒì‹±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
            duplicateProposition: "ê°™ì€ ëª…ì œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.",
            contradictionFound:
              "ëª¨ìˆœì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤!<br>ì´ ëª…ì œëŠ” ê¸°ì¡´ì˜ ì°¸ ëª…ì œë“¤ê³¼ ì–‘ë¦½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            undoLastCard: "ë§ˆì§€ë§‰ìœ¼ë¡œ ë†“ì€ ì¹´ë“œë¥¼ ë˜ëŒë ¸ìŠµë‹ˆë‹¤.",
            undoLastProposition: "ë§ˆì§€ë§‰ìœ¼ë¡œ ì™„ì„±ëœ ëª…ì œë¥¼ ë˜ëŒë ¸ìŠµë‹ˆë‹¤.",
            nothingToUndo: "ë˜ëŒë¦´ ìˆ˜ ìˆëŠ” ì™„ì„±ëœ ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤.",
            roundEndNoMoves:
              "'{player}' í”Œë ˆì´ì–´ê°€ ë” ì´ìƒ ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œê°€ ì—†ì–´ ì‚¬ìœ  ì‹œê°„ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.",
            criticalErrorUndo:
              "ì§„ë¦¬ ì²´ê³„ë¥¼ ì¬êµ¬ì„±í•˜ëŠ” ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê²Œì„ì„ ìƒˆë¡œ ì‹œì‘í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            oneAssumptionOnly: "ê°€ì •ì€ í•œ ë²ˆì— í•˜ë‚˜ë§Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            parsingFailed:
              "ëª…ì œë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.",
            premiseNeededForIntro:
              "ì¡°ê±´ë¬¸ ë„ì… ê·œì¹™ì€ ê°€ì •ìœ¼ë¡œë¶€í„° ë„ì¶œëœ 'ê²°ë¡ ' ëª…ì œ í•˜ë‚˜ë§Œ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.",
            assumptionNeededForIntro:
              "ì¡°ê±´ë¬¸ ë„ì… ê·œì¹™ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë¨¼ì € 'ê°€ì •í•˜ê¸°'ë¥¼ í†µí•´ ê°€ì •ì„ í•´ì•¼ í•©ë‹ˆë‹¤.",
            premiseNotFromAssumption:
              "ì„ íƒí•œ ëª…ì œëŠ” í˜„ì¬ ê°€ì •ê³¼ ë¬´ê´€í•©ë‹ˆë‹¤. ê°€ì •ìœ¼ë¡œë¶€í„° íŒŒìƒëœ ëª…ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.",
            premiseCountError: "ì´ ê·œì¹™ì€ {count}ê°œì˜ ì „ì œê°€ í•„ìš”í•©ë‹ˆë‹¤.",
            contradictionNeededForRAA:
              "ê·€ë¥˜ë²•ì€ ì„œë¡œ ëª¨ìˆœë˜ëŠ” 2ê°œì˜ ì „ì œê°€ í•„ìš”í•©ë‹ˆë‹¤.",
            assumptionNeededForRAA:
              "ê·€ë¥˜ë²•ì„ ì ìš©í•˜ë ¤ë©´ ë¨¼ì € 'ê°€ì •í•˜ê¸°'ë¥¼ í†µí•´ ê°€ì •ì„ í•´ì•¼ í•©ë‹ˆë‹¤.",
            notAContradiction:
              "ëª¨ìˆœ ê´€ê³„ê°€ ì•„ë‹™ë‹ˆë‹¤. ê·€ë¥˜ë²•ì„ ì ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            ruleFailed: "ê·œì¹™ ì ìš©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì „ì œë“¤ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
            noTheoremsToAdd: "ì¶”ê°€í•  ìƒˆë¡œìš´ ì •ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.",
            proofIncomplete:
              "ì¦ëª…ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\nìì‹ ì˜ ìŠ¹ë¦¬ [{myGoal}] ë˜ëŠ”\nìƒëŒ€ì˜ íŒ¨ë°° [{opponentGoal}] ë¥¼ ë„ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.",
            oneCardPerTurn: "í•œ í„´ì— í•œ ì¥ì˜ ì¹´ë“œë§Œ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            aiEurekaDeclared: "AIê°€ 'ìœ ë ˆì¹´!'ë¥¼ ì„ ì–¸í–ˆìŠµë‹ˆë‹¤!",
            selectOneTheoremOnly: "í•˜ë‚˜ì˜ ìµœì¢… ì •ë¦¬ë§Œ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.",
            wittgensteinSuccess:
              "ìƒˆë¡œìš´ ì •ë¦¬ê°€ ì¶”ê°€ë˜ì—ˆê³ , ì¦ëª…ì— ì‚¬ìš©ëœ ì „ì œë“¤ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.",
            kantSuccess: "ìƒˆë¡œìš´ ëª…ì œê°€ ì°¸ ëª©ë¡ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!",
            confirmCloseEureka:
              "ìœ ë ˆì¹´! ì„ ì–¸ì€ í•œ ë¼ìš´ë“œì— í•œ ë²ˆë§Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>ì •ë§ ì°½ì„ ë‹«ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?",
            confirmExit: "ì •ë§ë¡œ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            tutorialVictory:
              "ì˜ í•˜ì…¨ìŠµë‹ˆë‹¤.<br>ì´ì œ ë…¼ë¦¬ ëŒ€ê²°ì— ì°¸ì—¬í•˜ì—¬ ë‹¹ì‹ ì˜ ì§€í˜œë¥¼ ì¦ëª…í•´ ë³´ì„¸ìš”!",
            puzzleCleared: "ì¶•í•˜í•©ë‹ˆë‹¤! í´ë¦¬ì–´í•˜ì…¨ìŠµë‹ˆë‹¤!",
            confirmDeclareEureka:
              "ìœ ë ˆì¹´! ì„ ì–¸ì€ í•œ ë¼ìš´ë“œì— í•œ ë²ˆë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.<br>ì„ ì–¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
          },
          keywords: {
            if: "ë¼ë©´",
            and: "ê·¸ë¦¬ê³ ",
            or: "ë˜ëŠ”",
            not: "ëŠ” ê±°ì§“ì´ë‹¤",
            wins: "ìŠ¹ë¦¬í•œë‹¤",
            socrates: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ”",
            plato: "í”Œë¼í†¤ì€",
            universal_q: "ëª¨ë“ ",
            existential_q: "ì–´ë–¤",
          },
          cards: [
            { type: "ì–‘í™”ì‚¬", text: "ì–´ë–¤" },
            { type: "ì–‘í™”ì‚¬", text: "ëª¨ë“ " },
            { type: "ì—°ì‚°ì", text: "ë¼ë©´" },
            { type: "ì—°ì‚°ì", text: "ê·¸ë¦¬ê³ " },
            { type: "ì—°ì‚°ì", text: "ë˜ëŠ”" },
            { type: "ì—°ì‚°ì", text: "ëŠ” ê±°ì§“ì´ë‹¤" },
            { type: "ê°œì²´", text: "ìƒˆëŠ”" },
            { type: "ê°œì²´", text: "ë¬¼ê³ ê¸°ëŠ”" },
            { type: "ê°œì²´", text: "ê°œëŠ”" },
            { type: "ê³ ìœ ëª…ì‚¬", text: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ”" },
            { type: "ê³ ìœ ëª…ì‚¬", text: "í”Œë¼í†¤ì€" },
            { type: "ì„œìˆ ì–´", text: "ì„ í•˜ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ì•…í•˜ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ì§€í˜œë¡­ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ì–´ë¦¬ì„ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ìƒˆì´ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ë¬¼ê³ ê¸°ì´ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ê°œì´ë‹¤" },
            { type: "ì„œìˆ ì–´", text: "ìŠ¹ë¦¬í•œë‹¤" },
          ],
          cardTypes: ["ê³ ìœ ëª…ì‚¬", "ì–‘í™”ì‚¬", "ê°œì²´", "ì„œìˆ ì–´", "ì—°ì‚°ì"],
          axiom_templates: {
            identity: [
              "ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ìƒˆì´ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ë¬¼ê³ ê¸°ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ë¬¼ê³ ê¸°ì´ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ê°œì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ê°œì´ë‹¤",
            ],
            subject_good_evil: [
              "{S} ì„ í•˜ë‹¤ ë˜ëŠ” {S} ì•…í•˜ë‹¤",
              "{S} ì„ í•˜ë‹¤ ë¼ë©´ {S} ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            subject_wise_foolish: [
              "{S} ì§€í˜œë¡­ë‹¤ ë˜ëŠ” {S} ì–´ë¦¬ì„ë‹¤",
              "{S} ì§€í˜œë¡­ë‹¤ ë¼ë©´ {S} ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            bird_good_evil_forward: [
              "ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ìƒˆëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            bird_good_evil_reverse: [
              "ì–´ë–¤ ìƒˆëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤",
            ],
            fish_good_evil_forward: [
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            fish_good_evil_reverse: [
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤",
            ],
            dog_good_evil_forward: [
              "ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            dog_good_evil_reverse: [
              "ì–´ë–¤ ê°œëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤",
            ],
          },
          victoryPredicates: ["ì„ í•˜ë‹¤", "ì•…í•˜ë‹¤", "ì§€í˜œë¡­ë‹¤", "ì–´ë¦¬ì„ë‹¤"],
          contradictoryPredicates: { ì„ í•˜ë‹¤: "ì•…í•˜ë‹¤", ì§€í˜œë¡­ë‹¤: "ì–´ë¦¬ì„ë‹¤" },
          labels: {
            proposition: "[ëª…ì œ]",
            axiom: "[ê³µë¦¬]",
            victory_condition: "[ìŠ¹ë¦¬ ì¡°ê±´]",
            theorem: "[ì •ë¦¬]",
            assumption: "[ê°€ì •]",
            ci_theorem: "[ì¡°ê±´ë¬¸ ë„ì…]",
            raa_theorem: "[ê·€ë¥˜ë²• ì¦ëª…]",
            theorem_source: "[ì •ë¦¬] {text} (R{round} ì‚¬ìœ )",
            victory_text: "{owner} ìŠ¹ë¦¬ ì¡°ê±´: <strong>{text}</strong>",
            plato_ability_source: "{text} (ì´ë°ì•„ íšŒìƒ)",
            nietzsche_ability_source: "{text} (ì˜ì› íšŒê·€)",
            wittgenstein_ability_source: "{text} (ì‚¬ë‹¤ë¦¬ ê±·ì–´ì°¨ê¸°)",
            derrida_ability_source: "{text} (í•´ì²´)",
            hume_ability_source: "{text} (ê·€ë‚©ì˜ ë¬¸ì œ)",
            kuhn_ability_source: "{text} (íŒ¨ëŸ¬ë‹¤ì„ ì „í™˜)",
            kant_ability_source: "{text} (ì„ í—˜ì  ì¢…í•©íŒë‹¨)",
          },
        },
        en: {
          langCode: "en",
          ui: {
            title: "LOGOS ORGANON",
            tutorialButton: "Tutorial",
            tutorialPuzzleButton: "Tutorial Puzzle",
            puzzleButton: "Puzzle",
            exitGameButton: "Exit Game",
            creditsButton: "Credits",
            endTutorialButton: "End Tutorial",
            newGameButton: "New Game",
            fullscreenButton: "Fullscreen",
            settingsButton: "Settings",
            settingsTitle: "Settings",
            bgmLabel: "BGM",
            sfxLabel: "SFX",
            vsAIButton: "1P vs AI",
            vsPlayerButton: "1P vs 2P",
            playerAName: "Socrates",
            playerAColor: "âšªï¸ White",
            playerBName: "Plato",
            playerBColor: "âš«ï¸ Black",
            currentPropositionTitle: "Current Proposition",
            completeButton: "Complete",
            undoButton: "Undo",
            endTurnButton: "End Turn",
            truePropositionsTitle: "True Propositions",
            eurekaButton: "Eureka!",
            addTheoremButton: "Add Theorem â•",
            roundDisplay: "Round {round}",
            axiomTitle: "Basic Axioms (Click to expand)",
            statusTurn: "'s Turn",
            statusAITurn: "AI is thinking...",
            thinkingTimeStatus: "Thinking Time. Derive new theorems.",
            thinkingTimeTitle: "Thinking Time",
            thinkingTimeDesc:
              "Derive new theorems and add them to the list using the 'Add Theorem' button.",
            endThinkingTimeButton: "End Thinking Time & Start Next Round",
            victoryMessage: "Player Wins!",
            victorySubMessage: "Succeeded with a logical proof!",
            okButton: "OK",
            cancelButton: "Cancel",
            nextButton: "Next",
            yesButton: "Yes",
            noButton: "No",
            cancelAssumptionButton: "Cancel",
            selectP1Philosopher: "1P, Select Your Philosopher",
            selectP2Philosopher: "2P, Select Your Philosopher",
            selectYourPhilosopher: "Select Your Philosopher",
            selectAIPhilosopher: "Select AI's Philosopher",
            gameStartingSoon: "Game starting soon...",
            turnOrderTitle: "Choose Turn Order",
            selectFirstPlayer: "Go First",
            selectSecondPlayer: "Go Second",
            skillTitle: "Unique Ability",
            thinkingTimeTurnMessage: "'s Thinking Time.",
            useAbilityButton: "Use Ability",
            platoAbilityTitle: "Recollection of Forms",
            platoConfirmButton: "Universalize this Proposition",
            socratesAbilityTitle: "Awareness of Ignorance",
            socratesConfirmButton: "Exclude this proposition from arguments",
            wittgensteinAbilityTitle: "Kicking Away the Ladder",
            wittgensteinConfirmButton: "Derive Theorem & Delete Premises",
            vsAIBattleButton: "AI vs AI",
            selectAIP1Philosopher: "Select AI 1P's Philosopher",
            selectAIP2Philosopher: "Select AI 2P's Philosopher",
            aiSummaryTitleDefault: "AI's Turn Result",
            aiSummaryTitleTheorem: "AI has derived a new theorem.",
            aiSummaryTitleAbility: "AI has used an ability.",
            abilityLabel: "[Ability]",
            theoremLabel: "[Theorem]",
            platoAbilityDescription:
              "[Recollection of Forms] ability was used to derive '{proposition}'.",
            socratesAbilityDescription:
              "[Awareness of Ignorance] ability was used to exclude '{proposition}' from arguments for the next round.",
            descartesAbilityDescription:
              "[Methodic Doubt] ability was used to delete '{proposition}' from the list of true propositions.",
            humeAbilityDescription:
              "[Problem of Induction] ability was used to weaken '{proposition}'.",
            wittgensteinAbilityDescription:
              "[Kicking Away the Ladder] ability was used to derive the theorem '{newTheorem}' and delete its premises.",
            kuhnAbilityDescription:
              "[Paradigm Shift] ability was used to establish a new paradigm: '{newParadigm}'.",
            derridaAbilityDescription:
              "[Deconstruction] ability was used to deconstruct the proposition '{proposition}'.",
            kantAbilityDescription:
              "[Synthetic A Priori Judgment] ability was used to derive '{proposition}'.",
            vsPlayerDesc: "Two players face off on a single computer.",
            vsAIDesc: "Practice the game by playing against the AI.",
            tutorialDesc:
              "Learn the basic rules of the game and the rules of inference.",
            puzzleDesc:
              "Solve pre-made logical reasoning puzzles without competition.",
          },
          modals: {
            characterSelectTitle: "Select Your Philosopher",
            selectSocrates: "Socrates (White) âšªï¸",
            selectPlato: "Plato (Black) âš«ï¸",
            eurekaTitleVictory: "Eureka! Construct Proof",
            eurekaTitleTheorem: "Thinking Time: Construct Theorem",
            premiseSelectionTitle: "Available Premises List",
            applyRuleButton: "Apply",
            addAssumptionButton: "Assume",
            confirmVictoryButton: "Prove Victory with this Argument!",
            confirmTheoremButton: "Add Selected Theorems to True List â•",
            tutorialTitle: "LOGOS ORGANON Tutorial",
            promptInputPlaceholder: "Enter proposition...",
            puzzleTitle: "Select Level",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "Welcome to LOGOS ORGANON!",
              "Before we begin, let's go over a few core rules.",
              "<strong>Win Condition:</strong> At the start of each game, you get a random <strong>Win Condition</strong>.<br><br>You win by declaring <strong>Eureka!</strong>, which is possible once per round, and proving either <strong>your own victory</strong> or <strong>your opponent's defeat</strong>.<br><br>For example, if your philosopher is Socrates and your opponent's is Plato, you win by proving either <strong>Socrates wins</strong> or <strong>Plato wins is false</strong>.",
              "<strong>First Turn:</strong> The first round always begins with the White player.<br><br><strong>Alternating Turns:</strong> The starting player alternates each round.",
              "Now, let's learn the most basic action: how to form a <strong>proposition</strong>.",
              "This is your <strong>hand</strong>. It contains various word cards.",
              "You will move cards here to form a <strong>proposition</strong>.",
              "Click a card to move it to the <strong>Current Proposition</strong> area.",
              "Excellent! A <strong>Proper Noun</strong> like <strong>Socrates</strong> can start a proposition directly.",
              "However, <strong>Entity</strong> cards like <strong>dog</strong>, <strong>bird</strong>, and <strong>fish</strong> must always follow a <strong>Quantifier</strong> card like <strong>Every</strong> or <strong>Some</strong>.<br><br>Also, a proper noun card cannot be placed after a quantifier.<br>Saying 'Every Socrates' or 'Some Socrates' is impossible, both intuitively and by the rules.<br><br>Please remember this crucial point!",
              "Each player must play exactly one card per turn, and if they have a playable card, they must play it.<br><br>Now that you've played a card, shall we end the turn?",
              "Press the <strong>End Turn</strong> button to pass the turn to your opponent.",
              "Next, let's learn how to respond to the proposition passed by your opponent.",
            ],
            // Stage 2 (Index 1)
            [
              "Your opponent's turn is over. It's your turn again.",
              "The proposition your opponent made is grammatically complete. You have several options now.",
              "<strong>First Option: Complete Proposition.</strong> This accepts the current statement as <strong>true</strong>. Since there are no contradictions for now, let's press the <strong>Complete Proposition</strong> button to add it to the <strong>List of True Propositions</strong>.",
              "The proposition has been added to the List of True Propositions.<br><br>There are two important conditions for a proposition to be added.",
              "First, you cannot add a proposition if the exact same one already exists.",
              "Second, you cannot add a proposition that contradicts an existing truth.",
              "Instead of completing the proposition, other options are also available.",
              "<strong>Second Option: Extend.</strong> You can add <strong>connective</strong> cards like <strong>and</strong>, <strong>or</strong>, or <strong>then</strong> to make the proposition more complex.<br><br>Remember, you can only use one connective per proposition.",
              "<strong>Third Option: Negate.</strong> If a proposition is disadvantageous, you can add the <strong>is false</strong> card from your hand to negate it.<br>But be careful! If your opponent also plays a negation card, your negation can be immediately nullified by the <strong>Double Negation</strong> rule.<br><br>Also, when <strong>is false</strong> is attached to a sentence with a connective, it only negates the smallest proposition it's attached to, not the whole sentence.<br><br>For example, in <strong>Some dog is good and Socrates is evil is false</strong>, only the <strong>Socrates is evil</strong> part is negated.",
              "Now you've learned the various ways to respond to an opponent's proposition. Next, let's learn about the <strong>Basic Axioms</strong> that form the foundation of our arguments.",
            ],
            // Stage 3 (Index 2)
            [
              "The List of True Propositions contains not only the propositions we've made, but also the <strong>Basic Axioms</strong> which are the foundation of all arguments.",
              "Click this item to see what axioms are available.",
              "Axioms are propositions that are accepted as true without proof, such as 'Every dog is a dog'.",
              "According to the axioms, the same entity <strong>cannot have two opposing properties at the same time</strong>, like being both 'good' and 'evil'.<br><br>Furthermore, a statement about an entire group, such as <strong>Every dog</strong>, cannot be contradicted by a statement about a part of that group, such as <strong>Some dog</strong>.<br><br>For example, <strong>Every dog is good</strong> and <strong>Some dog is evil</strong> cannot both be true at the same time.",
              "You can use these axioms as important premises when constructing your arguments.",
              "Now that you've checked the basic axioms, let's find out what happens when you cannot play any card.",
            ],
            // Stage 4 (Index 3)
            [
              "As the game progresses, a situation will arise where the current player can neither play a card nor complete the proposition.",
              "When this happens, the round ends and <strong>Thinking Time</strong> begins.",
              "During Thinking Time, players take one turn each, starting with the player who went second in that round. You can derive new <strong>theorems</strong> based on the existing true propositions.",
              "Your opponent is ending their turn.",
              "Now it's your turn. Press the <strong>Add Theorem</strong> button.",
              "The proof workbench has opened. Let's create a new theorem using the <strong>Universal Application</strong> rule. We will learn the specific uses of inference rules later.",
              "Select the premises <strong>Socrates is a dog</strong> and <strong>Every dog is wise</strong> from the list.",
              "Now, select <strong>Universal Application</strong> from the dropdown and click the <strong>Apply Rule</strong> button.",
              "The new theorem <strong>Socrates is wise</strong> has been derived.<br><br>Now, select this theorem and press the <strong>Add Selected Theorems to True List</strong> button to finalize the proof.",
              "The new theorem has been added to the <strong>List of True Propositions</strong>.<br>In Thinking Time, besides creating new theorems, you can also use your philosopher's <strong>unique ability</strong>. Abilities have limited uses per game, but they are powerful tools that can turn the tide or solidify your advantage.",
              "Now press the <strong>End Turn</strong> button to finish Thinking Time and start the next round.<br>When a new round starts, you get all your played cards back, and the List of True Propositions remains.",
            ],
            // Stage 5 (Index 4)
            [
              "You've learned the game flow. Now, let's learn the <strong>inference rules</strong> used to construct arguments. Press the <strong>Eureka!</strong> button to open the proof workbench.",
              // 1. Modus Ponens
              "First up is <strong>Modus Ponens</strong>. It's the most intuitive rule: if the first part of a 'then' statement is true, the second part must also be true.",
              "From the premise list, select <strong>Socrates is good</strong> and <strong>Socrates is good then Socrates wins</strong>.",
              "Select <strong>Modus Ponens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 2. Modus Tollens
              "Great. The conclusion <strong>Socrates wins</strong> has been derived.<br><br>Now let's practice <strong>Modus Tollens</strong>. If the second part of a 'then' statement is false, the first part must also be false.<br>For example, from 'If it rains, then the ground is wet', if the ground is not wet, you intuitively know it didn't rain.",
              "From the premise list, select <strong>Plato is wise is false</strong> and <strong>Plato wins then Plato is wise</strong>.",
              "Select <strong>Modus Tollens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 3. Disjunctive Syllogism
              "The conclusion <strong>Plato wins is false</strong> has been derived.<br><br>Next is <strong>Disjunctive Syllogism</strong>.<br>In an <strong>or</strong> statement, if one part is false, the other must be true.",
              "From the premise list, select <strong>Some bird is a fish or Some bird is a bird</strong> and <strong>Some bird is a fish is false</strong>.",
              "Select <strong>Disjunctive Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 4. Hypothetical Syllogism
              "<strong>Some bird is a bird</strong> has been derived.<br><br>Now for <strong>Hypothetical Syllogism</strong>. Let's combine two chaining propositions into one.",
              "Select <strong>Plato is a dog then Plato is good</strong> and <strong>Plato is good then Plato wins</strong>.",
              "Select <strong>Hypothetical Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 5. Conjunction Elimination (Simplification)
              "A more concise proposition <strong>Plato is a dog then Plato wins</strong> has been created. Next is the <strong>Simplification</strong> rule.",
              "A statement connected by <strong>and</strong> means both parts are true. From the premise list, select <strong>Socrates is wise and Plato is foolish</strong>.",
              "Select <strong>Simplification</strong> from the rule list and click <strong>Apply Rule</strong>. Two propositions will be derived at once.",
              // 6. Double Negation Elimination
              "As you can see, the two propositions have been separated.<br><br>Now let's learn the <strong>Double Negation Elimination</strong> rule. Two negatives make a positive.",
              "Select <strong>Some fish is good is false is false</strong> from the premise list.",
              "Select <strong>Double Negation Elimination</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 7. Universal Application
              "It's back to the original positive statement.<br><br>Next up is the <strong>Universal Application</strong> rule. A universal rule applies to specific instances.",
              "Select <strong>Every bird is good</strong> and <strong>Plato is a bird</strong> from the premise list.",
              "Select <strong>Universal Application</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 8. Existential Instantiation
              "<strong>Plato is good</strong> has been derived.<br><br>Next is the <strong>Existential Instantiation</strong> rule. Axioms like 'Some bird is a bird', 'Some dog is a dog', and 'Some fish is a fish' guarantee that entities exist. Therefore, if a property is true for <strong>Every</strong> member of a group, it can be derived that it is true for <strong>Some</strong> members.",
              "Select <strong>Every dog is good</strong> from the premise list.",
              "Select <strong>Existential Instantiation</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // End of Stage 5
              "<strong>Some dog is good</strong> has been derived.<br><br>Next, let's learn a powerful rule for combining multiple propositions at once.",
            ],
            // Stage 6 (Index 5)
            [
              "The <strong>Proof by Cases</strong> rule we'll learn now brings multiple diverging paths to a single conclusion.",
              "We have two cases: <strong>Plato is good or Plato is evil</strong>. However, either case leads to the conclusion <strong>Plato is wise</strong>. First, please select all three required premises.",
              "Now, select <strong>Proof by Cases</strong> from the rule list and click <strong>Apply Rule</strong> to derive the conclusion.",
              "The conclusion <strong>Plato is wise</strong> has been derived.<br><br>Next up are rules that use <strong>assumptions</strong>, the heart of logic.",
            ],
            // Stage 7 (Index 6)
            [
              "Sometimes, to prove something, you need to assume <strong>what if...</strong>. This time, let's logically connect two premises.",
              "Click the <strong>Assume</strong> button and assume <strong>Socrates is wise</strong> by typing it in.",
              "Great. Now, select the assumption and the first premise: <strong>Socrates is wise then Plato is a dog</strong>.",
              "Apply the <strong>Modus Ponens</strong> rule to derive an intermediate conclusion.",
              "Now, select the intermediate conclusion you just got and the second premise: <strong>Plato is a dog then Plato is good</strong>.",
              "Apply the <strong>Modus Ponens</strong> rule again to derive the final conclusion.",
              "Select the final result, <strong>Plato is good</strong>.",
              "Finally, apply the <strong>Conditional Introduction</strong> rule. This will create the new theorem <strong>Socrates is wise then Plato is good</strong>.",
              "Now let's learn about Reductio ad Absurdum.",
            ],
            // Stage 8 (Index 7)
            [
              "<strong>Reductio ad Absurdum</strong> is a method of proving something by assuming its <strong>opposite</strong> to find a contradiction.",
              "Our goal is to prove <strong>Socrates is evil</strong>. Click <strong>Assume</strong> and assume the opposite: <strong>Socrates is evil is false</strong>.",
              "The assumption has been added. Now, let's use it to create an obvious contradiction, a pair of 'P' and '~P'. Select the assumption you just made and the other premise, then apply the <strong>Modus Ponens</strong> rule.",
              "<strong>Plato is wise</strong> has been derived. But we already have <strong>Plato is wise is false</strong> in our list of true propositions. This is a contradiction!",
              "Now, select the two contradictory propositions and apply the <strong>Reductio ad Absurdum</strong> rule.",
              "This proves our initial assumption was wrong. Now, apply the <strong>Double Negation Elimination</strong> rule to the result to get our final conclusion.",
              "Excellent. You have now learned all the inference rules of LOGOS ORGANON.<br><br>At any time outside of Thinking Time, you can open the proof workbench with the Eureka! button. Use the rules you've learned to prove your own victory or your opponent's inability to win, and you will immediately win the game.",
            ],
            [
              "Finally, using the inference rules you've learned so far, try to prove your victory [Socrates wins] or your opponent's defeat [Plato wins is false].",
            ],
          ],
          inferenceRules: {
            basic: "Basic Rules",
            modusPonens: "Modus Ponens (P, P then Q âˆ´ Q)",
            modusTollens: "Modus Tollens (Q is false, P then Q âˆ´ ~P)",
            hypotheticalSyllogism:
              "Hypothetical Syllogism (P then Q, Q then R âˆ´ P then R)",
            disjunctiveSyllogism:
              "Disjunctive Syllogism (P or Q, P is false âˆ´ Q)",
            universalApplication:
              "Universal Application (A is P, Every P are Q âˆ´ A is Q)",
            existentialInstantiation:
              "Existential Instantiation (Every P is Q âˆ´ Some P is Q)",
            conjunctionElimination: "Simplification (P and Q âˆ´ P, Q)",
            doubleNegationElimination:
              "Double Negation Elimination (P is false is false âˆ´ P)",
            assumptionBased: "Assumption-Based Rules",
            conditionalIntroduction:
              "Conditional Introduction (Assume P, derive Q âˆ´ P then Q)",
            reductioAdAbsurdum:
              "Reductio ad Absurdum (Assume P, derive contradiction âˆ´ P is false)",
            advanced: "Advanced Rules",
            proofByCases: "Proof by Cases (P or Q, P then R, Q then R âˆ´ R)",
          },
          alerts: {
            invalidCard: "This card cannot be played here.",
            incompleteProposition:
              "The proposition is incomplete or could not be parsed.",
            duplicateProposition: "The same proposition already exists.",
            contradictionFound:
              "Contradiction found!<br>This proposition is not compatible with the set of true propositions.",
            undoLastCard: "Reverted the last played card.",
            undoLastProposition: "Reverted the last completed proposition.",
            nothingToUndo: "There are no completed propositions to undo.",
            roundEndNoMoves:
              "Player '{player}' has no valid moves. Entering thinking time.",
            criticalErrorUndo:
              "A critical error occurred while rebuilding the truth set. You may need to restart the game.",
            oneAssumptionOnly: "You can only have one assumption at a time.",
            parsingFailed:
              "Could not parse the proposition. Please check the format.",
            premiseNeededForIntro:
              "For Conditional Introduction, you must select exactly one conclusion derived from the assumption.",
            assumptionNeededForIntro:
              "You must make an assumption first to use Conditional Introduction.",
            premiseNotFromAssumption:
              "The selected proposition does not depend on the current assumption.",
            premiseCountError: "This rule requires {count} premises.",
            contradictionNeededForRAA:
              "Reductio ad Absurdum requires 2 contradictory premises.",
            assumptionNeededForRAA:
              "You must make an assumption first to use Reductio ad Absurdum.",
            notAContradiction: "The selected premises are not a contradiction.",
            ruleFailed: "Failed to apply the rule. Please check your premises.",
            noTheoremsToAdd: "There are no new, non-dependent theorems to add.",
            proofIncomplete:
              "Proof incomplete.\nYou must derive your victory [{myGoal}] or your opponent's defeat [{opponentGoal}].",
            oneCardPerTurn: "You can only play one card per turn.",
            aiEurekaDeclared: "AI has declared 'Eureka!'",
            selectOneTheoremOnly: "You must select exactly one final theorem.",
            wittgensteinSuccess:
              "The new theorem has been added, and the premises used for its proof have been deleted.",
            kantSuccess: "A new proposition has been added to the true list!",
            confirmCloseEureka:
              "Eureka! can only be declared once per round.<br>Are you sure you want to close this window?",
            confirmExit: "Are you sure you want to exit?",
            tutorialVictory:
              "Well done!<br>Now, engage in a battle of wits and prove your wisdom!",
            puzzleCleared: "Congratulations! You cleared the puzzle!",
            confirmDeclareEureka:
              "Eureka! can only be declared once per round.<br>Do you want to proceed?",
          },
          keywords: {
            if: "then",
            and: "and",
            or: "or",
            not: "is false",
            wins: "wins",
            socrates: "Socrates",
            plato: "Plato",
            universal_q: "Every",
            existential_q: "Some",
          },
          cards: [
            { type: "Quantifier", text: "Some" },
            { type: "Quantifier", text: "Every" },
            { type: "Operator", text: "then" },
            { type: "Operator", text: "and" },
            { type: "Operator", text: "or" },
            { type: "Operator", text: "is false" },
            { type: "Entity", text: "bird" },
            { type: "Entity", text: "fish" },
            { type: "Entity", text: "dog" },
            { type: "Proper Noun", text: "Socrates" },
            { type: "Proper Noun", text: "Plato" },
            { type: "Predicate", text: "is good" },
            { type: "Predicate", text: "is evil" },
            { type: "Predicate", text: "is wise" },
            { type: "Predicate", text: "is foolish" },
            { type: "Predicate", text: "is a bird" },
            { type: "Predicate", text: "is a fish" },
            { type: "Predicate", text: "is a dog" },
            { type: "Predicate", text: "wins" },
          ],
          cardTypes: [
            "Proper Noun",
            "Quantifier",
            "Entity",
            "Predicate",
            "Operator",
          ],
          axiom_templates: {
            identity: [
              "Some bird is a bird",
              "Every bird is a bird",
              "Some fish is a fish",
              "Every fish is a fish",
              "Some dog is a dog",
              "Every dog is a dog",
            ],
            subject_good_evil: [
              "{S} is good or {S} is evil",
              "{S} is good then {S} is evil is false",
            ],
            subject_wise_foolish: [
              "{S} is wise or {S} is foolish",
              "{S} is wise then {S} is foolish is false",
            ],
            bird_good_evil_forward: [
              "Every bird is good then Some bird is evil is false",
              "Every bird is evil then Some bird is good is false",
              "Every bird is wise then Some bird is foolish is false",
              "Every bird is foolish then Some bird is wise is false",
            ],
            bird_good_evil_reverse: [
              "Some bird is good is false then Every bird is evil",
              "Some bird is evil is false then Every bird is good",
              "Some bird is wise is false then Every bird is foolish",
              "Some bird is foolish is false then Every bird is wise",
            ],
            fish_good_evil_forward: [
              "Every fish is good then Some fish is evil is false",
              "Every fish is evil then Some fish is good is false",
              "Every fish is wise then Some fish is foolish is false",
              "Every fish is foolish then Some fish is wise is false",
            ],
            fish_good_evil_reverse: [
              "Some fish is good is false then Every fish is evil",
              "Some fish is evil is false then Every fish is good",
              "Some fish is wise is false then Every fish is foolish",
              "Some fish is foolish is false then Every fish is wise",
            ],
            dog_good_evil_forward: [
              "Every dog is good then Some dog is evil is false",
              "Every dog is evil then Some dog is good is false",
              "Every dog is wise then Some dog is foolish is false",
              "Every dog is foolish then Some dog is wise is false",
            ],
            dog_good_evil_reverse: [
              "Some dog is good is false then Every dog is evil",
              "Some dog is evil is false then Every dog is good",
              "Some dog is wise is false then Every dog is foolish",
              "Some dog is foolish is false then Every dog is wise",
            ],
          },
          victoryPredicates: ["is good", "is evil", "is wise", "is foolish"],
          contradictoryPredicates: {
            "is good": "is evil",
            "is wise": "is foolish",
          },
          labels: {
            proposition: "[Prop]",
            axiom: "[Axiom]",
            victory_condition: "[WinCon]",
            theorem: "[Thm]",
            assumption: "[Asmp]",
            ci_theorem: "[CI Thm]",
            raa_theorem: "[RAA Thm]",
            theorem_source: "[Thm] {text} (R{round} Thinking)",
            victory_text: "{owner} Win Condition: {text}",
            plato_ability_source: "{text} (Recollection of Forms)",
            nietzsche_ability_source: "{text} (Eternal Recurrence)",
            wittgenstein_ability_source: "{text} (Kicking Away the Ladder)",
            derrida_ability_source: "{text} (Deconstruction)",
            hume_ability_source: "{text} (Problem of Induction)",
            kuhn_ability_source: "{text} (Paradigm Shift)",
            kant_ability_source: "{text} (Synthetic A Priori Judgment)",
          },
        },
      };

      const PHILOSOPHERS = {
        aristotle: {
          id: "aristotle",
          name: { ko: "ì•„ë¦¬ìŠ¤í† í…”ë ˆìŠ¤", en: "Aristotle" },
          cardText: { ko: "ì•„ë¦¬ìŠ¤í† í…”ë ˆìŠ¤ëŠ”", en: "Aristotle" },
          image: {
            p1: "assets/images/ari_p1.png",
            p2: "assets/images/ari_p2.png",
          },
          icon: "assets/images/ari_icon.png",
          skill: {
            ko: "í˜•ì‹ ë…¼ë¦¬í•™: íŠ¹ë³„í•œ ëŠ¥ë ¥ì€ ì—†ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ê²Œì„ì˜ ëª¨ë“  ë§¤ì»¤ë‹ˆì¦˜ì€ ê·¸ ë•ë¶„ì— ì¡´ì¬í•œë‹¤ëŠ” ì‚¬ì‹¤ì„ ê¸°ì–µí•˜ì„¸ìš”.",
            en: "Formal Logic: Has no special ability. However, remember. All the mechanisms of this game exist thanks to him.",
          },
        },
        socrates: {
          id: "socrates",
          name: { ko: "ì†Œí¬ë¼í…ŒìŠ¤", en: "Socrates" },
          cardText: { ko: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ”", en: "Socrates" },
          image: {
            p1: "assets/images/socrat_p1.png",
            p2: "assets/images/socrat_p2.png",
          },
          icon: "assets/images/socra_icon.png",
          skill: {
            ko: "ë¬´ì§€ì˜ ìê°: ê²Œì„ë‹¹ ë‘ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— ì°¸ ëª…ì œ ëª©ë¡ì—ì„œ ê³µë¦¬ì™€ ìŠ¹ë¦¬ì¡°ê±´ì´ ì•„ë‹Œ ëª…ì œë¥¼ í•˜ë‚˜ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ ëª…ì œëŠ” ë‹¤ìŒ ë¼ìš´ë“œë™ì•ˆ ì–‘ í”Œë ˆì´ì–´ ëª¨ë‘ ë…¼ì¦ì˜ ì „ì œë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            en: "Awareness of Ignorance: Twice per game, during Thinking Time, you may choose one proposition from the list of true propositions that is not an axiom or a win condition. For the next round, that proposition cannot be used as a premise by either player.",
          },
        },
        plato: {
          id: "plato",
          name: { ko: "í”Œë¼í†¤", en: "Plato" },
          cardText: { ko: "í”Œë¼í†¤ì€", en: "Plato" },
          image: {
            p1: "assets/images/pl_p1.png",
            p2: "assets/images/pl_p2.png",
          },
          icon: "assets/images/pl_icon.png",
          skill: {
            ko: "ì´ë°ì•„ íšŒìƒ: ê²Œì„ë‹¹ í•œ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— ëª¨ìˆœì´ ë°œìƒí•˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ 'ì–´ë–¤ AëŠ” Bë‹¤'ì—ì„œ 'ëª¨ë“  AëŠ” Bë‹¤'ë¥¼ ë„ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            en: "Recollection of Forms: Once per game, during Thinking Time, you can derive 'Every A is B' from 'Some A is B' as long as no contradiction arises.",
          },
        },
        descartes: {
          id: "descartes",
          name: { ko: "ë¥´ë„¤ ë°ì¹´ë¥´íŠ¸", en: "RenÃ© Descartes" },
          cardText: { ko: "ë°ì¹´ë¥´íŠ¸ëŠ”", en: "Descartes" },
          image: {
            p1: "assets/images/de_p1.png",
            p2: "assets/images/de_p2.png",
          },
          icon: "assets/images/de_icon.png",
          skill: {
            ko: "ë°©ë²•ì  íšŒì˜: ê²Œì„ë‹¹ í•œ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— ì°¸ ëª…ì œ ëª©ë¡ì—ì„œ ê³µë¦¬ì™€ ìŠ¹ë¦¬ì¡°ê±´ì´ ì•„ë‹Œ ëª…ì œ í•˜ë‚˜ë¥¼ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            en: "Methodic Doubt: Once per game, during Thinking Time, you may delete one proposition from the list of true propositions that is not an axiom or a win condition.",
          },
        },
        hume: {
          id: "hume",
          name: { ko: "ë°ì´ë¹„ë“œ í„", en: "David Hume" },
          cardText: { ko: "í„ì€", en: "Hume" },
          image: {
            p1: "assets/images/hu_p1.png",
            p2: "assets/images/hu_p2.png",
          },
          icon: "assets/images/hu_icon.png",
          skill: {
            ko: "ê·€ë‚©ì˜ ë¬¸ì œ: ê²Œì„ë‹¹ ë‘ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— 'ëª¨ë“  AëŠ” Bë‹¤' í•˜ë‚˜ë¥¼ 'ì–´ë–¤ AëŠ” Bë‹¤'ë¡œ êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            en: "Problem of Induction: Twice per game, during Thinking Time, you may replace an 'Every A is B' proposition with 'Some A is B'.",
          },
        },
        kant: {
          id: "kant",
          name: { ko: "ì„ë§ˆëˆ„ì—˜ ì¹¸íŠ¸", en: "Immanuel Kant" },
          cardText: { ko: "ì¹¸íŠ¸ëŠ”", en: "Kant" },
          image: {
            p1: "assets/images/ka_p1.png",
            p2: "assets/images/ka_p2.png",
          },
          icon: "assets/images/ka_icon.png",
          skill: {
            ko: "ì„ í—˜ì  ì¢…í•©íŒë‹¨: ê²Œì„ë‹¹ í•œ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨ìˆœì´ ë°œìƒí•˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ, ì†ì— ë‚¨ì•„ìˆëŠ” ì¹´ë“œë¡œ ëª…ì œ í•˜ë‚˜ë¥¼ ë§Œë“¤ì–´ ì°¸ ëª…ì œ ëª©ë¡ì— ì¶”ê°€í•©ë‹ˆë‹¤.",
            en: "Synthetic A Priori Judgment: Once per game, during Thinking Time, you may create one proposition using cards remaining in your hand and add it to the list of true propositions, as long as no contradiction arises.",
          },
        },
        nietzsche: {
          id: "nietzsche",
          name: { ko: "í”„ë¦¬ë“œë¦¬íˆ ë‹ˆì²´", en: "Friedrich Nietzsche" },
          cardText: { ko: "ë‹ˆì²´ëŠ”", en: "Nietzsche" },
          image: {
            p1: "assets/images/ni_p1.png",
            p2: "assets/images/ni_p2.png",
          },
          icon: "assets/images/ni_icon.png",
          skill: {
            ko: "ì˜ì› íšŒê·€: ì°¸ ëª…ì œ ëª©ë¡ì— ì¡´ì¬í•˜ëŠ” ëª…ì œë¥¼ ë¬´ì œí•œìœ¼ë¡œ ì¤‘ë³µí•´ì„œ ì™„ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            en: "Eternal Recurrence: You can complete propositions that already exist in the list of true propositions an unlimited number of times.",
          },
        },
        marx: {
          id: "marx",
          name: { ko: "ì¹´ë¥¼ ë§ˆë¥´í¬ìŠ¤", en: "Karl Marx" },
          cardText: { ko: "ë§ˆë¥´í¬ìŠ¤ëŠ”", en: "Marx" },
          image: {
            p1: "assets/images/ma_p1.png",
            p2: "assets/images/ma_p2.png",
          },
          icon: "assets/images/ma_icon.png",
          skill: {
            ko: "í”„ë¡¤ë ˆíƒ€ë¦¬ì•„ í˜ëª…: ê²Œì„ ì‹œì‘ ì‹œ, ì–‘ í”Œë ˆì´ì–´ì˜ ì†ì— 'ë¸Œë£¨ì£¼ì•„ëŠ”' ê°œì²´ ì¹´ë“œê°€ ì¶”ê°€ë˜ë©°, ì°¸ ëª…ì œ ëª©ë¡ì— '((ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì•…í•˜ë‹¤) ë¼ë©´ (í˜ëª…ì´ ì¼ì–´ë‚œë‹¤)) ê·¸ë¦¬ê³  ((í˜ëª…ì´ ì¼ì–´ë‚œë‹¤) ë¼ë©´ (ë§ˆë¥´í¬ìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤))'ë¼ëŠ” ìŠ¹ë¦¬ ì¡°ê±´ ëª…ì œì™€ ë¸Œë£¨ì£¼ì•„ì— ê´€í•œ ê³µë¦¬ê°€ ì¶”ê°€ë©ë‹ˆë‹¤.",
            en: "Proletarian Revolution: At the start of the game, a 'Bourgeois' entity card is added to both players' hands. A victory condition, '((Every Bourgeois is evil) then (a revolution occurs)) and ((a revolution occurs) then (Marx wins))' and axioms about Bourgeois are added to the list of true propositions.",
          },
        },
        wittgenstein: {
          id: "wittgenstein",
          name: { ko: "ë£¨íŠ¸ë¹„íˆ ë¹„íŠ¸ê²ìŠˆíƒ€ì¸", en: "Ludwig Wittgenstein" },
          cardText: { ko: "ë¹„íŠ¸ê²ìŠˆíƒ€ì¸ì€", en: "Wittgenstein" },
          image: {
            p1: "assets/images/wi_p1.png",
            p2: "assets/images/wi_p2.png",
          },
          icon: "assets/images/wi_icon.png",
          skill: {
            ko: "ì‚¬ë‹¤ë¦¬ ê±·ì–´ì°¨ê¸°: ê²Œì„ë‹¹ í•œ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¶”ë¡  ê·œì¹™ë“¤ì„ ì‚¬ìš©í•´ í•˜ë‚˜ì˜ ì •ë¦¬ë¥¼ ë„ì¶œí•˜ê³ , ì‚¬ìš©í•œ ì „ì œë“¤ì¤‘ ê³µë¦¬ì™€ ìŠ¹ë¦¬ ì¡°ê±´ì„ ì œì™¸í•œ ëª…ì œë¥¼ ëª¨ë‘ ì‚­ì œí•©ë‹ˆë‹¤.",
            en: "Kicking Away the Ladder: Once per game, during Thinking Time, you may derive one theorem using inference rules. Then, delete all premises used in the derivation, except for axioms and win conditions.",
          },
        },
        kuhn: {
          id: "kuhn",
          name: { ko: "í† ë§ˆìŠ¤ ì¿¤", en: "Thomas Kuhn" },
          cardText: { ko: "ì¿¤ì€", en: "Kuhn" },
          image: {
            p1: "assets/images/ku_p1.png",
            p2: "assets/images/ku_p2.png",
          },
          icon: "assets/images/ku_icon.png",
          skill: {
            ko: "íŒ¨ëŸ¬ë‹¤ì„ ì „í™˜: ê²Œì„ë‹¹ í•œ ë²ˆ, í”Œë ˆì´ì–´ë“¤ì´ ì¹´ë“œë¥¼ ë†“ì•„ ìƒì„±í•œ ì°¸ ëª…ì œê°€ 15ê°œ ì´ìƒì¼ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‚¬ìœ ì‹œê°„ì— 'ëª¨ë“  AëŠ” ì„ í•˜ë‹¤/ì•…í•˜ë‹¤' í˜¹ì€ 'ëª¨ë“  AëŠ” ì§€í˜œë¡­ë‹¤/ì–´ë¦¬ì„ë‹¤' ëª…ì œ í•˜ë‚˜ì˜ ìˆ ì–´ë¥¼ ë°˜ëŒ€ë¡œ ë°”ê¾¸ê³ , ê·¸ ëª…ì œì™€ ëª¨ìˆœë˜ëŠ” ëª…ì œë¥¼ ëª¨ë‘ ì‚­ì œí•©ë‹ˆë‹¤.",
            en: "Paradigm Shift: Once per game, when 15 or more true propositions have been created by players, during Thinking Time, you may take a universal proposition like 'Every A is good' or 'Every A is wise', change its predicate to the opposite (e.g., 'is evil' or 'is foolish'), and then delete all propositions that contradict this new paradigm.",
          },
        },
        derrida: {
          id: "derrida",
          name: { ko: "ìí¬ ë°ë¦¬ë‹¤", en: "Jacques Derrida" },
          cardText: { ko: "ë°ë¦¬ë‹¤ëŠ”", en: "Derrida" },
          image: {
            p1: "assets/images/der_p1.png",
            p2: "assets/images/der_p2.png",
          },
          icon: "assets/images/der_icon.png",
          skill: {
            ko: "í•´ì²´: ê²Œì„ë‹¹ í•œ ë²ˆ, ì‚¬ìœ  ì‹œê°„ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³µë¦¬ì™€ ìŠ¹ë¦¬ì¡°ê±´ì´ ì•„ë‹ˆë©°, ì—°ê²°ì‚¬ë¡œ ì´ì–´ì§„ ëª…ì œ í•˜ë‚˜ë¥¼ ëª¨ìˆœì´ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ ìµœì†Œë‹¨ìœ„ ëª…ì œ ë‘ ê°œë¡œ ë¶„í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            en: "Deconstruction: Once per game, during Thinking Time, you may choose one non-axiom, non-victory-condition proposition connected by a logical operator, and decompose it into two atomic propositions, as long as no contradiction aeises.",
          },
        },
      };

      const PUZZLES = {
        1: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤",
              "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤ ê·¸ë¦¬ê³  í”Œë¼í†¤ì€ ë¬¼ê³ ê¸°ì´ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤",
            ],
            en: [
              "(Some dog is evil) then (Socrates is wise)",
              "(Socrates is a dog) and (Plato is a fish)",
              "(Some fish is foolish) then (Some dog is wise)",
              "Every dog is foolish",
            ],
          },
        },
        2: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤",
              "ì–´ë–¤ ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤",
            ],
            en: [
              "(Some dog is wise) then (Socrates is good)",
              "(Some dog is foolish) then (Socrates is good)",
            ],
          },
        },
        3: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "ëª¨ë“  ìƒˆëŠ” ê°œì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ë¬¼ê³ ê¸°ì´ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤",
              "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìƒˆì´ë‹¤ ë˜ëŠ” ì–´ë–¤ ê°œëŠ” ì•…í•˜ë‹¤",
            ],
            en: [
              "Every bird is a dog",
              "Every dog is a fish",
              "Every fish is good",
              "(Socrates is a bird) or (Some dog is evil)",
            ],
          },
        },
        4: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ê°œì´ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤",
              "í”Œë¼í†¤ì€ ì•…í•˜ë‹¤",
            ],
            en: [
              "(Socrates is evil) then (Plato is a dog)",
              "Every dog is good",
              "Plato is evil",
            ],
          },
        },
        5: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: ["í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ë˜ëŠ” í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤"],
            en: ["(Plato is wise) or (Plato is wise)"],
          },
        },
        6: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "í”Œë¼í†¤ì€ ìƒˆì´ë‹¤",
              "í”Œë¼í†¤ì€ ê°œì´ë‹¤",
              "í”Œë¼í†¤ì€ ë¬¼ê³ ê¸°ì´ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤",
              "ëª¨ë“  ìƒˆëŠ” ì–´ë¦¬ì„ë‹¤ ë˜ëŠ” ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤ ë˜ëŠ” ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì§€í˜œë¡­ë‹¤",
              "ëª¨ë“  ë¬¼ê³ ê¸°ëŠ” ì–´ë¦¬ì„ë‹¤ ë˜ëŠ” ëª¨ë“  ìƒˆëŠ” ì§€í˜œë¡­ë‹¤",
            ],
            en: [
              "Plato is a bird",
              "Plato is a dog",
              "Plato is a fish",
              "(Every bird is foolish) then (Every dog is wise)",
              "(Every dog is foolish) then (Every fish is wise)",
              "(Every fish is foolish) then (Every bird is wise)",
              "(Every bird is foolish) or (Every dog is wise)",
              "(Every dog is foolish) or (Every fish is wise)",
              "(Every fish is foolish) or (Every bird is wise)",
            ],
          },
        },
        7: {
          goalDescription: {
            ko: "ë‹¹ì‹ ì˜ ìŠ¹ë¦¬ <strong>[ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤]</strong>ë‚˜ ìƒëŒ€ì˜ íŒ¨ë°° <strong>[í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ëŠ” ê±°ì§“ì´ë‹¤]</strong>ë¥¼ ì¦ëª…í•˜ì„¸ìš”.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ë˜ëŠ” ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤",
              "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤",
              "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ë¬¼ê³ ê¸°ì´ë‹¤",
              "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
            ],
            en: [
              "(Plato is wise) or (Every dog is foolish)",
              "(Every dog is wise) is false then (Socrates is good)",
              "(Plato is wise) then (Socrates is a fish)",
              "Some fish is evil is false",
            ],
          },
        },
      };

      // --- GLOBAL STATE ---

      document
        .getElementById("vs-ai-test-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return;
          isTestMode = true;
          audioManager.fadeOut("main-menu");
          audioManager.play("character-select");
          startCharacterSelection("AI");
        });
      let bgmVolume = 0.4; // ë°°ê²½ìŒì•… ê¸°ë³¸ ë³¼ë¥¨ 40%
      let sfxVolume = 0.6; // íš¨ê³¼ìŒ ê¸°ë³¸ ë³¼ë¥¨ 100%
      let currentLang;
      let currentPuzzleLevel = null;
      let isPlayerAI = { A: false, B: false };
      let fullDeck, cardTypeOrder;
      let playerA_Hand = [],
        playerB_Hand = [];
      let truePropositions = [];
      let parsedAxioms = [];
      let currentProposition = [];
      let currentPlayer = "A";
      let propositionStarter = "A";
      let gameIsOver = false;
      let currentRound = 1;
      let isThinkingTime = false;
      let lastPropositionMaker = null;
      let internalTruthSet = [];
      let derivedPropositionsInModal = [];
      let currentAssumption = null;
      let lastCardPlayer = null;
      let cardsPlayedThisTurn = { A: 0, B: 0 };
      let eurekaUsedInRound = { A: false, B: false };
      let thinkingTimeTurn = null;
      let abilityUsedState = {};
      let socratesDisabledProps = [];
      let kantProposition = [];

      const audioContext = new (window.AudioContext ||
        window.webkitAudioContext)();

      // ëª¨ë“  ì˜¤ë””ì˜¤ íŠ¸ë™ì„ ê´€ë¦¬í•˜ëŠ” ì¤‘ì•™ ê´€ë¦¬ì
      const audioManager = {
        tracks: {
          bgm: {
            // 1. BGMì„ ìœ„í•œ í•˜ìœ„ ê°ì²´ë¡œ ë¬¶ìŠµë‹ˆë‹¤.
            "main-menu": {
              url: "assets/sounds/main_theme.flac",
              loopStart: 0.0,
              loopEnd: 0.0,
            },
            "character-select": {
              url: "assets/sounds/char_select_theme.flac",
              loopStart: 0.333,
              loopEnd: 32.333,
            },
            "game-play": {
              url: "assets/sounds/game_music.wav",
              loopStart: 0.0,
              loopEnd: 61.091,
            },
            "thinking-time": {
              url: "assets/sounds/thinking_music.wav",
              loopStart: 0.0,
              loopEnd: 0.0,
            },
            "puzzle-theme": {
              url: "assets/sounds/puzzle.wav",
              loopStart: 0.0,
              loopEnd: 0.0,
            },
          },
          sfx: {
            // 2. SFXë¥¼ ìœ„í•œ í•˜ìœ„ ê°ì²´ë¥¼ ìƒˆë¡œ ì¶”ê°€í•©ë‹ˆë‹¤.
            hover: "assets/sounds/hover.ogg",
            playCard: "assets/sounds/play_card.flac",
            complete: "assets/sounds/complete.ogg",
            pop: "assets/sounds/pop.ogg",
            undo: "assets/sounds/undo.flac",
            end: "assets/sounds/end.wav",
            eureka: "assets/sounds/eureka.wav",
            victory: "assets/sounds/victory.wav",
          },
        },
        buffers: {},
        sourceNodes: {},
        gainNodes: {},
        sfxGainNode: null, // 3. SFX ì „ìš© ë³¼ë¥¨ ì¡°ì ˆ ë…¸ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

        async init() {
          // BGMìš© Gain Node ìƒì„±
          for (const key in this.tracks.bgm) {
            const gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            this.gainNodes[key] = gainNode;
          }
          // SFXìš© Gain Node ìƒì„±
          this.sfxGainNode = audioContext.createGain();
          this.sfxGainNode.connect(audioContext.destination);

          // ëª¨ë“  BGMê³¼ SFX ë¡œë“œ
          const loadPromises = [];
          for (const key in this.tracks.bgm) {
            loadPromises.push(this._loadTrack(key, this.tracks.bgm[key].url));
          }
          for (const key in this.tracks.sfx) {
            loadPromises.push(this._loadTrack(key, this.tracks.sfx[key]));
          }
          await Promise.all(loadPromises); // ëª¨ë“  ë¡œë”©ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
          console.log("ëª¨ë“  ì˜¤ë””ì˜¤ íŠ¸ë™ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.");
        },
        async _loadTrack(key, url) {
          // key ì¸ì ì¶”ê°€
          try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            this.buffers[key] = await audioContext.decodeAudioData(arrayBuffer); // keyë¥¼ ì‚¬ìš©í•´ ë²„í¼ì— ì €ì¥
          } catch (error) {
            console.error(`ì˜¤ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨: ${url}`, error);
          }
        },

        play(key, volume = 0.5) {
          if (audioContext.state === "suspended") {
            audioContext.resume();
          }

          this.stop(key); // ê¸°ì¡´ì— ì¬ìƒì¤‘ì¸ ê°™ì€ íŠ¸ë™ì´ ìˆìœ¼ë©´ ì¤‘ì§€

          const buffer = this.buffers[key];
          if (!buffer) return;

          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.loop = true;
          const trackData = this.tracks.bgm[key];
          source.loopStart = trackData.loopStart || 0.0;

          // loopEnd ê°’ì´ ìœ íš¨í•˜ê²Œ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ê·¸ ê°’ì„ ì‚¬ìš©í•˜ê³ , ì•„ë‹ˆë©´ íŒŒì¼ ì „ì²´ ê¸¸ì´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
          if (trackData.loopEnd && trackData.loopEnd > 0) {
            source.loopEnd = trackData.loopEnd;
          } else {
            source.loopEnd = buffer.duration; // buffer.durationì´ íŒŒì¼ì˜ ì „ì²´ ê¸¸ì´ì…ë‹ˆë‹¤.
          }

          const gainNode = this.gainNodes[key];
          source.connect(gainNode);

          // í˜ì´ë“œ ì¸ íš¨ê³¼
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(
            bgmVolume, // ê¸°ì¡´: volume
            audioContext.currentTime + 1.5
          );

          source.start(0);
          this.sourceNodes[key] = source;
        },

        fadeOut(key, duration = 1.5) {
          const gainNode = this.gainNodes[key];
          const sourceNode = this.sourceNodes[key];

          // gainNodeì™€ í˜„ì¬ ì¬ìƒ ì¤‘ì¸ sourceNodeê°€ ëª¨ë‘ ìˆì„ ë•Œë§Œ ì‹¤í–‰
          if (gainNode && sourceNode) {
            gainNode.gain.linearRampToValueAtTime(
              0.001,
              audioContext.currentTime + duration
            );

            // ë³¼ë¥¨ì´ ëª¨ë‘ ì¤„ì–´ë“œëŠ” ì‹œê°„(duration)ì´ ì§€ë‚œ í›„ì— stop í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
            setTimeout(() => {
              this.stop(key);
            }, duration * 1000); // durationì€ ì´ˆ(sec) ë‹¨ìœ„ì´ë¯€ë¡œ 1000ì„ ê³±í•´ msë¡œ ë³€í™˜
          }
        },

        setVolume(volume) {
          // gainNodes ê°ì²´ì— ìˆëŠ” ëª¨ë“  ê²Œì¸ ë…¸ë“œë¥¼ ìˆœíšŒ
          for (const key in this.gainNodes) {
            const gainNode = this.gainNodes[key];
            if (gainNode) {
              // linearRampToValueAtTimeì„ ì‚¬ìš©í•´ ë¶€ë“œëŸ½ê²Œ ë³¼ë¥¨ì„ ë³€ê²½
              gainNode.gain.linearRampToValueAtTime(
                volume,
                audioContext.currentTime + 0.1
              );
            }
          }
        },

        stop(key) {
          const source = this.sourceNodes[key];
          if (source) {
            try {
              source.stop(0);
            } catch (e) {}
            delete this.sourceNodes[key];
          }
        },

        stopAll() {
          for (const key in this.sourceNodes) {
            this.stop(key);
          }
        },
        /**
         * ë¯¸ë¦¬ ë¡œë“œëœ íš¨ê³¼ìŒì„ ì¬ìƒí•©ë‹ˆë‹¤. (Non-looping)
         * @param {string} key - ì¬ìƒí•  íš¨ê³¼ìŒì˜ í‚¤ (ì˜ˆ: "hover", "playCard")
         */
        playSfx(key) {
          if (audioContext.state === "suspended") {
            audioContext.resume();
          }

          const buffer = this.buffers[key];
          if (!buffer || !this.sfxGainNode) return;

          // íš¨ê³¼ìŒì€ ì¬ìƒí•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ì†ŒìŠ¤ ë…¸ë“œë¥¼ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤.
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(this.sfxGainNode);
          source.start(0);
        },

        /**
         * íš¨ê³¼ìŒ ì „ì²´ ë³¼ë¥¨ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.
         * @param {number} volume - 0.0 ~ 1.0 ì‚¬ì´ì˜ ë³¼ë¥¨ ê°’
         */
        setSfxVolume(volume) {
          if (this.sfxGainNode) {
            this.sfxGainNode.gain.linearRampToValueAtTime(
              volume,
              audioContext.currentTime + 0.1
            );
          }
        },
      };

      // ê²Œì„ ì‹œì‘ ì „ ì˜¤ë””ì˜¤ë¥¼ ë¯¸ë¦¬ ë¡œë“œí•˜ê³ , ë¡œë”©ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.
      (async () => {
        try {
          await audioManager.init();
          // ì˜¤ë””ì˜¤ ë¡œë”©ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œëœ í›„, ì–¸ì–´ ì„ íƒ ë²„íŠ¼ì„ í™œì„±í™”í•˜ê±°ë‚˜
          // ë‹¤ìŒ ë¡œì§ì„ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” íŠ¹ë³„í•œ ì¶”ê°€ ë™ì‘ì€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
          console.log("Audio assets successfully preloaded.");
        } catch (error) {
          console.error("Failed to preload audio assets:", error);
          // ì˜¤ë””ì˜¤ ë¡œë”© ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ì„ ë„ìš°ëŠ” ë“±ì˜ ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        }
      })();

      let currentAxioms = []; // í˜„ì¬ ê²Œì„ì˜ ê³µë¦¬ë¥¼ ì €ì¥í•  ë°°ì—´

      // --- AI Mode State ---
      let gameMode = null;
      let playerCharacter = null;
      let aiPlayer = null;
      let activeGambitPlan = null;

      function getLastName(fullName) {
        if (!fullName) return "";
        const parts = fullName.split(" ");
        return parts[parts.length - 1];
      }

      // --- TUTORIAL STATE ---
      let inTutorialMode = false;
      let inPuzzleMode = false;
      let tutorialStep = 0;
      let tutorialSubStep = 0;
      let temporaryListener = null;

      let selectionMode = null;
      let characterSelectionTurn = null;
      let tempSelections = { p1: null, p2: null };
      let humanPlayerId = null;

      let aiTimeoutId = null;

      function parseTokensToProposition(tokens) {
        if (!tokens || tokens.length === 0) return null;
        if (tokens[0] === "(" && tokens[tokens.length - 1] === ")") {
          let balance = 0;
          let isOuterParens = true;
          for (let i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] === "(") balance++;
            else if (tokens[i] === ")") balance--;
            if (balance === 0) {
              isOuterParens = false;
              break;
            }
          }
          if (isOuterParens) {
            return parseTokensToProposition(tokens.slice(1, -1));
          }
        }
        let balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.if) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conditional", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.or) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "disjunction", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.and) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conjunction", left: left, right: right };
          }
        }
        if (
          tokens.length > 1 &&
          tokens[tokens.length - 1] === currentLang.keywords.not
        ) {
          const prop = parseTokensToProposition(tokens.slice(0, -1));
          if (!prop) return null;
          return { type: "negation", proposition: prop };
        }
        const cardInfo = tokens.map((t) => fullDeck.find((c) => c.text === t));
        if (cardInfo.some((c) => !c)) {
          const [properNoun, quantifier, entity, predicate] =
            currentLang.cardTypes;
          const types = tokens.map((t) => {
            const card = fullDeck.find((c) => c.text === t);
            return card ? card.type : null;
          });
          if (types.length === 2 && types[0] === properNoun) {
            return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
          }
          if (types.length === 3 && types[0] === quantifier) {
            return {
              type:
                tokens[0] === currentLang.keywords.universal_q
                  ? "universal"
                  : "existential",
              entity: tokens[1],
              predicate: tokens[2],
            };
          }
          return null;
        }
        const types = cardInfo.map((c) => c.type);
        const [properNoun, quantifier, entity, predicate] =
          currentLang.cardTypes;
        if (types.length === 2 && types[0] === properNoun) {
          return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
        }
        if (types.length === 3 && types[0] === quantifier) {
          return {
            type:
              tokens[0] === currentLang.keywords.universal_q
                ? "universal"
                : "existential",
            entity: tokens[1],
            predicate: tokens[2],
          };
        }
        return null;
      }

      function parsePropositionFromString(str) {
        const allKeywords = [...fullDeck.map((c) => c.text), "(", ")"].sort(
          (a, b) => b.length - a.length
        );
        let tempStr = str.trim();
        const tokens = [];
        while (tempStr.length > 0) {
          const foundToken = allKeywords.find((k) => tempStr.startsWith(k));
          if (foundToken) {
            tokens.push(foundToken);
            tempStr = tempStr.substring(foundToken.length).trim();
          } else {
            console.error(
              "Tokenizer failed for string:",
              str,
              "at substring:",
              tempStr
            );
            return null;
          }
        }
        return parseTokensToProposition(tokens);
      }

      function parsePropositionFromCards(propInfoArray) {
        if (!propInfoArray || propInfoArray.length === 0) return null;
        const tokens = propInfoArray.map((info) => info.card.text);
        return parseTokensToProposition(tokens);
      }

      function arePropositionsEqual(prop1, prop2) {
        if (!prop1 || !prop2 || prop1.type !== prop2.type) return false;
        switch (prop1.type) {
          case "atomic":
            return (
              prop1.subject === prop2.subject &&
              prop1.predicate === prop2.predicate
            );
          case "universal":
          case "existential":
            return (
              prop1.entity === prop2.entity &&
              prop1.predicate === prop2.predicate
            );
          case "negation":
            return arePropositionsEqual(prop1.proposition, prop2.proposition);
          case "conjunction":
          case "disjunction":
          case "conditional":
            return (
              arePropositionsEqual(prop1.left, prop2.left) &&
              arePropositionsEqual(prop1.right, prop2.right)
            );
          default:
            return false;
        }
      }

      function propositionToText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation":
            return `~(${propositionToText(prop.proposition)})`;
          case "conjunction":
            return `(${propositionToText(prop.left)}) âˆ§ (${propositionToText(
              prop.right
            )})`;
          case "disjunction":
            return `(${propositionToText(prop.left)}) âˆ¨ (${propositionToText(
              prop.right
            )})`;
          case "conditional":
            return `(${propositionToText(prop.left)}) â†’ (${propositionToText(
              prop.right
            )})`;
          default:
            return "Unknown Proposition";
        }
      }

      function propositionToNaturalText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation": {
            const innerProp = prop.proposition;
            const innerText = propositionToNaturalText(innerProp);
            const notKeyword = `<span class="op-not">${currentLang.keywords.not}</span>`;

            // í•µì‹¬ ìˆ˜ì • 1: ë¶€ì • ëŒ€ìƒì´ ë‹¨ì¼ ëª…ì œ(atomic, universal, existential)ì¼ ë•Œë§Œ ê´„í˜¸ë¡œ ê°ìŒ‰ë‹ˆë‹¤.
            if (
              innerProp.type === "atomic" ||
              innerProp.type === "universal" ||
              innerProp.type === "existential"
            ) {
              return `(${innerText}) ${notKeyword}`;
            }

            // ê·¸ ì™¸ (ì´ë¯¸ ê´„í˜¸ê°€ ìˆëŠ” ë³µí•© ëª…ì œë‚˜ ë˜ ë‹¤ë¥¸ ë¶€ì •ë¬¸)ëŠ” ê·¸ëŒ€ë¡œ í…ìŠ¤íŠ¸ë¥¼ ì´ì–´ë¶™ì…ë‹ˆë‹¤.
            return `${innerText} ${notKeyword}`;
          }
          case "conjunction": {
            const leftProp = prop.left;
            const rightProp = prop.right;
            let leftText = propositionToNaturalText(leftProp);
            let rightText = propositionToNaturalText(rightProp);

            // í•µì‹¬ ìˆ˜ì • 2: ìì‹ ë…¸ë“œê°€ ë¶€ì •ë¬¸ì´ ì•„ë‹ ê²½ìš°ì—ë§Œ ê´„í˜¸ë¡œ ê°ìŒ‰ë‹ˆë‹¤.
            if (leftProp.type !== "negation") {
              leftText = `(${leftText})`;
            }
            if (rightProp.type !== "negation") {
              rightText = `(${rightText})`;
            }

            const andKeyword = `<span class="op-and">${currentLang.keywords.and}</span>`;
            return `${leftText} ${andKeyword} ${rightText}`;
          }
          case "disjunction": {
            const leftProp = prop.left;
            const rightProp = prop.right;
            let leftText = propositionToNaturalText(leftProp);
            let rightText = propositionToNaturalText(rightProp);

            // í•µì‹¬ ìˆ˜ì • 2: ìì‹ ë…¸ë“œê°€ ë¶€ì •ë¬¸ì´ ì•„ë‹ ê²½ìš°ì—ë§Œ ê´„í˜¸ë¡œ ê°ìŒ‰ë‹ˆë‹¤.
            if (leftProp.type !== "negation") {
              leftText = `(${leftText})`;
            }
            if (rightProp.type !== "negation") {
              rightText = `(${rightText})`;
            }

            const orKeyword = `<span class="op-or">${currentLang.keywords.or}</span>`;
            return `${leftText} ${orKeyword} ${rightText}`;
          }
          case "conditional": {
            const leftProp = prop.left;
            const rightProp = prop.right;
            let leftText = propositionToNaturalText(leftProp);
            let rightText = propositionToNaturalText(rightProp);

            // í•µì‹¬ ìˆ˜ì • 2: ìì‹ ë…¸ë“œê°€ ë¶€ì •ë¬¸ì´ ì•„ë‹ ê²½ìš°ì—ë§Œ ê´„í˜¸ë¡œ ê°ìŒ‰ë‹ˆë‹¤.
            if (leftProp.type !== "negation") {
              leftText = `(${leftText})`;
            }
            if (rightProp.type !== "negation") {
              rightText = `(${rightText})`;
            }

            const ifKeyword = `<span class="op-if">${currentLang.keywords.if}</span>`;
            return `${leftText} ${ifKeyword} ${rightText}`;
          }
          default:
            return "Unknown Proposition";
        }
      }

      function propositionToPlainText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;

          case "negation": {
            const innerProp = prop.proposition;
            const innerText = propositionToPlainText(innerProp); // ì¬ê·€ í˜¸ì¶œ ì‹œì—ë„ ìƒˆ í•¨ìˆ˜ ì‚¬ìš©
            const notKeyword = currentLang.keywords.not;
            if (
              innerProp.type === "conjunction" ||
              innerProp.type === "disjunction" ||
              innerProp.type === "conditional"
            ) {
              return `(${innerText}) ${notKeyword}`;
            }
            return `${innerText} ${notKeyword}`;
          }

          case "conjunction": {
            let leftText;
            if (prop.left.type === "negation") {
              const innerText = propositionToPlainText(prop.left.proposition);
              leftText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              leftText = `(${propositionToPlainText(prop.left)})`;
            }

            let rightText;
            if (prop.right.type === "negation") {
              const innerText = propositionToPlainText(prop.right.proposition);
              rightText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              rightText = `(${propositionToPlainText(prop.right)})`;
            }

            const andKeyword = currentLang.keywords.and;
            return `${leftText} ${andKeyword} ${rightText}`;
          }

          case "disjunction": {
            let leftText;
            if (prop.left.type === "negation") {
              const innerText = propositionToPlainText(prop.left.proposition);
              leftText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              leftText = `(${propositionToPlainText(prop.left)})`;
            }

            let rightText;
            if (prop.right.type === "negation") {
              const innerText = propositionToPlainText(prop.right.proposition);
              rightText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              rightText = `(${propositionToPlainText(prop.right)})`;
            }

            const orKeyword = currentLang.keywords.or;
            return `${leftText} ${orKeyword} ${rightText}`;
          }

          case "conditional": {
            let leftText;
            if (prop.left.type === "negation") {
              const innerText = propositionToPlainText(prop.left.proposition);
              leftText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              leftText = `(${propositionToPlainText(prop.left)})`;
            }

            let rightText;
            if (prop.right.type === "negation") {
              const innerText = propositionToPlainText(prop.right.proposition);
              rightText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              rightText = `(${propositionToPlainText(prop.right)})`;
            }

            const ifKeyword = currentLang.keywords.if;
            return `${leftText} ${ifKeyword} ${rightText}`;
          }

          default:
            return "Unknown Proposition";
        }
      }

      function initializeGame(lang) {
        currentLang = TEXTS[lang];
        document.documentElement.lang = currentLang.langCode;
        document.title = currentLang.ui.title;

        fullDeck = currentLang.cards;
        cardTypeOrder = currentLang.cardTypes;

        document.getElementById("language-modal").classList.remove("visible");
        setupUI();
        setupModeDescriptionHovers();
        loadSettings();
        showMainMenu();
        addGlobalSoundEvents();
      }

      function showMainMenu() {
        // ìƒˆë¡œìš´ ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •
        audioManager.stopAll();
        audioManager.play("main-menu"); // ë³¼ë¥¨ 60%ë¡œ ë©”ì¸ ë©”ë‰´ ìŒì•… ì¬ìƒ

        document
          .getElementById("thinking-time-controls")
          .classList.add("hidden");
        document
          .getElementById("character-select-indicator")
          .classList.add("hidden");
        document.getElementById("container").classList.add("ready");
        document.querySelector(".main-center-bg").classList.remove("hidden");
        document.getElementById("credits-btn").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
      }
      function setupModeDescriptionHovers() {
        const descriptionBox = document.getElementById("mode-description");
        if (!descriptionBox) return;

        const buttonsToDescribe = [
          { id: "vs-player-btn", key: "vsPlayerDesc" },
          { id: "vs-ai-btn", key: "vsAIDesc" },
          { id: "tutorial-btn", key: "tutorialDesc" },
          { id: "puzzle-mode-btn", key: "puzzleDesc" },
        ];

        buttonsToDescribe.forEach((buttonInfo) => {
          const buttonEl = document.getElementById(buttonInfo.id);
          if (buttonEl) {
            buttonEl.addEventListener("mouseenter", (e) => {
              // 1. í˜„ì¬ ì–¸ì–´ì— ë§ëŠ” ì„¤ëª… í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì™€ì„œ ë‚´ìš© ë³€ê²½
              const descText = currentLang.ui[buttonInfo.key];
              descriptionBox.innerHTML = descText;

              // 2. ì„¤ëª… ë°•ìŠ¤ì˜ Yì¶• ìœ„ì¹˜ë¥¼ í˜„ì¬ ë§ˆìš°ìŠ¤ê°€ ì˜¬ë¼ê°„ ë²„íŠ¼ì˜ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
              const buttonCenterY =
                e.target.offsetTop + e.target.offsetHeight / 2;
              descriptionBox.style.top = `${buttonCenterY}px`;

              // 3. ì„¤ëª… ë°•ìŠ¤ë¥¼ ë¶€ë“œëŸ½ê²Œ í‘œì‹œ
              descriptionBox.style.opacity = "1";
              descriptionBox.style.visibility = "visible";
            });

            buttonEl.addEventListener("mouseleave", () => {
              // ë§ˆìš°ìŠ¤ê°€ ë²—ì–´ë‚˜ë©´ ì„¤ëª… ë°•ìŠ¤ë¥¼ ë‹¤ì‹œ ìˆ¨ê¹€
              descriptionBox.style.opacity = "0";
              descriptionBox.style.visibility = "hidden";
            });
          }
        });
      }
      function setupUI() {
        document.getElementById("main-menu-btn").textContent =
          currentLang.langCode === "ko" ? "ë©”ì¸ìœ¼ë¡œ" : "Main Menu";

        document.getElementById("main-title").textContent =
          currentLang.ui.title;
        document.getElementById("new-game-btn").textContent =
          currentLang.ui.newGameButton;
        document.getElementById("vs-ai-btn").textContent =
          currentLang.ui.vsAIButton;
        document.getElementById("vs-player-btn").textContent =
          currentLang.ui.vsPlayerButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;
        document.getElementById("exit-game-btn").textContent =
          currentLang.ui.exitGameButton;
        document.getElementById("vs-ai-battle-btn").textContent =
          currentLang.ui.vsAIBattleButton;
        document.getElementById(
          "player-a-title"
        ).innerHTML = `${currentLang.ui.playerAName} - ${currentLang.ui.playerAColor}`;
        document.getElementById(
          "player-b-title"
        ).innerHTML = `${currentLang.ui.playerBName} - ${currentLang.ui.playerBColor}`;
        document.getElementById("eureka-a").textContent =
          currentLang.ui.eurekaButton;
        document.getElementById("eureka-b").textContent =
          currentLang.ui.eurekaButton;
        document
          .getElementById("ability-a")
          .addEventListener("click", () => activateAbility("A"));
        document
          .getElementById("ability-b")
          .addEventListener("click", () => activateAbility("B"));
        document.getElementById("current-proposition-title").textContent =
          currentLang.ui.currentPropositionTitle;
        document.getElementById("complete-btn").textContent =
          currentLang.ui.completeButton;
        document.getElementById("undo-btn").textContent =
          currentLang.ui.undoButton;
        document.getElementById("end-turn-btn").textContent =
          currentLang.ui.endTurnButton;
        document.getElementById("true-propositions-title").textContent =
          currentLang.ui.truePropositionsTitle;
        document.getElementById("thinking-time-title").textContent =
          currentLang.ui.thinkingTimeTitle;
        document.getElementById("thinking-time-desc").innerHTML =
          currentLang.ui.thinkingTimeDesc;
        document.getElementById("fullscreen-btn").textContent =
          currentLang.ui.fullscreenButton;
        document.getElementById("settings-btn").textContent =
          currentLang.ui.settingsButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;
        document.getElementById("tutorial-puzzle-btn").textContent =
          currentLang.ui.tutorialPuzzleButton;

        document.getElementById("puzzle-mode-btn").textContent =
          currentLang.ui.puzzleButton;
        document.getElementById("puzzle-modal-title").textContent =
          currentLang.modals.puzzleTitle;

        document.getElementById("tutorial-modal-title").textContent =
          currentLang.modals.tutorialTitle;
        document.getElementById("alert-ok-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("credits-btn").textContent =
          currentLang.ui.creditsButton;
        document.getElementById("credits-title").textContent =
          currentLang.modals.creditsTitle;
        document.getElementById("prompt-cancel-btn").textContent =
          currentLang.ui.cancelButton;
        document.getElementById("prompt-confirm-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("prompt-input").placeholder =
          currentLang.modals.promptInputPlaceholder;

        document.getElementById("p1-skill-title").textContent =
          currentLang.ui.skillTitle;
        document.getElementById("p2-skill-title").textContent =
          currentLang.ui.skillTitle;

        document.getElementById("premise-selection-title").textContent =
          currentLang.modals.premiseSelectionTitle;
        document.getElementById("apply-rule-btn").textContent =
          currentLang.modals.applyRuleButton;
        document.getElementById("add-assumption-btn").textContent =
          currentLang.modals.addAssumptionButton;
        document.getElementById("cancel-assumption-btn").textContent =
          currentLang.ui.cancelAssumptionButton;

        document.getElementById("settings-title").textContent =
          currentLang.ui.settingsTitle;
        document.getElementById("bgm-label").textContent =
          currentLang.ui.bgmLabel;
        document.getElementById("sfx-label").textContent =
          currentLang.ui.sfxLabel;

        const select = document.getElementById("inference-rule-select");
        select.innerHTML = `
                  <optgroup label="${currentLang.inferenceRules.basic}">
                      <option value="modusPonens">${currentLang.inferenceRules.modusPonens}</option>
                      <option value="modusTollens">${currentLang.inferenceRules.modusTollens}</option>
                      <option value="hypotheticalSyllogism">${currentLang.inferenceRules.hypotheticalSyllogism}</option>
                      <option value="disjunctiveSyllogism">${currentLang.inferenceRules.disjunctiveSyllogism}</option>
                      <option value="universalApplication">${currentLang.inferenceRules.universalApplication}</option>
                      <option value="existentialInstantiation">${currentLang.inferenceRules.existentialInstantiation}</option>
                      <option value="conjunctionElimination">${currentLang.inferenceRules.conjunctionElimination}</option>
                      <option value="doubleNegationElimination">${currentLang.inferenceRules.doubleNegationElimination}</option>
                  </optgroup>
                  <optgroup label="${currentLang.inferenceRules.assumptionBased}">
                      <option value="conditionalIntroduction" style="color:#27ae60; font-weight:normal;">${currentLang.inferenceRules.conditionalIntroduction}</option>
                      <option value="reductioAdAbsurdum" style="color:#c0392b; font-weight:normal;">${currentLang.inferenceRules.reductioAdAbsurdum}</option>
                  </optgroup>
                  <optgroup label="${currentLang.inferenceRules.advanced}">
                      <option value="proofByCases" style="color:#2980b9; font-weight:normal;">${currentLang.inferenceRules.proofByCases}</option>
                  </optgroup>
              `;
      }
      document
        .getElementById("vs-ai-battle-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return;
          gameMode = "AI_VS_AI";
          audioManager.fadeOut("main-menu");
          audioManager.play("character-select");
          startCharacterSelection(gameMode);
        });

      document.getElementById("exit-game-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        showConfirm(currentLang.alerts.confirmExit, () => {
          // 'ì˜ˆ'ë¥¼ ëˆŒë €ì„ ë•Œì˜ ë™ì‘
          window.close();
        });
      });

      function generateAxioms(
        subjectA,
        subjectB,
        langData,
        isMarxInGame = false
      ) {
        const templates = langData.axiom_templates;
        const axiomGroups = {
          identity: [...templates.identity],
          subjectOpposition: [],
          quantifierOpposition: [],
        };

        // ë§ˆë¥´í¬ìŠ¤ ì •ì²´ì„± ê³µë¦¬ ì¶”ê°€
        if (isMarxInGame) {
          if (langData.langCode === "ko") {
            axiomGroups.identity.push("ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ë¸Œë£¨ì£¼ì•„ì´ë‹¤");
            axiomGroups.identity.push("ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ë¸Œë£¨ì£¼ì•„ì´ë‹¤");
          } else {
            axiomGroups.identity.push("Some Bourgeois is a Bourgeois");
            axiomGroups.identity.push("Every Bourgeois is a Bourgeois");
          }
        }

        // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê³µë¦¬ë“¤
        templates.subject_good_evil.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectA)
          );
        });
        templates.subject_wise_foolish.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectA)
          );
        });
        templates.subject_good_evil.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectB)
          );
        });
        templates.subject_wise_foolish.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectB)
          );
        });

        // ì–‘í™”ì‚¬ë³„ ì†ì„± ëŒ€ë¦½ ê³µë¦¬ë“¤
        axiomGroups.quantifierOpposition.push(
          ...templates.bird_good_evil_forward
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.bird_good_evil_reverse
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.fish_good_evil_forward
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.fish_good_evil_reverse
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.dog_good_evil_forward
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.dog_good_evil_reverse
        );

        if (isMarxInGame) {
          let marxBourgeoisAxioms = [];
          if (langData.langCode === "ko") {
            marxBourgeoisAxioms = [
              // ì†ì„±ì˜ ëŒ€ë¦½ (ì„ /ì•…)
              "ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì•…í•˜ë‹¤",
              "ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì„ í•˜ë‹¤",
              // ì†ì„±ì˜ ëŒ€ë¦½ (ì§€í˜œ/ì–´ë¦¬ì„ìŒ)
              "ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì–´ë¦¬ì„ë‹¤ ë¼ë©´ ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
              "ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì–´ë¦¬ì„ë‹¤",
              "ì–´ë–¤ ë¸Œë£¨ì£¼ì•„ëŠ” ì–´ë¦¬ì„ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ë¼ë©´ ëª¨ë“  ë¸Œë£¨ì£¼ì•„ëŠ” ì§€í˜œë¡­ë‹¤",
            ];
          } else {
            // langCode === 'en'
            marxBourgeoisAxioms = [
              // Opposition of Predicates (good/evil)
              "Every Bourgeois is good then Some Bourgeois is evil is false",
              "Every Bourgeois is evil then Some Bourgeois is good is false",
              "Some Bourgeois is good is false then Every Bourgeois is evil",
              "Some Bourgeois is evil is false then Every Bourgeois is good",
              // Opposition of Predicates (wise/foolish)
              "Every Bourgeois is wise then Some Bourgeois is foolish is false",
              "Every Bourgeois is foolish then Some Bourgeois is wise is false",
              "Some Bourgeois is wise is false then Every Bourgeois is foolish",
              "Some Bourgeois is foolish is false then Every Bourgeois is wise",
            ];
          }
          axiomGroups.quantifierOpposition.push(...marxBourgeoisAxioms);
        }

        // í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ í‰ë©´ì ì¸ ë°°ì—´ë¡œ ë°˜í™˜
        const flatAxioms = [
          ...axiomGroups.identity,
          ...axiomGroups.subjectOpposition,
          ...axiomGroups.quantifierOpposition,
        ];

        // ê·¸ë£¹ ì •ë³´ë¥¼ ì†ì„±ìœ¼ë¡œ ì¶”ê°€
        flatAxioms.groups = axiomGroups;

        return flatAxioms;
      }
      function getTopicParticle(name) {
        const lastChar = name.charCodeAt(name.length - 1);
        if (lastChar < 0xac00 || lastChar > 0xd7a3) {
          return "ëŠ”"; // í•œê¸€ì´ ì•„ë‹ˆë©´ 'ëŠ”'ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë°˜í™˜
        }
        // ë°›ì¹¨ ìœ ë¬´ í™•ì¸: (ê¸€ìì½”ë“œ - 0xAC00) % 28
        const hasJongseong = (lastChar - 0xac00) % 28 !== 0;
        return hasJongseong ? "ì€" : "ëŠ”";
      }

      function setupGame(selectedCharacters, testConfig = null) {
        playerA_Data = PHILOSOPHERS[selectedCharacters.p1];
        playerB_Data = PHILOSOPHERS[selectedCharacters.p2];
        truePropositions = []; // ê²Œì„ ì‹œì‘ ì‹œ ì°¸ ëª…ì œ ëª©ë¡ ì´ˆê¸°í™”

        const p1_id = selectedCharacters.p1;
        const p2_id = selectedCharacters.p2;
        let p1_card_obj, p2_card_obj;
        let subjectA, subjectB;

        subjectA = playerA_Data.cardText[currentLang.langCode];
        subjectB = playerB_Data.cardText[currentLang.langCode];

        // 1. ë¯¸ëŸ¬ì „(ë™ì¼ ì² í•™ì ì„ íƒ) ì²˜ë¦¬
        if (p1_id === p2_id) {
          if (currentLang.langCode === "ko") {
            const fullName = playerA_Data.name.ko;
            const nameParts = fullName.split(" ");
            const lastName = nameParts[nameParts.length - 1];
            const particle = getTopicParticle(lastName);
            subjectA = `ë°±ìƒ‰ ${lastName}${particle}`;
            subjectB = `í‘ìƒ‰ ${lastName}${particle}`;
          } else {
            const fullName = playerA_Data.name.en;
            const nameParts = fullName.split(" ");
            const lastName = nameParts[nameParts.length - 1];
            subjectA = `White ${lastName}`;
            subjectB = `Black ${lastName}`;
          }
          document.getElementById("player-a-title").innerHTML = `âšªï¸ ${
            playerA_Data.name[currentLang.langCode]
          }(ë°±)`;
          document.getElementById("player-b-title").innerHTML = `âš«ï¸ ${
            playerB_Data.name[currentLang.langCode]
          }(í‘)`;
        } else {
          document.getElementById("player-a-title").innerHTML = `âšªï¸ ${
            playerA_Data.name[currentLang.langCode]
          }`;
          document.getElementById("player-b-title").innerHTML = `âš«ï¸ ${
            playerB_Data.name[currentLang.langCode]
          }`;
        }

        const properNounType =
          currentLang.langCode === "ko" ? "ê³ ìœ ëª…ì‚¬" : "Proper Noun";
        p1_card_obj = { type: properNounType, text: subjectA };
        p2_card_obj = { type: properNounType, text: subjectB };

        // 2. ê²Œì„ ë± êµ¬ì„± (ë§ˆë¥´í¬ìŠ¤ ì¹´ë“œ í¬í•¨)
        const masterDeck = currentLang.cards;
        const allPhilosopherCardTexts = Object.values(PHILOSOPHERS).map(
          (p) => p.cardText[currentLang.langCode]
        );
        const baseDeck = masterDeck.filter(
          (card) => !allPhilosopherCardTexts.includes(card.text)
        );

        let currentGameDeck = [...baseDeck, p1_card_obj, p2_card_obj];

        const isMarxInGame = p1_id === "marx" || p2_id === "marx";
        const bourgeoisCard = {
          type: currentLang.langCode === "ko" ? "ê°œì²´" : "Entity",
          text: currentLang.langCode === "ko" ? "ë¸Œë£¨ì£¼ì•„ëŠ”" : "Bourgeois",
        };
        const revolutionSubjectCard = {
          type: currentLang.langCode === "ko" ? "ê³ ìœ ëª…ì‚¬" : "Proper Noun",
          text: currentLang.langCode === "ko" ? "í˜ëª…ì´" : "A revolution",
        };
        const revolutionPredicateCard = {
          type: currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate",
          text: currentLang.langCode === "ko" ? "ì¼ì–´ë‚œë‹¤" : "occurs",
        };

        if (isMarxInGame) {
          currentGameDeck.push(
            bourgeoisCard,
            revolutionSubjectCard,
            revolutionPredicateCard
          );
        }

        fullDeck = currentGameDeck;

        // 3. ì†íŒ¨ ë¶„ë°° (ë§ˆë¥´í¬ìŠ¤ í”Œë ˆì´ ë¶ˆê°€ëŠ¥ ì¹´ë“œ ì œê±° í¬í•¨)
        if (testConfig && testConfig.handA) {
          const handATexts = testConfig.handA.split(",").map((s) => s.trim());
          playerA_Hand = handATexts
            .map((text) => fullDeck.find((c) => c.text === text))
            .filter(Boolean);
        } else {
          const nonPlayerCards = ["ìŠ¹ë¦¬í•œë‹¤", "wins"];
          playerA_Hand = JSON.parse(
            JSON.stringify(
              fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
            )
          );
        }
        if (testConfig && testConfig.handB) {
          const handBTexts = testConfig.handB.split(",").map((s) => s.trim());
          playerB_Hand = handBTexts
            .map((text) => fullDeck.find((c) => c.text === text))
            .filter(Boolean);
        } else {
          const nonPlayerCards = ["ìŠ¹ë¦¬í•œë‹¤", "wins"];
          playerB_Hand = JSON.parse(
            JSON.stringify(
              fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
            )
          );
        }

        if (isMarxInGame) {
          const unplayableCardTexts = [
            revolutionSubjectCard.text,
            revolutionPredicateCard.text,
          ];
          playerA_Hand = playerA_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          );
          playerB_Hand = playerB_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          );
        }

        // 4. ê³µë¦¬ ë° ìŠ¹ë¦¬ ì¡°ê±´ ì„¤ì •
        currentAxioms = generateAxioms(
          subjectA,
          subjectB,
          currentLang,
          isMarxInGame
        );
        parsedAxioms = currentAxioms
          .map((str) => ({
            type: "axiom",
            proposition: parsePropositionFromString(str),
          }))
          .filter((a) => a.proposition);
        internalTruthSet = parsedAxioms.map((a) => a.proposition);

        const { if: ifKeyword, wins, and } = currentLang.keywords;

        const predicateA =
          testConfig?.victoryA ||
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextA = `((${subjectA} ${predicateA}) ${ifKeyword} (${subjectA} ${wins})) ${and} ((${subjectA} ${wins}) ${ifKeyword} (${subjectA} ${predicateA}))`;
        const parsedVictoryA = parsePropositionFromString(victoryTextA);
        truePropositions.push({
          type: "victory",
          text: victoryTextA,
          owner: "A",
          proposition: parsedVictoryA,
          ultimate_target: {
            type: "atomic",
            subject: subjectA,
            predicate: wins,
          },
          core_goal: {
            type: "atomic",
            subject: subjectA,
            predicate: predicateA,
          },
        });
        if (parsedVictoryA) internalTruthSet.push(parsedVictoryA);

        const predicateB =
          testConfig?.victoryB ||
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextB = `((${subjectB} ${predicateB}) ${ifKeyword} (${subjectB} ${wins})) ${and} ((${subjectB} ${wins}) ${ifKeyword} (${subjectB} ${predicateB}))`;
        const parsedVictoryB = parsePropositionFromString(victoryTextB);
        truePropositions.push({
          type: "victory",
          text: victoryTextB,
          owner: "B",
          proposition: parsedVictoryB,
          ultimate_target: {
            type: "atomic",
            subject: subjectB,
            predicate: wins,
          },
          core_goal: {
            type: "atomic",
            subject: subjectB,
            predicate: predicateB,
          },
        });
        if (parsedVictoryB) internalTruthSet.push(parsedVictoryB);

        // 5. ë§ˆë¥´í¬ìŠ¤ íŠ¹ë³„ ìŠ¹ë¦¬ ì¡°ê±´ ì¶”ê°€
        const setupMarxVictory = (player, subject) => {
          const revolutionPropText = `${revolutionSubjectCard.text} ${revolutionPredicateCard.text}`;
          const firstClause = `(${currentLang.keywords.universal_q} ${
            bourgeoisCard.text
          } ${currentLang.langCode === "ko" ? "ì•…í•˜ë‹¤" : "is evil"})`;
          const secondClause = `(${revolutionPropText})`;
          const thirdClause = `(${subject} ${wins})`;
          const marxVictoryString = `(${firstClause} ${ifKeyword} ${secondClause}) ${and} (${secondClause} ${ifKeyword} ${thirdClause})`;
          const parsedMarxVictory =
            parsePropositionFromString(marxVictoryString);

          if (parsedMarxVictory) {
            truePropositions.push({
              owner: player,
              type: "victory",
              source: "marx_revolution",
              text: propositionToPlainText(parsedMarxVictory),
              proposition: parsedMarxVictory,
              ultimate_target: {
                type: "atomic",
                subject: subject,
                predicate: wins,
              },
              core_goal: {
                type: "atomic",
                subject: revolutionSubjectCard.text,
                predicate: revolutionPredicateCard.text,
              },
            });
            internalTruthSet.push(parsedMarxVictory);
          } else {
            console.error(
              "CRITICAL: Failed to parse Marx's victory string.",
              marxVictoryString
            );
          }
        };

        if (p1_id === "marx") {
          setupMarxVictory("A", subjectA);
        }
        if (p2_id === "marx") {
          setupMarxVictory("B", subjectB);
        }

        // 6. í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì´ˆê¸° ì°¸ ëª…ì œ ì²˜ë¦¬
        if (testConfig && testConfig.trueProps) {
          const propStrings = testConfig.trueProps
            .split(";")
            .map((s) => s.trim())
            .filter(Boolean);
          propStrings.forEach((str) => {
            const parsed = parsePropositionFromString(str);
            if (parsed) {
              const verificationResult = verifyAndExpandTruths(
                parsed,
                internalTruthSet
              );
              if (verificationResult.success) {
                truePropositions.push({
                  propId: `prop_${Date.now()}_${Math.random()}`,
                  type: "user-made",
                  round: 0,
                  proposition: parsed,
                  original_cards: [],
                });
                internalTruthSet = verificationResult.expandedSet;
              } else {
                alert(
                  `ì…ë ¥í•œ ì´ˆê¸° ì°¸ ëª…ì œ "${str}"ê°€ ê¸°ì¡´ ê³µë¦¬ ë˜ëŠ” ë‹¤ë¥¸ ëª…ì œì™€ ëª¨ìˆœë˜ì–´ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
                );
              }
            } else {
              alert(`ì…ë ¥í•œ ì´ˆê¸° ì°¸ ëª…ì œ "${str}"ì˜ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.`);
            }
          });
        }

        // 7. ì´ˆìƒí™” ë° ëŠ¥ë ¥ ì‚¬ìš© ìƒíƒœ ì´ˆê¸°í™”
        const portraitA_El = document.getElementById("player-a-portrait");
        if (portraitA_El) {
          portraitA_El.style.backgroundImage = `url('${playerA_Data.image.p1}')`;
        }
        const portraitB_El = document.getElementById("player-b-portrait");
        if (portraitB_El) {
          portraitB_El.style.backgroundImage = `url('${playerB_Data.image.p2}')`;
        }

        abilityUsedState = {};

        // í”Œë ˆì´ì–´ Aì˜ ëŠ¥ë ¥ ìƒíƒœ ì„¤ì • (ì´ë¯¸ ì„ ì–¸ëœ p1_id ë³€ìˆ˜ ì‚¬ìš©)
        if (p1_id === "hume" || p1_id === "socrates") {
          abilityUsedState["A"] = { usedCount: 0, maxUses: 2 };
        } else {
          abilityUsedState["A"] = { used: false };
        }

        // í”Œë ˆì´ì–´ Bì˜ ëŠ¥ë ¥ ìƒíƒœ ì„¤ì • (ì´ë¯¸ ì„ ì–¸ëœ p2_id ë³€ìˆ˜ ì‚¬ìš©)
        if (p2_id === "hume" || p2_id === "socrates") {
          abilityUsedState["B"] = { usedCount: 0, maxUses: 2 };
        } else {
          abilityUsedState["B"] = { used: false };
        }

        render();
        checkNextTurn();
      }

      function resetGame(selectedCharacters, testConfig = null) {
        audioManager.stop("main-menu");
        audioManager.play("game-play");

        // ë§Œì•½ ì„ íƒëœ ìºë¦­í„° ì •ë³´ê°€ ì—†ë‹¤ë©´, ê¸°ë³¸ê°’ìœ¼ë¡œ ì†Œí¬ë¼í…ŒìŠ¤ì™€ í”Œë¼í†¤ì„ ì„¤ì •
        if (!selectedCharacters) {
          selectedCharacters = { p1: "socrates", p2: "plato" };
        }

        clearAllAITimeouts();

        socratesDisabledProps = []; // ì†Œí¬ë¼í…ŒìŠ¤ ëŠ¥ë ¥ìœ¼ë¡œ ë¹„í™œì„±í™”ëœ ëª…ì œ ëª©ë¡ ì´ˆê¸°í™”

        playerA_Hand = [];
        playerB_Hand = [];
        truePropositions = [];
        currentProposition = [];
        currentPlayer = "A";
        gameIsOver = false;
        currentRound = 1;
        isThinkingTime = false;

        eurekaUsedInRound = { A: false, B: false };

        cardsPlayedThisTurn = { A: 0, B: 0 };

        document.getElementById("thinking-time-controls").style.display =
          "none";
        document.getElementById("status").innerHTML = "";

        setupGame(selectedCharacters, testConfig);
      }
      // --- EVENT LISTENERS ---
      document.getElementById("lang-en").addEventListener("click", () => {
        // AudioContextê°€ suspended ìƒíƒœì¼ ê²½ìš° ì¦‰ì‹œ í™œì„±í™”í•©ë‹ˆë‹¤.
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        initializeGame("en");
      });
      document.getElementById("lang-ko").addEventListener("click", () => {
        // AudioContextê°€ suspended ìƒíƒœì¼ ê²½ìš° ì¦‰ì‹œ í™œì„±í™”í•©ë‹ˆë‹¤.
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        initializeGame("ko");
      });
      document.getElementById("new-game-btn").addEventListener("click", () => {
        if (inTutorialMode) return;

        audioManager.fadeOut("game-play");
        audioManager.fadeOut("thinking-time");

        // í˜„ì¬ ê²Œì„ ëª¨ë“œê°€ ì„¤ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
        if (gameMode) {
          clearAllAITimeouts(); // ì§„í–‰ ì¤‘ì¸ AI ë™ì‘ì´ ìˆë‹¤ë©´ ì¤‘ì§€
          // í˜„ì¬ ê²Œì„ ëª¨ë“œë¡œ ìºë¦­í„° ì„ íƒì„ ë‹¤ì‹œ ì‹œì‘
          startCharacterSelection(gameMode);
        } else {
          // í˜¹ì‹œ ëª¨ë“œê°€ ì„¤ì •ë˜ì§€ ì•Šì€ ì˜ˆì™¸ì ì¸ ê²½ìš°, ë©”ì¸ ë©”ë‰´ë¡œ ì´ë™
          showMainMenu();
        }
      });

      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // ìˆ˜ì •ëœ ë¶€ë¶„
        audioManager.fadeOut("main-menu");
        audioManager.play("character-select");
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // ìˆ˜ì •ëœ ë¶€ë¶„
        audioManager.fadeOut("main-menu");
        audioManager.play("character-select");
        startCharacterSelection("AI");
      });

      // NEW Event Listener for the single confirm button
      document
        .getElementById("confirm-selection-btn")
        .addEventListener("click", handleConfirmClick);

      // Keep other event listeners like those for complete-btn, undo-btn, etc. as they are.

      document
        .getElementById("back-to-main-from-char-select-btn")
        .addEventListener("click", goToMainMenu);

      document.getElementById("complete-btn").addEventListener("click", () => {
        if (!inTutorialMode) completeProposition();
      });
      document.getElementById("undo-btn").addEventListener("click", () => {
        if (!inTutorialMode) undoProposition();
      });
      document
        .getElementById("end-turn-btn")
        .addEventListener("click", (event) => {
          // event ê°ì²´ë¥¼ ì¸ìë¡œ ë°›ë„ë¡ ìˆ˜ì •
          if (inTutorialMode) return;

          // ì´ë²¤íŠ¸ê°€ document.bodyë¡œ ì „íŒŒ(ë²„ë¸”ë§)ë˜ëŠ” ê²ƒì„ ë§‰ì•„ ë²”ìš© í´ë¦­ìŒ ì¤‘ë³µ ë°©ì§€
          event.stopPropagation();

          endTurn(); // ê¸°ì¡´ í„´ ì¢…ë£Œ í•¨ìˆ˜ í˜¸ì¶œ
        });
      document.getElementById("eureka-a").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("A");
      });
      document.getElementById("eureka-b").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("B");
      });
      document
        .getElementById("close-eureka-modal-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return;

          // â–¼â–¼â–¼ [ìˆ˜ì •] ì•„ë˜ ë‘ ì¤„ì„ ì¶”ê°€í•˜ì—¬ ëª¨ë‹¬ì˜ ë‚´ë¶€ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. â–¼â–¼â–¼
          derivedPropositionsInModal = [];
          currentAssumption = null;
          // â–²â–²â–² [ìˆ˜ì •] ì½”ë“œ ì¶”ê°€ ë â–²â–²â–²

          if (inPuzzleMode) {
            document.getElementById("eureka-modal").classList.remove("visible");
            document.getElementById("puzzle-goal-box").classList.add("hidden");
            inPuzzleMode = false;
            populatePuzzleLevels();
            document
              .getElementById("puzzle-level-select-modal")
              .classList.add("visible");
            return;
          }

          document.getElementById("eureka-modal").classList.remove("visible");
        });
      document
        .getElementById("close-tutorial-modal-btn")
        .addEventListener("click", () =>
          document.getElementById("tutorial-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-btn")
        .addEventListener("click", () => startTutorial(0)); // Existing tutorial button
      document
        .getElementById("tutorial-puzzle-btn")
        .addEventListener("click", () => startTutorial(8)); // New puzzle button
      document
        .getElementById("apply-rule-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode || tutorialStep === 8) applyRule();
        });
      document
        .getElementById("add-assumption-btn")
        .addEventListener("click", addAssumption);
      document
        .getElementById("cancel-assumption-btn")
        .addEventListener("click", cancelAssumption);
      document
        .getElementById("alert-ok-btn")
        .addEventListener("click", () =>
          document.getElementById("alert-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-next-btn")
        .addEventListener("click", advanceTutorial);

      document
        .getElementById("emergency-exit-tutorial-btn")
        .addEventListener("click", endTutorial);

      document
        .getElementById("puzzle-mode-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return; // íŠœí† ë¦¬ì–¼ ì¤‘ì—ëŠ” ë™ì‘ ì•ˆ í•¨

          audioManager.fadeOut("main-menu"); // ë©”ì¸ ë©”ë‰´ ìŒì•… í˜ì´ë“œì•„ì›ƒ
          audioManager.play("puzzle-theme"); // ì¼ë°˜ ê²Œì„ ìŒì•… ì¬ìƒ

          populatePuzzleLevels();

          document
            .getElementById("puzzle-level-select-modal")
            .classList.add("visible");
        });

      document
        .getElementById("close-puzzle-modal-btn")
        .addEventListener("click", () => {
          document
            .getElementById("puzzle-level-select-modal")
            .classList.remove("visible");
          showMainMenu();
        });

      // --- CHARACTER SELECTION LOGIC (NEW SECTION) ---

      function addGlobalSoundEvents() {
        // bodyì— ë‹¨ í•˜ë‚˜ì˜ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤ (ì´ë²¤íŠ¸ ìœ„ì„ ë°©ì‹).
        document.body.addEventListener("click", (event) => {
          // í´ë¦­ëœ ìš”ì†Œ ë˜ëŠ” ê·¸ ë¶€ëª¨ ì¤‘ì—ì„œ ìš°ë¦¬ê°€ ì†Œë¦¬ë¥¼ ë‚´ê³  ì‹¶ì€ ëŒ€ìƒì„ ì°¾ìŠµë‹ˆë‹¤.
          const targetElement = event.target.closest("button");

          // ëŒ€ìƒì´ ì—†ìœ¼ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          if (!targetElement) {
            return;
          }

          // ë¹„í™œì„±í™”ëœ ìš”ì†Œë‚˜ AIì˜ ì†íŒ¨ì—ì„œëŠ” ì†Œë¦¬ë¥¼ ì¬ìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          if (
            targetElement.disabled ||
            targetElement.classList.contains("ai-hand")
          ) {
            return;
          }

          // ëª¨ë“  ì¡°ê±´ì„ í†µê³¼í•˜ë©´ ì‚¬ìš´ë“œë¥¼ ì¬ìƒí•©ë‹ˆë‹¤.
          audioManager.playSfx("hover");
        });
      }

      function startCharacterSelection(mode) {
        document.querySelector(".shared-selection-area").style.pointerEvents =
          "auto";
        audioManager.fadeOut("main-menu");
        audioManager.play("character-select");

        gameMode = mode;
        selectionMode = mode;
        tempSelections = { p1: null, p2: null };
        isPlayerAI = { A: false, B: false }; // ìƒíƒœ ì´ˆê¸°í™”

        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");

        updatePlayerDisplay("p1", null);
        updatePlayerDisplay("p2", null);
        document.getElementById("p1-ready-overlay").classList.remove("visible");
        document.getElementById("p2-ready-overlay").classList.remove("visible");

        if (mode === "AI") {
          // ê¸°ì¡´ 1P vs AI ëª¨ë“œ ë¡œì§ (ìˆ˜ì • ì—†ìŒ)
          const turnModal = document.getElementById("turn-order-modal");
          document.getElementById("turn-order-title").textContent =
            currentLang.ui.turnOrderTitle;
          document.getElementById("select-first-player").textContent =
            currentLang.ui.selectFirstPlayer;
          document.getElementById("select-second-player").textContent =
            currentLang.ui.selectSecondPlayer;

          turnModal.classList.add("visible");

          document.getElementById("select-first-player").onclick = () => {
            humanPlayerId = "P1";
            aiPlayer = "B"; // ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
            isPlayerAI.B = true; // ìƒˆë¡œìš´ ìƒíƒœ ë³€ìˆ˜ ì„¤ì •
            turnModal.classList.remove("visible");
            document
              .getElementById("character-selection-screen")
              .classList.remove("hidden");
            beginPlayerSelectionTurn("P1");
          };
          document.getElementById("select-second-player").onclick = () => {
            humanPlayerId = "P2";
            aiPlayer = "A"; // ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
            isPlayerAI.A = true; // ìƒˆë¡œìš´ ìƒíƒœ ë³€ìˆ˜ ì„¤ì •
            turnModal.classList.remove("visible");
            document
              .getElementById("character-selection-screen")
              .classList.remove("hidden");
            beginPlayerSelectionTurn("P1");
          };
        } else if (mode === "AI_VS_AI") {
          aiPlayer = null; // ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
          humanPlayerId = null;
          isPlayerAI = { A: true, B: true }; // ì–‘ìª½ ëª¨ë‘ AIë¡œ ì„¤ì •
          document
            .getElementById("character-selection-screen")
            .classList.remove("hidden");
          beginPlayerSelectionTurn("P1"); // 1P AI ì„ íƒë¶€í„° ì‹œì‘
        } else {
          // 2P ëª¨ë“œì˜ ê²½ìš° (ìˆ˜ì • ì—†ìŒ)
          aiPlayer = null;
          humanPlayerId = null;
          document
            .getElementById("character-selection-screen")
            .classList.remove("hidden");
          beginPlayerSelectionTurn("P1");
        }
      }

      function beginPlayerSelectionTurn(player) {
        characterSelectionTurn = player;
        const lang = currentLang.ui;
        let instruction; // instruction ë³€ìˆ˜ ì„ ì–¸

        // í„´ì— ë”°ë¼ í‘œì‹œí•  ì•ˆë‚´ ë¬¸êµ¬ë¥¼ ê²°ì •í•˜ëŠ” ë¶€ë¶„ (ê¸°ì¡´ê³¼ ë™ì¼)
        if (selectionMode === "AI") {
          instruction =
            player === humanPlayerId
              ? lang.selectYourPhilosopher // "ë‹¹ì‹ ì˜ ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”"
              : lang.selectAIPhilosopher; // "AIì˜ ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”"
        } else if (selectionMode === "AI_VS_AI") {
          instruction =
            player === "P1"
              ? lang.selectAIP1Philosopher
              : lang.selectAIP2Philosopher;
        } else {
          // 2P ëª¨ë“œ
          instruction =
            player === "P1"
              ? lang.selectP1Philosopher // "1P, ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”"
              : lang.selectP2Philosopher; // "2P, ì² í•™ìë¥¼ ì„ íƒí•˜ì„¸ìš”"
        }

        // [ìˆ˜ì •ëœ ë¶€ë¶„ 1] ìš°ë¦¬ê°€ ìƒˆë¡œ ì¶”ê°€í•œ ì „ìš© ì¸ë””ì¼€ì´í„°ì— í…ìŠ¤íŠ¸ë¥¼ ì„¤ì •í•˜ê³  í™”ë©´ì— í‘œì‹œ
        const charIndicator = document.getElementById(
          "character-select-indicator"
        );
        charIndicator.textContent = instruction;
        charIndicator.classList.remove("hidden");

        // [ìˆ˜ì •ëœ ë¶€ë¶„ 2] ëˆ„ë½ë˜ì—ˆë˜ ìºë¦­í„° ì•„ì´ì½˜ ìƒì„± ì½”ë“œê°€ ì—¬ê¸°ì— ë‹¤ì‹œ í¬í•¨ë˜ì—ˆìŠµë‹ˆë‹¤.
        const grid = document.getElementById("shared-char-grid");
        grid.innerHTML = "";
        for (const key in PHILOSOPHERS) {
          if (key === "derrida") {
            continue; // í‚¤ê°€ 'derrida'ì´ë©´ ì•„ì´ì½˜ì„ ìƒì„±í•˜ì§€ ì•Šê³  ê±´ë„ˆëœë‹ˆë‹¤.
          }
          const philosopher = PHILOSOPHERS[key];
          const iconEl = document.createElement("div");
          iconEl.className = "char-icon";
          iconEl.dataset.id = key;
          iconEl.style.backgroundImage = `url('${philosopher.icon}')`;
          iconEl.onclick = () => handleCharacterClick(key);
          grid.appendChild(iconEl);
        }
        const randomIconEl = document.createElement("div");
        randomIconEl.className = "char-icon";
        randomIconEl.id = "random-char-btn";
        randomIconEl.onclick = () => {
          // 'derrida'ë¥¼ ì œì™¸í•œ ì² í•™ì ID ëª©ë¡ì„ ìƒì„±í•©ë‹ˆë‹¤.
          const allCharIds = Object.keys(PHILOSOPHERS).filter(
            (id) => id !== "derrida"
          );
          let availableCharIds;
          if (characterSelectionTurn === "P1") {
            availableCharIds = allCharIds;
          } else {
            availableCharIds = allCharIds.filter(
              (id) => id !== tempSelections.p1
            );
          }
          const randomId =
            availableCharIds[
              Math.floor(Math.random() * availableCharIds.length)
            ];
          handleCharacterClick(randomId);
        };
        grid.appendChild(randomIconEl);
      }

      function handleCharacterClick(philosopherId) {
        const targetPlayer = characterSelectionTurn === "P1" ? "p1" : "p2";
        tempSelections[targetPlayer] = philosopherId;
        updatePlayerDisplay(targetPlayer, philosopherId);

        document.querySelectorAll(".char-icon").forEach((icon) => {
          icon.classList.toggle("selected", icon.dataset.id === philosopherId);
        });

        document.getElementById("confirm-selection-btn").disabled = false;
      }

      function updatePlayerDisplay(player, philosopherId) {
        const portraitEl = document.getElementById(`${player}-portrait`);
        const nameEl = document.getElementById(`${player}-philosopher-name`);
        const skillDescEl = document.getElementById(`${player}-skill-desc`);

        if (philosopherId) {
          const p = PHILOSOPHERS[philosopherId];
          // player('p1' ë˜ëŠ” 'p2')ì— ë”°ë¼ p.image ê°ì²´ì—ì„œ ì•Œë§ì€ ê²½ë¡œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
          const imageUrl = p.image[player];
          portraitEl.style.backgroundImage = `url('${imageUrl}')`;
          nameEl.textContent = p.name[currentLang.langCode];
          skillDescEl.textContent = p.skill[currentLang.langCode];
        } else {
          portraitEl.style.backgroundImage = "none";
          nameEl.textContent = "";
          skillDescEl.textContent = currentLang.ui.waitingForOpponent;
        }
      }

      function handleConfirmClick() {
        audioManager.playSfx("hover");
        document.getElementById("confirm-selection-btn").disabled = true;

        if (characterSelectionTurn === "P1") {
          document.getElementById("p1-ready-overlay").classList.add("visible");
          beginPlayerSelectionTurn("P2");
        } else {
          document.getElementById("p2-ready-overlay").classList.add("visible");
          finalizeSelection();
        }
      }

      function finalizeSelection() {
        const charIndicator = document.getElementById(
          "character-select-indicator"
        );
        charIndicator.textContent = currentLang.ui.gameStartingSoon;

        document.querySelector(".shared-selection-area").style.pointerEvents =
          "none";

        audioManager.fadeOut("character-select");

        setTimeout(() => {
          charIndicator.classList.add("hidden");
          document
            .getElementById("character-selection-screen")
            .classList.add("hidden");
          document
            .getElementById("turn-order-modal")
            .classList.remove("visible");
          updateMainMenuBtnVisibility();
          updateMainCenterVisibility();
          resetGame(tempSelections);

          if (isTestMode) {
            // í…ŒìŠ¤íŠ¸ ëª¨ë“œì¼ ê²½ìš°, ë°ì´í„° ì…ë ¥ ë° í…ŒìŠ¤íŠ¸ ê²Œì„ ì‹œì‘
            promptAndSetupTestGame(tempSelections);
          } else {
            // ì¼ë°˜ ëª¨ë“œì¼ ê²½ìš°, ê¸°ì¡´ ê²Œì„ ì‹œì‘
            resetGame(tempSelections);
          }
        }, 2000);
      }

      function startTutorial(startStep = 0) {
        const exitBtn = document.getElementById("emergency-exit-tutorial-btn");
        exitBtn.classList.remove("hidden");
        exitBtn.textContent = currentLang.ui.endTutorialButton;
        audioManager.fadeOut("main-menu");
        audioManager.play("game-play");

        // íŠœí† ë¦¬ì–¼ ì‹œì‘ ì‹œ, ì² í•™ìë¥¼ ì†Œí¬ë¼í…ŒìŠ¤ì™€ í”Œë¼í†¤ìœ¼ë¡œ ê°•ì œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        playerA_Data = PHILOSOPHERS["socrates"];
        playerB_Data = PHILOSOPHERS["plato"];

        // íŠœí† ë¦¬ì–¼ì— ì‚¬ìš©ë  ì² í•™ì(ì†Œí¬ë¼í…ŒìŠ¤, í”Œë¼í†¤)ì˜ ëŠ¥ë ¥ ì‚¬ìš© ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        abilityUsedState = {};
        abilityUsedState["A"] = { usedCount: 0, maxUses: 2 }; // ì†Œí¬ë¼í…ŒìŠ¤ëŠ” 2íšŒ ì‚¬ìš© ê°€ëŠ¥
        abilityUsedState["B"] = { used: false }; // í”Œë¼í†¤ì€ 1íšŒ ì‚¬ìš© ê°€ëŠ¥

        fullDeck = currentLang.cards;

        inTutorialMode = true;
        tutorialStep = startStep;
        tutorialSubStep = 0;

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.endTutorialButton;
        tutorialBtn.removeEventListener("click", startTutorial);
        tutorialBtn.addEventListener("click", endTutorial);

        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            if (
              btn.id !== "tutorial-btn" &&
              btn.id !== "main-menu-btn" &&
              btn.id !== "fullscreen-btn" &&
              btn.id !== "settings-btn"
            ) {
              btn.disabled = true;
            }
          });

        document.getElementById("tutorial-guide").classList.remove("hidden");
        document.getElementById("tutorial-next-btn").textContent =
          currentLang.ui.nextButton;

        setupTutorialScenario(startStep + 1);
        advanceTutorial();
      }

      function advanceTutorial() {
        // Clear previous temporary listeners to prevent stacking
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
          temporaryListener = null;
        }

        const script = currentLang.tutorial[tutorialStep];
        if (!script || tutorialSubStep >= script.length) {
          tutorialStep++;
          tutorialSubStep = 0;
          if (tutorialStep >= currentLang.tutorial.length) {
            endTutorial();
            return;
          }
          setupTutorialScenario(tutorialStep + 1); // Setup for the *next* stage
        }

        const newScript = currentLang.tutorial[tutorialStep];
        if (!newScript || tutorialSubStep >= newScript.length) {
          endTutorial();
          return;
        }

        const guideTextEl = document.getElementById("tutorial-text");
        const tutorialGuideEl = document.getElementById("tutorial-guide");
        const nextBtn = document.getElementById("tutorial-next-btn");
        guideTextEl.innerHTML = newScript[tutorialSubStep];
        nextBtn.classList.remove("hidden");

        // Reset position and highlights
        tutorialGuideEl.classList.remove("top");
        clearHighlights();

        handleTutorialStepLogic();

        tutorialSubStep++;
      }

      function handleTutorialStepLogic() {
        if (tutorialStep === 0) {
          // Stage 1
          switch (tutorialSubStep) {
            case 5:
              highlightElement("#player-a-hand");
              break;
            case 6:
              highlightElement("#proposition-display");
              break;
            case 7:
              const cardToClick = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.socrates);
              if (cardToClick) {
                highlightElement(cardToClick);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(cardToClick, "click", () => {
                  const cardData = playerA_Hand.find(
                    (c) => c.text === currentLang.keywords.socrates
                  );
                  playCardTutorial(cardData);
                  advanceTutorial();
                });
              }
              break;
            case 9:
              clearHighlights();
              const entityCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[2]; // ê°œì²´ or Entity
              });
              const quantifierCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[1]; // ì–‘í™”ì‚¬ or Quantifier
              });
              entityCards.forEach((card) => {
                card.classList.add("tutorial-highlight");
                card.classList.remove("unplayable"); // ì´ ì¤„ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
              });
              quantifierCards.forEach((card) => {
                card.classList.add("tutorial-highlight");
                card.classList.remove("unplayable"); // ì´ ì¤„ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
              });
              break;
            case 11:
              const endTurnBtn = document.getElementById("end-turn-btn");
              highlightElement(endTurnBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endTurnBtn, "click", () => {
                endTurnTutorial();
                advanceTutorial();
              });
              break;
          }
        } else if (tutorialStep === 1) {
          // Stage 2
          switch (tutorialSubStep) {
            case 2:
              const completeBtn = document.getElementById("complete-btn");
              highlightElement(completeBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(completeBtn, "click", () => {
                completePropositionTutorial();
                advanceTutorial();
              });
              break;
            case 7:
              clearHighlights();
              const connectiveCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter(
                (c) =>
                  c.textContent === currentLang.keywords.and ||
                  c.textContent === currentLang.keywords.or ||
                  c.textContent === currentLang.keywords.if
              );
              connectiveCards.forEach((card) => {
                card.classList.add("tutorial-highlight");
                card.classList.remove("unplayable"); // ì´ ì¤„ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
              });
              break;
            case 8:
              const negationCard = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.not);
              if (negationCard) highlightElement(negationCard);
              break;
          }
        } else if (tutorialStep === 2) {
          // Stage 3
          switch (tutorialSubStep) {
            case 0:
              highlightElement("#true-propositions");
              break;
            case 1:
              const axiomSummary = document.querySelector(
                ".axiom-wrapper summary"
              );
              if (axiomSummary) {
                highlightElement(axiomSummary);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(axiomSummary, "click", () => {
                  advanceTutorial();
                });
              }
              break;
            case 2:
            case 3:
            case 4:
            case 5:
              document.getElementById("tutorial-guide").classList.add("top");
              break;
          }
          // handleTutorialStepLogic í•¨ìˆ˜ ë‚´ì˜ 'else if (tutorialStep === 3)' ë¸”ë¡ì„ ì°¾ì•„ í†µì§¸ë¡œ êµì²´í•©ë‹ˆë‹¤.
        } else if (tutorialStep === 3) {
          // Stage 4 - Thinking Time
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 2: // "í›„ê³µ í”Œë ˆì´ì–´ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤..." í…ìŠ¤íŠ¸ í‘œì‹œ
              // íŠ¹ë³„í•œ ë™ì‘ ì—†ì´ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.
              break;
            case 3: // "(ìƒëŒ€ë°©ì´ í„´ì„ ë§ˆì³¤ìŠµë‹ˆë‹¤...)" í…ìŠ¤íŠ¸ í‘œì‹œ
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              // ìƒëŒ€ í„´ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ê³  ìë™ìœ¼ë¡œ í”Œë ˆì´ì–´ í„´ìœ¼ë¡œ ë„˜ê¹ë‹ˆë‹¤.
              setTimeout(() => {
                endTurn(); // ìƒëŒ€ í„´ ì¢…ë£Œ
                advanceTutorial(); // ë‹¤ìŒ ë‹¨ê³„ë¡œ ìë™ ì§„í–‰
              }, 1500); // 1.5ì´ˆ í›„ ì‹¤í–‰
              break;
            case 4: // "ì´ì œ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤. ì •ë¦¬ ì¶”ê°€ ë²„íŠ¼ì„..."
              const addTheoremBtn = document.getElementById("eureka-a");
              highlightElement(addTheoremBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(addTheoremBtn, "click", () => {
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            case 6: // "ì „ì œ ëª©ë¡ì—ì„œ..."
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤", "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤"]
                  : ["Socrates is a dog", "Every dog is wise"]
              );
              break;
            case 7: // "ì¶”ë¡  ê·œì¹™ì—ì„œ..."
              handleTutorialRuleApplication("universalApplication");
              break;
            case 8: // "ì¢‹ìŠµë‹ˆë‹¤! ... ì´ì œ ì´ ì •ë¦¬ë¥¼ ì„ íƒí•˜ê³ ..."
              const confirmBtn = document.getElementById("modal-confirm-btn");
              const newTheoremText =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤"
                  : "Socrates is wise";
              const newTheoremProp = parsePropositionFromString(newTheoremText);
              const theoremLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.type === "theorem" &&
                  arePropositionsEqual(data.proposition, newTheoremProp)
                );
              });

              if (theoremLi && confirmBtn) {
                highlightElement(theoremLi);
                confirmBtn.classList.add("tutorial-highlight");
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");

                const confirmHandler = () => {
                  const checkbox = theoremLi.querySelector("input");
                  if (checkbox && checkbox.checked) {
                    addTheoremsToListTutorial();
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "ìƒˆë¡œ ë„ì¶œëœ ì •ë¦¬ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”."
                        : "Please select the newly derived theorem first."
                    );
                  }
                };
                waitForInteraction(confirmBtn, "click", confirmHandler);
              }
              break;
            case 9: // "í›Œë¥­í•©ë‹ˆë‹¤! ì‚¬ìœ  ì‹œê°„ì—ëŠ”..."
              // 'ëŠ¥ë ¥ ì‚¬ìš©' ë²„íŠ¼ì„ í•˜ì´ë¼ì´íŠ¸í•©ë‹ˆë‹¤.
              highlightElement("#ability-a");
              break;
            case 10: // "ìƒˆë¡œìš´ ì •ë¦¬ê°€... ì´ì œ í„´ ì¢…ë£Œ ë²„íŠ¼ì„..."
              const endTurnBtn = document.getElementById("end-turn-btn");
              highlightElement(endTurnBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endTurnBtn, "click", () => {
                endThinkingTime(); // ì‚¬ìœ  ì‹œê°„ì„ ì¢…ë£Œí•˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œ
                advanceTutorial();
              });

              break;
          }
        } else if (tutorialStep === 4) {
          // Stage 5 - Basic Rules
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            // Intro
            case 0:
              const eurekaBtn = document.getElementById("eureka-a");
              highlightElement(eurekaBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(eurekaBtn, "click", (event) => {
                // eventë¥¼ ì¸ìë¡œ ë°›ë„ë¡ ìˆ˜ì •
                event.stopPropagation(); // ì „ì—­ ë¦¬ìŠ¤ë„ˆë¡œ ì´ë²¤íŠ¸ê°€ ê°€ëŠ” ê²ƒì„ ë§‰ìŒ
                audioManager.playSfx("eureka"); // ê³ ìœ  íš¨ê³¼ìŒ ì¬ìƒ
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            // Modus Ponens
            case 2:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤",
                      "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤) ë¼ë©´ (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤)",
                    ]
                  : [
                      "Socrates is good",
                      "(Socrates is good) then (Socrates wins)",
                    ]
              );
              break;
            case 3:
              handleTutorialRuleApplication("modusPonens");
              break;
            // Modus Tollens
            case 5:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                      "(í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                    ]
                  : [
                      "Plato is wise is false",
                      "(Plato wins) then (Plato is wise)",
                    ]
              );
              break;
            case 6:
              handleTutorialRuleApplication("modusTollens");
              break;
            // Disjunctive Syllogism
            case 8:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤) ë˜ëŠ” (ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤)",
                      "ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                    ]
                  : [
                      "(Some bird is a fish) or (Some bird is a bird)",
                      "Some bird is a fish is false",
                    ]
              );
              break;
            case 9:
              handleTutorialRuleApplication("disjunctiveSyllogism");
              break;
            // Hypothetical Syllogism
            case 11:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                      "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤)",
                    ]
                  : [
                      "(Plato is a dog) then (Plato is good)",
                      "(Plato is good) then (Plato wins)",
                    ]
              );
              break;
            case 12:
              handleTutorialRuleApplication("hypotheticalSyllogism");
              break;
            // Conjunction Elimination
            case 14:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)"]
                  : ["(Socrates is wise) and (Plato is foolish)"]
              );
              break;
            case 15:
              handleTutorialRuleApplication("conjunctionElimination");
              break;
            // Double Negation
            case 17:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"]
                  : ["Some fish is good is false is false"]
              );
              break;
            case 18:
              handleTutorialRuleApplication("doubleNegationElimination");
              break;
            // Universal Application
            case 20:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤", "í”Œë¼í†¤ì€ ìƒˆì´ë‹¤"]
                  : ["Every bird is good", "Plato is a bird"]
              );
              break;
            case 21:
              handleTutorialRuleApplication("universalApplication");
              break;
            // Existential Instantiation
            case 23:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤"]
                  : ["Every dog is good"]
              );
              break;
            case 24:
              handleTutorialRuleApplication("existentialInstantiation");
              break;
          }
        } else if (tutorialStep === 5) {
          // Stage 6 - Advanced Rules (Proof by Cases)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              const premises =
                currentLang.langCode === "ko"
                  ? [
                      "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë˜ëŠ” í”Œë¼í†¤ì€ ì•…í•˜ë‹¤",
                      "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                      "(í”Œë¼í†¤ì€ ì•…í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                    ]
                  : [
                      "Plato is good or Plato is evil",
                      "(Plato is good) then (Plato is wise)",
                      "(Plato is evil) then (Plato is wise)",
                    ];
              handleTutorialRuleInteraction(premises);
              break;
            case 2:
              handleTutorialRuleApplication("proofByCases");
              break;
          }
        } else if (tutorialStep === 6) {
          // Stage 7 - Assumption (Conditional Intro) â˜…â˜…â˜… MODIFIED SECTION â˜…â˜…â˜…
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1: // Assume
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionCI =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤"
                  : "Socrates is wise";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionCI) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "ì˜¬ë°”ë¥¸ ëª…ì œë¥¼ ì…ë ¥í•´ ì£¼ì‹­ì‹œì˜¤."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2: // Select premises for 1st MP
              const premisesCI_1 =
                currentLang.langCode === "ko"
                  ? [
                      "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤",
                      "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ê°œì´ë‹¤)",
                    ]
                  : [
                      "Socrates is wise",
                      "(Socrates is wise) then (Plato is a dog)",
                    ];
              handleTutorialRuleInteraction(premisesCI_1);
              break;
            case 3: // Apply 1st MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 4: // Select premises for 2nd MP
              const premisesCI_2 =
                currentLang.langCode === "ko"
                  ? [
                      "í”Œë¼í†¤ì€ ê°œì´ë‹¤",
                      "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                    ]
                  : ["Plato is a dog", "(Plato is a dog) then (Plato is good)"];
              handleTutorialRuleInteraction(premisesCI_2);
              break;
            case 5: // Apply 2nd MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 6: // Select final result
              const conclusionTextCI =
                currentLang.langCode === "ko"
                  ? "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤"
                  : "Plato is good";
              const conclusionPropCI =
                parsePropositionFromString(conclusionTextCI);
              const conclusionLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.dependsOnAssumption &&
                  arePropositionsEqual(data.proposition, conclusionPropCI)
                );
              });
              if (conclusionLi) {
                highlightElement(conclusionLi);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(
                  document.getElementById("premise-list"),
                  "click",
                  () => {
                    const selectedCheckbox =
                      conclusionLi.querySelector("input");
                    const allCheckboxes = document.querySelectorAll(
                      "#premise-list input:checked"
                    );
                    if (
                      selectedCheckbox.checked &&
                      allCheckboxes.length === 1
                    ) {
                      advanceTutorial();
                    }
                  }
                );
              }
              break;
            case 7: // Apply CI
              handleTutorialRuleApplication("conditionalIntroduction");
              break;
          }
        } else if (tutorialStep === 7) {
          // Stage 8 - Assumption (RAA)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionRAA =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
                  : "Socrates is evil is false";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionRAA) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "ì˜¬ë°”ë¥¸ ëª…ì œë¥¼ ì…ë ¥í•´ ì£¼ì‹­ì‹œì˜¤."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2:
              const premisesRAA_texts =
                currentLang.langCode === "ko"
                  ? [
                      "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                      "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                    ]
                  : [
                      "(Socrates is evil is false) then (Plato is wise)",
                      "Socrates is evil is false",
                    ];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList_mp = document.getElementById("premise-list");
              const premiseProps_mp = premisesRAA_texts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis_mp = premiseProps_mp
                .map((prop) =>
                  Array.from(premiseList_mp.querySelectorAll("li")).find(
                    (li) => {
                      const data = JSON.parse(li.dataset.propObject);
                      return arePropositionsEqual(data.proposition, prop);
                    }
                  )
                )
                .filter(Boolean);

              premiseLis_mp.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              document
                .getElementById("inference-rule-select")
                .classList.add("tutorial-highlight");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn_mp = document.getElementById("apply-rule-btn");
              const select_mp = document.getElementById(
                "inference-rule-select"
              );

              const applyRuleHandler_mp = () => {
                const allChecked = premiseLis_mp.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList_mp.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis_mp.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "ë¨¼ì € ê°€ì •ê³¼ ë‹¤ë¥¸ ì „ì œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”."
                      : "Please select the assumption and the other premise first."
                  );
                  return;
                }

                if (select_mp.value === "modusPonens") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 3
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn_mp, "click", applyRuleHandler_mp);
              break;
            case 3:
              // This substep now just shows the result text.
              // The logic is handled in case 2.
              // We just need to clear highlights and let the user click "Next".
              clearHighlights();
              break;
            case 4: // This case now handles both selection and application for RAA.
              const contradictionPairTexts =
                currentLang.langCode === "ko"
                  ? ["í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤", "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"]
                  : ["Plato is wise", "Plato is wise is false"];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList = document.getElementById("premise-list");
              const premiseProps = contradictionPairTexts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis = premiseProps
                .map((prop) =>
                  Array.from(premiseList.querySelectorAll("li")).find((li) => {
                    const data = JSON.parse(li.dataset.propObject);
                    return arePropositionsEqual(data.proposition, prop);
                  })
                )
                .filter(Boolean);

              premiseLis.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              highlightElement("#inference-rule-select");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn = document.getElementById("apply-rule-btn");
              const select = document.getElementById("inference-rule-select");

              const applyRuleHandler = () => {
                const allChecked = premiseLis.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "ë¨¼ì € ëª¨ìˆœë˜ëŠ” ë‘ ì „ì œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”."
                      : "Please select the two contradictory premises first."
                  );
                  return;
                }

                if (select.value === "reductioAdAbsurdum") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 5
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn, "click", applyRuleHandler);
              break;
            case 5: // This is the step where the RAA result is shown and DNE is expected
              clearHighlights();
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden"); // Hide the "Next" button

              const raaResultText =
                currentLang.langCode === "ko"
                  ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
                  : "Socrates is evil is false is false";
              const raaResultProp = parsePropositionFromString(raaResultText);

              const premiseListForDNE = document.getElementById("premise-list");
              const raaResultLi = Array.from(
                premiseListForDNE.querySelectorAll("li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                // Check if it's a theorem derived from RAA and matches the expected proposition
                return (
                  data.type === "theorem" &&
                  data.label === currentLang.labels.raa_theorem &&
                  arePropositionsEqual(data.proposition, raaResultProp)
                );
              });

              if (raaResultLi) {
                highlightElement(raaResultLi); // Highlight the RAA result
                highlightElement("#inference-rule-select"); // Highlight the rule dropdown
                document
                  .getElementById("apply-rule-btn")
                  .classList.add("tutorial-highlight"); // Highlight the apply button

                const applyBtnDNE = document.getElementById("apply-rule-btn");
                const selectDNE = document.getElementById(
                  "inference-rule-select"
                );

                const applyRuleHandlerDNE = () => {
                  const selectedCheckboxes = premiseListForDNE.querySelectorAll(
                    'input[type="checkbox"]:checked'
                  );
                  const isRaaResultSelected = Array.from(
                    selectedCheckboxes
                  ).some((chk) => chk.parentElement === raaResultLi);

                  // Check if exactly one premise is selected, it's the RAA result, and DNE rule is chosen
                  if (
                    selectedCheckboxes.length === 1 &&
                    isRaaResultSelected &&
                    selectDNE.value === "doubleNegationElimination"
                  ) {
                    applyRuleTutorial(); // Apply the rule
                    advanceTutorial(); // Proceed to the next tutorial step
                  } else {
                    showAlert(currentLang.alerts.ruleFailed); // Show error if conditions not met
                  }
                };
                waitForInteraction(applyBtnDNE, "click", applyRuleHandlerDNE);
              } else {
                // Fallback if RAA result not found (shouldn't happen in normal tutorial flow)
                console.error(
                  "Tutorial Error: RAA result not found for DNE step."
                );
                advanceTutorial(); // Proceed to next step if something went wrong
              }
              break;
            case 6: // This is the final text step
              clearHighlights();
              // No specific interaction needed, just display text and allow "Next" to end tutorial
              break;
          }
        } else if (tutorialStep === 8) {
          // Stage 9 - Final Puzzle Logic
          document.getElementById("tutorial-guide").classList.add("top");
          document.getElementById("tutorial-next-btn").classList.add("hidden"); // ë‹¤ìŒ ë²„íŠ¼ ìˆ¨ê¹€
          // ì‚¬ìš©ìê°€ ì§ì ‘ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼ í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œ ë” ì´ìƒ ìë™ ì§„í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
        }
      }

      function handleTutorialRuleInteraction(premiseTexts) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        const premiseList = document.getElementById("premise-list");
        const premiseProps = premiseTexts.map((text) =>
          parsePropositionFromString(text)
        );
        const premiseLis = premiseProps
          .map((prop) =>
            Array.from(premiseList.querySelectorAll("li")).find((li) => {
              // êµ¬ë¶„ì„  ìš”ì†ŒëŠ” ê±´ë„ˆë›°ê¸°
              if (!li.dataset.propObject) return false;
              const data = JSON.parse(li.dataset.propObject);
              return arePropositionsEqual(data.proposition, prop);
            })
          )
          .filter(Boolean);

        if (premiseLis.length !== premiseTexts.length) {
          console.error(
            "Tutorial Error: Could not find all required premises in the list.",
            premiseTexts
          );
          return;
        }

        premiseLis.forEach((li) => li.classList.add("tutorial-highlight"));

        const checkPremises = () => {
          const allChecked = premiseLis.every(
            (li) => li.querySelector("input").checked
          );
          const totalChecked =
            premiseList.querySelectorAll("input:checked").length;
          if (allChecked && totalChecked === premiseLis.length) {
            advanceTutorial();
          }
        };
        waitForInteraction(premiseList, "click", checkPremises);
      }

      function handleTutorialRuleApplication(ruleValue) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        highlightElement("#inference-rule-select");
        document
          .getElementById("apply-rule-btn")
          .classList.add("tutorial-highlight");

        // ì²´í¬ë°•ìŠ¤ë“¤ì„ ë¹„í™œì„±í™”
        const checkboxes = document.querySelectorAll(
          "#premise-list input[type='checkbox']"
        );
        checkboxes.forEach((checkbox) => {
          checkbox.disabled = true;
        });

        const applyBtn = document.getElementById("apply-rule-btn");
        const select = document.getElementById("inference-rule-select");

        const applyRuleHandler = () => {
          if (select.value === ruleValue) {
            // ì „ì œê°€ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸
            const selectedPremises = document.querySelectorAll(
              "#premise-list input:checked"
            );
            if (selectedPremises.length === 0) {
              showAlert(
                currentLang.langCode === "ko"
                  ? "ì „ì œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”."
                  : "Please select premises."
              );
              return;
            }

            applyRuleTutorial();
            advanceTutorial();
          } else {
            showAlert(currentLang.alerts.ruleFailed);
          }
        };
        waitForInteraction(applyBtn, "click", applyRuleHandler);
      }

      function playCardTutorial(cardToPlay) {
        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (c) => c.text === cardToPlay.text && c.type === cardToPlay.type
        );

        audioManager.playSfx("playCard");

        if (cardIndex > -1) {
          const [playedCard] = hand.splice(cardIndex, 1);
          currentProposition.push({ card: playedCard, player: currentPlayer });
          cardsPlayedThisTurn[currentPlayer]++;
          lastCardPlayer = currentPlayer;
          render();
        }
      }

      function endTurnTutorial() {
        audioManager.playSfx("end");
        currentPlayer = currentPlayer === "A" ? "B" : "A";
        cardsPlayedThisTurn.A = 0;
        cardsPlayedThisTurn.B = 0;
        render();
      }

      function completePropositionTutorial() {
        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (parsedProp) {
          truePropositions.push({
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          });

          audioManager.playSfx("complete");

          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
        }
      }

      function openEurekaModalTutorial() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions.filter(
            (p) =>
              p.type === "user-made" ||
              p.type === "theorem" ||
              p.type === "victory"
          ),
        ];
        // ê³µë¦¬ë“¤ì„ ê·¸ë£¹ë³„ë¡œ ë¶„ë¥˜í•˜ê³  ìˆœì„œëŒ€ë¡œ ì¶”ê°€ (íŠœí† ë¦¬ì–¼ ë²„ì „)
        const axioms = allSelectablePropositions.filter(p => p.type === "axiom");
        const nonAxioms = allSelectablePropositions.filter(p => p.type !== "axiom");
        
        // ê³µë¦¬ë¥¼ ê·¸ë£¹í™”í•˜ì—¬ ì¶”ê°€ - ì‘ì€ ì„œë¸Œê·¸ë£¹ë³„ë¡œ êµ¬ë¶„ì„  ì¶”ê°€
        if (currentAxioms.groups && axioms.length > 0) {
          const groups = currentAxioms.groups;
          const templates = currentLang.axiom_templates;
          let axiomIndex = 0;
          
          // ì •ì²´ì„± ê³µë¦¬ ê·¸ë£¹
          if (groups.identity && groups.identity.length > 0) {
            for (let i = 0; i < groups.identity.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì •ì²´ì„± ê·¸ë£¹ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ - ì„œë¸Œê·¸ë£¹ë³„ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.subjectOpposition && groups.subjectOpposition.length > 0) {
            // ì²« ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ì²« ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë‘ ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë‘ ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ - ì„œë¸Œê·¸ë£¹ë³„ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.quantifierOpposition && groups.quantifierOpposition.length > 0) {
            // ìƒˆ ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.bird_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ìƒˆ ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.bird_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.fish_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.fish_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ê°œ ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.dog_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ê°œ ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.dog_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ë§ˆë¥´í¬ìŠ¤ ê³µë¦¬ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            const remainingAxioms = axioms.slice(axiomIndex);
            const marxAxioms = remainingAxioms.filter(a => {
              const text = propositionToNaturalText(a.proposition);
              return text.includes("ë¸Œë£¨ì£¼ì•„") || text.includes("Bourgeois");
            });
            
            if (marxAxioms.length > 0) {
              // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
              addPremiseToWorkbench({
                type: "separator",
                label: "",
                proposition: null,
                isSeparator: true
              });
              
              marxAxioms.forEach((axiomData) => {
                addPremiseToWorkbench({
                  proposition: axiomData.proposition,
                  type: axiomData.type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              });
            }
            
            // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ ë§ˆì§€ë§‰ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        } else {
          // ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ê³µë¦¬ ì¶”ê°€ (í•˜ìœ„ í˜¸í™˜ì„±)
          axioms.forEach((propData) => {
            addPremiseToWorkbench({
              proposition: propData.proposition,
              type: propData.type,
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.axiom
            });
          });
          
          // ê³µë¦¬ ë§ˆì§€ë§‰ êµ¬ë¶„ì„  ì¶”ê°€
          if (axioms.length > 0) {
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        }
        
        // ê³µë¦¬ê°€ ì•„ë‹Œ ëª…ì œë“¤ ì¶”ê°€
        nonAxioms.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });

        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        modalTitle.textContent = isThinkingTime
          ? currentLang.modals.eurekaTitleTheorem
          : currentLang.modals.eurekaTitleVictory;
        confirmBtn.textContent = isThinkingTime
          ? currentLang.modals.confirmTheoremButton
          : currentLang.modals.confirmVictoryButton;

        confirmBtn.onclick = isThinkingTime ? addTheoremsToList : proveVictory;

        document.getElementById("cancel-assumption-btn").style.display =
          currentAssumption ? "inline-block" : "none";

        renderModal();
        document.getElementById("inference-rule-select").onchange =
          updateConclusionPreview;
        updateConclusionPreview();
        modal.classList.add("visible");
      }

      function applyRuleTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premisesData = selectedLis
          .map((chk) => {
            const propString = chk.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter(Boolean);

        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];

        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (rule === "conditionalIntroduction") {
          const result = {
            type: "conditional",
            left: currentAssumption,
            right: premises[0],
          };
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.ci_theorem,
            });
            // íŠœí† ë¦¬ì–¼ ì¡°ê±´ë¶€ ë„ì… ì„±ê³µ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
            audioManager.playSfx("pop");
          }
        } else if (rule === "reductioAdAbsurdum") {
          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
            });
            // íŠœí† ë¦¬ì–¼ ê·€ë¥˜ë²• ì„±ê³µ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
            audioManager.playSfx("pop");
          }
        } else if (threePremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }

        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
            });
          });
          // íŠœí† ë¦¬ì–¼ ì¶”ë¡  ê·œì¹™ ì ìš© ì„±ê³µ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
          audioManager.playSfx("pop");
        }
        renderModal();
        updateConclusionPreview();
      }

      function addTheoremsToListTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const newTheorems = selectedLis
          .map((li) => {
            const propString = li.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter((p) => p && p.type === "theorem" && !p.dependsOnAssumption);

        newTheorems.forEach((theoremData) => {
          const isDuplicate = truePropositions.some((p) =>
            arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          if (!isDuplicate) {
            truePropositions.push({
              propId: `prop_${Date.now()}_${Math.random()}`, // âœ… ì´ ì¤„ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
          }
        });
        document.getElementById("eureka-modal").classList.remove("visible");
        render();
      }

      function highlightElement(elementOrSelector, remove = false) {
        clearHighlights();
        if (remove) return;

        const element =
          typeof elementOrSelector === "string"
            ? document.querySelector(elementOrSelector)
            : elementOrSelector;
        if (element) {
          element.classList.add("tutorial-highlight");
          element.classList.remove("unplayable");
        }
      }

      function clearHighlights() {
        const previouslyHighlighted = document.querySelectorAll(
          ".tutorial-highlight"
        );

        previouslyHighlighted.forEach((el) => {
          el.classList.remove("tutorial-highlight");

          // í•˜ì´ë¼ì´íŠ¸ê°€ ì œê±°ëœ ìš”ì†Œê°€ ì†íŒ¨ì— ìˆëŠ” ì¹´ë“œë¼ë©´,
          if (
            el.classList.contains("card") &&
            el.parentElement &&
            (el.parentElement.id === "player-a-hand" ||
              el.parentElement.id === "player-b-hand")
          ) {
            const cardText = el.textContent;
            const player = el.parentElement.id === "player-a-hand" ? "A" : "B";
            const hand = player === "A" ? playerA_Hand : playerB_Hand;
            const cardData = hand.find((c) => c.text === cardText);

            if (cardData) {
              // í˜„ì¬ ê²Œì„ ìƒíƒœì— ë”°ë¼ ì¹´ë“œê°€ ë¹„í™œì„±í™” ë˜ì–´ì•¼ í•˜ëŠ”ì§€ ë‹¤ì‹œ í™•ì¸í•©ë‹ˆë‹¤.
              const shouldBeUnplayable =
                isThinkingTime ||
                player !== currentPlayer ||
                cardsPlayedThisTurn[player] >= 1 ||
                !isValidPlay(cardData, currentProposition);

              if (shouldBeUnplayable) {
                el.classList.add("unplayable");
              }
            }
          }
        });
      }

      function waitForInteraction(element, eventType, callback) {
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
        }
        const handler = (event) => {
          // For checkbox clicks, we don't want to stop propagation
          if (eventType !== "click" || event.target.type !== "checkbox") {
          }
          callback(event);
        };
        element.addEventListener(eventType, handler, {
          once: eventType !== "click",
        });

        temporaryListener = { element, type: eventType, handler };
      }

      function endTutorial() {
        document
          .getElementById("emergency-exit-tutorial-btn")
          .classList.add("hidden");
        audioManager.fadeOut("game-play");
        audioManager.fadeOut("thinking-time");

        // --- ğŸ’¡[ìˆ˜ì •ëœ ë¶€ë¶„ ì‹œì‘] ---

        // 1. íŠœí† ë¦¬ì–¼ ì§„í–‰ ë‹¨ê³„ë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        inTutorialMode = false;
        tutorialStep = 0;
        tutorialSubStep = 0;

        // 2. íŠœí† ë¦¬ì–¼ ì§„í–‰ì„ ìœ„í•´ ì„ì‹œë¡œ ì¶”ê°€ë˜ì—ˆì„ ìˆ˜ ìˆëŠ” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì•ˆì „í•˜ê²Œ ì œê±°í•©ë‹ˆë‹¤.
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
          temporaryListener = null;
        }

        // --- [ìˆ˜ì •ëœ ë¶€ë¶„ ë] ---

        document.getElementById("tutorial-guide").classList.add("hidden");
        clearHighlights();

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.tutorialButton;
        tutorialBtn.removeEventListener("click", endTutorial);
        tutorialBtn.addEventListener("click", startTutorial);

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            btn.disabled = false;
          });
        document.getElementById("eureka-modal").classList.remove("visible");

        // ë©”ì¸ ë©”ë‰´ë¥¼ í‘œì‹œí•˜ì—¬ ê²Œì„ ìƒíƒœë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        showMainMenu();
      }
      function showAlert(message, callback) {
        const modal = document.getElementById("alert-modal");
        document.getElementById("alert-message").innerHTML = message;
        modal.classList.add("visible");

        // ê¸°ì¡´ ì´ë²¤íŠ¸ ì œê±°
        const okBtn = document.getElementById("alert-ok-btn");
        const newBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newBtn, okBtn);

        newBtn.addEventListener("click", () => {
          modal.classList.remove("visible");
          if (callback) callback();
        });
      }

      function showPrompt(message, callback) {
        const modal = document.getElementById("prompt-modal");
        document.getElementById("prompt-message").textContent = message;
        const input = document.getElementById("prompt-input");
        const confirmBtn = document.getElementById("prompt-confirm-btn");
        const cancelBtn = document.getElementById("prompt-cancel-btn");
        input.value = "";

        const confirmHandler = () => {
          cleanup();
          callback(input.value);
        };
        const cancelHandler = () => {
          cleanup();
          callback(null);
        };
        const cleanup = () => {
          modal.classList.remove("visible");
          confirmBtn.removeEventListener("click", confirmHandler);
          cancelBtn.removeEventListener("click", cancelHandler);
        };

        confirmBtn.addEventListener("click", confirmHandler);
        cancelBtn.addEventListener("click", cancelHandler);
        modal.classList.add("visible");
        input.focus();
      }

      function showConfirm(message, onConfirm, onCancel) {
        const modal = document.getElementById("prompt-modal");
        document.getElementById("prompt-message").innerHTML = message;
        const input = document.getElementById("prompt-input");
        const confirmBtn = document.getElementById("prompt-confirm-btn");
        const cancelBtn = document.getElementById("prompt-cancel-btn");

        input.style.display = "none";
        confirmBtn.textContent = currentLang.ui.yesButton;
        cancelBtn.textContent = currentLang.ui.noButton;

        const confirmHandler = (event) => {
          // ğŸ’¡ ë³€ê²½ì : event ê°ì²´ë¥¼ ë°›ë„ë¡ ìˆ˜ì •
          cleanup();
          if (onConfirm) onConfirm(event); // ğŸ’¡ ë³€ê²½ì : onConfirm ì½œë°±ìœ¼ë¡œ event ê°ì²´ë¥¼ ì „ë‹¬
        };

        const cancelHandler = () => {
          cleanup();
          if (onCancel) onCancel();
        };

        const cleanup = () => {
          modal.classList.remove("visible");
          input.style.display = "";
          confirmBtn.textContent = currentLang.ui.okButton;
          cancelBtn.textContent = currentLang.ui.cancelButton;
          confirmBtn.removeEventListener("click", confirmHandler);
          cancelBtn.removeEventListener("click", cancelHandler);
        };

        confirmBtn.addEventListener("click", confirmHandler);
        cancelBtn.addEventListener("click", cancelHandler);
        modal.classList.add("visible");
      }

      // --- GAME FLOW & TURN MANAGEMENT ---
      function modusPonens(p1, p2) {
        if (!p1 || !p2) return null;
        if (p2.type === "conditional" && arePropositionsEqual(p1, p2.left))
          return p2.right;
        if (p1.type === "conditional" && arePropositionsEqual(p2, p1.left))
          return p1.right;
        return null;
      }

      function modusTollens(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c, o) => {
          if (c.type !== "conditional") return null;
          const consequent = c.right;
          let isContradiction = false;
          if (
            o.type === "negation" &&
            arePropositionsEqual(o.proposition, consequent)
          ) {
            isContradiction = true;
          }
          if (
            consequent.type === "negation" &&
            arePropositionsEqual(consequent.proposition, o)
          ) {
            isContradiction = true;
          }
          if (isContradiction) {
            return { type: "negation", proposition: c.left };
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function disjunctiveSyllogism(p1, p2) {
        /**
         * ë‘ ëª…ì œê°€ ì„œë¡œ ëª¨ìˆœ ê´€ê³„ì¸ì§€ í™•ì¸í•˜ëŠ” í—¬í¼ í•¨ìˆ˜.
         * ì˜ˆ: (P, ~P) ë˜ëŠ” (~P, P)ëŠ” ì°¸ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
         * @param {object} propA - ëª…ì œ ê°ì²´ 1
         * @param {object} propB - ëª…ì œ ê°ì²´ 2
         * @returns {boolean} ëª¨ìˆœ ê´€ê³„ì´ë©´ true
         */
        const areContradictory = (propA, propB) => {
          // propAê°€ ~Xì´ê³  propBê°€ Xì¸ ê²½ìš°
          if (
            propA.type === "negation" &&
            arePropositionsEqual(propA.proposition, propB)
          ) {
            return true;
          }
          // propBê°€ ~Xì´ê³  propAê°€ Xì¸ ê²½ìš°
          if (
            propB.type === "negation" &&
            arePropositionsEqual(propB.proposition, propA)
          ) {
            return true;
          }
          return false;
        };

        /**
         * ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•ì„ ì ìš©í•˜ëŠ” ë‚´ë¶€ í•¨ìˆ˜.
         * @param {object} d - disjunction íƒ€ì…ìœ¼ë¡œ ì¶”ì •ë˜ëŠ” ëª…ì œ
         * @param {object} o - ë‚˜ë¨¸ì§€ ëª…ì œ
         * @returns {object|null} ì¶”ë¡  ê²°ê³¼ ë˜ëŠ” null
         */
        const check = (d, o) => {
          if (d.type !== "disjunction") return null;

          // ë‹¤ë¥¸ ì „ì œ(o)ê°€ ì„ ì–¸ë¬¸ì˜ ì™¼ìª½ ë¶€ë¶„(d.left)ê³¼ ëª¨ìˆœ ê´€ê³„ì¼ ë•Œ
          // ì˜ˆ: (P âˆ¨ Q)ì™€ ~Pê°€ ì£¼ì–´ì§€ë©´ Që¥¼ ë°˜í™˜ (ì´ë•Œ ~PëŠ” ~~Pì™€ë„ ëª¨ìˆœ)
          if (areContradictory(d.left, o)) {
            return d.right;
          }

          // ë‹¤ë¥¸ ì „ì œ(o)ê°€ ì„ ì–¸ë¬¸ì˜ ì˜¤ë¥¸ìª½ ë¶€ë¶„(d.right)ê³¼ ëª¨ìˆœ ê´€ê³„ì¼ ë•Œ
          // ì˜ˆ: (P âˆ¨ Q)ì™€ ~Qê°€ ì£¼ì–´ì§€ë©´ Pë¥¼ ë°˜í™˜
          if (areContradictory(d.right, o)) {
            return d.left;
          }

          return null;
        };

        // p1, p2 ìˆœì„œì™€ p2, p1 ìˆœì„œ ëª¨ë‘ í™•ì¸
        return check(p1, p2) || check(p2, p1);
      }

      function conjunctionIntroduction(p1, p2) {
        if (!p1 || !p2) return null;
        return { type: "conjunction", left: p1, right: p2 };
      }

      function conjunctionElimination(p) {
        if (p && p.type === "conjunction") return [p.left, p.right];
        return null;
      }

      function doubleNegationElimination(p) {
        if (p && p.type === "negation" && p.proposition.type === "negation")
          return p.proposition.proposition;
        return null;
      }

      function hypotheticalSyllogism(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c1, c2) => {
          if (
            c1.type === "conditional" &&
            c2.type === "conditional" &&
            arePropositionsEqual(c1.right, c2.left)
          )
            return { type: "conditional", left: c1.left, right: c2.right };
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function existentialInstantiation(p) {
        if (p && p.type === "universal") {
          return {
            type: "existential",
            entity: p.entity,
            predicate: p.predicate,
          };
        }
        return null;
      }

      function universalApplication(p1, p2) {
        if (!p1 || !p2) return null;
        const getBaseNoun = (text) => {
          if (currentLang.langCode === "ko") {
            return text.replace(/(ì´ë‹¤|ëŠ”|ì€)$/, "").trim();
          } else {
            return text.replace(/^is a /, "").trim();
          }
        };
        const check = (propA, propB) => {
          if (propA.type === "atomic" && propB.type === "universal") {
            const atomicPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (atomicPredicateBase === universalEntityBase) {
              return {
                type: "atomic",
                subject: propA.subject,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "existential" && propB.type === "universal") {
            const existentialPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (existentialPredicateBase === universalEntityBase) {
              return {
                type: "existential",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "universal" && propB.type === "universal") {
            const propAPredicateBase = getBaseNoun(propA.predicate);
            const propBEntityBase = getBaseNoun(propB.entity);
            if (propAPredicateBase === propBEntityBase) {
              return {
                type: "universal",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function reductioAdAbsurdum(p1, p2, assumption) {
        if (!p1 || !p2) return null;
        const isContradiction =
          (p1.type === "negation" &&
            arePropositionsEqual(p1.proposition, p2)) ||
          (p2.type === "negation" && arePropositionsEqual(p2.proposition, p1));
        if (isContradiction && assumption) {
          return { type: "negation", proposition: assumption };
        }
        return null;
      }

      function proofByCases(p1, p2, p3) {
        if (!p1 || !p2 || !p3) return null;
        const premises = [p1, p2, p3];
        const disjunction = premises.find((p) => p.type === "disjunction");
        if (!disjunction) return null;
        const conditionals = premises.filter((p) => p.type === "conditional");
        if (conditionals.length !== 2) return null;
        const p = disjunction.left;
        const q = disjunction.right;
        const cond1 = conditionals[0];
        const cond2 = conditionals[1];
        const caseA =
          arePropositionsEqual(cond1.left, p) &&
          arePropositionsEqual(cond2.left, q) &&
          arePropositionsEqual(cond1.right, cond2.right);
        const caseB =
          arePropositionsEqual(cond1.left, q) &&
          arePropositionsEqual(cond2.left, p) &&
          arePropositionsEqual(cond1.right, cond2.right);
        if (caseA || caseB) {
          return cond1.right;
        }
        return null;
      }

      function isContradictory(newProp, allTrueProps) {
        for (const trueProp of allTrueProps) {
          if (
            trueProp.type === "negation" &&
            arePropositionsEqual(newProp, trueProp.proposition)
          )
            return true;
          if (
            newProp.type === "negation" &&
            arePropositionsEqual(newProp.proposition, trueProp)
          )
            return true;
        }
        if (newProp.type === "atomic" || newProp.type === "universal") {
          const predicatePairs = currentLang.contradictoryPredicates;
          let oppositePredicate = null;
          for (const key in predicatePairs) {
            if (key === newProp.predicate) {
              oppositePredicate = predicatePairs[key];
              break;
            }
            if (predicatePairs[key] === newProp.predicate) {
              oppositePredicate = key;
              break;
            }
          }
          if (oppositePredicate) {
            for (const trueProp of allTrueProps) {
              if (trueProp.type === newProp.type) {
                const sameSubject =
                  (newProp.type === "atomic" &&
                    trueProp.subject === newProp.subject) ||
                  (newProp.type === "universal" &&
                    trueProp.entity === newProp.entity);
                if (sameSubject && trueProp.predicate === oppositePredicate) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }

      function verifyAndExpandTruths(
        newProposition,
        initialTruths = internalTruthSet
      ) {
        let knownTruths = [...initialTruths];

        // 1. newPropositionì´ nullì´ ì•„ë‹ ê²½ìš°ì—ë§Œ ì´ˆê¸° ëª¨ìˆœ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
        if (newProposition && isContradictory(newProposition, knownTruths)) {
          return { success: false, expandedSet: null };
        }

        // 2. ëª¨ìˆœì´ ì—†ì„ ê²½ìš°, newPropositionì´ nullì´ ì•„ë‹ ê²½ìš°ì—ë§Œ ì§‘í•©ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        if (
          newProposition &&
          !knownTruths.some((p) => arePropositionsEqual(p, newProposition))
        ) {
          knownTruths.push(newProposition);
        }

        let newTruthsFoundInIteration = true;
        let iterations = 0;
        const maxIterations = 50; // ê¹Šì´ëŠ” 50ìœ¼ë¡œ ìœ ì§€

        // 2. ë” ì´ìƒ ìƒˆë¡œìš´ ê²°ë¡ ì´ ë‚˜ì˜¤ì§€ ì•Šì„ ë•Œê¹Œì§€ ëª¨ë“  ì¡°í•©ì„ ë°˜ë³µì ìœ¼ë¡œ ê²€ì‚¬í•©ë‹ˆë‹¤.
        while (newTruthsFoundInIteration && iterations < maxIterations) {
          newTruthsFoundInIteration = false;
          iterations++;

          const currentSnapshot = [...knownTruths]; // í˜„ì¬ê¹Œì§€ ì•Œë ¤ì§„ ëª¨ë“  ì§„ì‹¤ì˜ ìŠ¤ëƒ…ìƒ·

          // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: ê¸°ì¡´ì˜ ëª¨ë“  ëª…ì œë“¤ë¼ë¦¬ ì„œë¡œ ë¹„êµí•˜ëŠ” ì™„ì „ íƒìƒ‰ (N x N)
          for (let i = 0; i < currentSnapshot.length; i++) {
            const p1 = currentSnapshot[i];

            // 1ê°œì˜ ì „ì œë§Œ í•„ìš”í•œ ê·œì¹™ë“¤ì„ ë¨¼ì € ì ìš©í•©ë‹ˆë‹¤.
            const onePremiseRules = [
              doubleNegationElimination,
              conjunctionElimination,
              existentialInstantiation,
            ];
            for (const rule of onePremiseRules) {
              const results = rule(p1);
              if (results) {
                const resultArray = Array.isArray(results)
                  ? results
                  : [results];
                for (const result of resultArray) {
                  if (isContradictory(result, knownTruths))
                    return { success: false, expandedSet: null };
                  if (
                    !knownTruths.some((p) => arePropositionsEqual(p, result))
                  ) {
                    knownTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }

            // 2ê°œì˜ ì „ì œê°€ í•„ìš”í•œ ê·œì¹™ë“¤ì„ ì ìš©í•©ë‹ˆë‹¤.
            for (let j = 0; j < currentSnapshot.length; j++) {
              if (i === j) continue;
              const p2 = currentSnapshot[j];
              const twoPremiseRules = [
                modusPonens,
                modusTollens,
                hypotheticalSyllogism,
                disjunctiveSyllogism,
                universalApplication,
              ];

              for (const rule of twoPremiseRules) {
                const result = rule(p1, p2);
                if (result) {
                  if (isContradictory(result, knownTruths))
                    return { success: false, expandedSet: null };
                  if (
                    !knownTruths.some((p) => arePropositionsEqual(p, result))
                  ) {
                    knownTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }
          }
        }

        return { success: true, expandedSet: knownTruths };
      }

      function isValidPlay(cardToPlay, proposition) {
        if (inTutorialMode) {
          const highlightedCard = document.querySelector(".tutorial-highlight");
          return (
            highlightedCard && highlightedCard.textContent === cardToPlay.text
          );
        }

        const propLength = proposition.length;
        const { if: ifKeyword, and, or, not } = currentLang.keywords;
        const isConnective = (card) => [ifKeyword, and, or].includes(card.text);
        const [properNoun, quantifier, entity, predicate, operator] =
          currentLang.cardTypes;

        if (propLength === 0) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const lastCardInfo = proposition[propLength - 1];

        if (cardToPlay.text === not) {
          // 'ëŠ” ê±°ì§“ì´ë‹¤'ê°€ ì ìš©ë  ì ˆ(clause)ì„ ì°¾ìŠµë‹ˆë‹¤.
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const clauseToNegate =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : [...proposition];
          const newClauseWithNegation = [
            ...clauseToNegate,
            { card: cardToPlay, player: currentPlayer },
          ];
          return parsePropositionFromCards(newClauseWithNegation) !== null;
        }

        if (isConnective(cardToPlay)) {
          if (proposition.some((info) => isConnective(info.card))) return false;
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const partToCheck =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : proposition;
          return parsePropositionFromCards(partToCheck) !== null;
        }

        if (isConnective(lastCardInfo.card)) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const connectiveIndex = proposition
          .map((info) => info.card)
          .findIndex(isConnective);
        const currentSimpleProp =
          connectiveIndex > -1
            ? proposition.slice(connectiveIndex + 1)
            : proposition;

        if (currentSimpleProp.length === 1) {
          const lastType = currentSimpleProp[0].card.type;
          if (lastType === properNoun) return cardToPlay.type === predicate;
          if (lastType === quantifier) return cardToPlay.type === entity;
        }
        if (currentSimpleProp.length === 2) {
          if (
            currentSimpleProp[0].card.type === quantifier &&
            currentSimpleProp[1].card.type === entity
          ) {
            return cardToPlay.type === predicate;
          }
        }
        return false;
      }

      function checkNextTurn() {
        if (gameIsOver || inTutorialMode) return; // ê²Œì„ì˜¤ë²„, íŠœí† ë¦¬ì–¼ ì¤‘ì—ëŠ” ì‹¤í–‰ ì•ˆ í•¨

        clearAllAITimeouts(); // ê¸°ì¡´ì— ì˜ˆì•½ëœ AI ë™ì‘ì´ ìˆë‹¤ë©´ ëª¨ë‘ ì·¨ì†Œ

        if (isThinkingTime) {
          // --- ì‚¬ìœ  ì‹œê°„ì¼ ë•Œì˜ í„´ ê´€ë¦¬ ---
          // í˜„ì¬ ìƒê°í•´ì•¼ í•  í”Œë ˆì´ì–´ê°€ AIë¼ë©´, AIì˜ ì‚¬ìœ  ì‹œê°„ í„´ì„ ì˜ˆì•½
          if (isPlayerAI[thinkingTimeTurn]) {
            aiTimeoutId = setTimeout(aiThinkingTimeTurn, 1500);
          }
          // ì‚¬ëŒì´ í„´ì´ë¼ë©´, ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šê³  ì‚¬ìš©ì ì…ë ¥ì„ ê¸°ë‹¤ë¦¼
        } else {
          // --- ì¼ë°˜ í„´ì¼ ë•Œì˜ í„´ ê´€ë¦¬ ---
          // í˜„ì¬ í„´ì˜ í”Œë ˆì´ì–´ê°€ AIë¼ë©´, AIì˜ ì¼ë°˜ í„´ì„ ì˜ˆì•½
          if (isPlayerAI[currentPlayer]) {
            const delay = gameMode === "AI_VS_AI" ? 250 : 1500;
            aiTimeoutId = setTimeout(aiTurn, delay);
          }
          // ì‚¬ëŒì´ í„´ì´ë¼ë©´, í–‰ë™ ê°€ëŠ¥ ì—¬ë¶€ë§Œ ì²´í¬ (í–‰ë™ ì—†ìœ¼ë©´ ì‚¬ìœ  ì‹œê°„ ì „í™˜)
          else {
            checkRoundEndConditions();
          }
        }
      }
      function endTurn() {
        // ì‚¬ìœ  ì‹œê°„ ì¤‘ì¼ ë•Œì˜ í„´ ì¢…ë£Œ ë¡œì§
        if (isThinkingTime) {
          audioManager.playSfx("end");
          // í•´ë‹¹ ë¼ìš´ë“œë¥¼ ë¨¼ì € ì‹œì‘í–ˆë˜ í”Œë ˆì´ì–´ (ì‚¬ìœ  ì‹œê°„ì—ëŠ” ë‘ ë²ˆì§¸ë¡œ í–‰ë™í•¨)
          const roundStarter = currentRound % 2 === 1 ? "A" : "B";

          // ì§€ê¸ˆ í„´ì„ ë§ˆì¹œ í”Œë ˆì´ì–´ê°€ 'ë‘ ë²ˆì§¸' ìˆœì„œë¼ë©´, ì‚¬ìœ  ì‹œê°„ì„ ì™„ì „íˆ ì¢…ë£Œí•©ë‹ˆë‹¤.
          if (thinkingTimeTurn === roundStarter) {
            endThinkingTime();
          } else {
            // 'ì²« ë²ˆì§¸' ìˆœì„œì˜ í”Œë ˆì´ì–´ë¼ë©´, í„´ì„ ìƒëŒ€ì—ê²Œ ë„˜ê¹ë‹ˆë‹¤.
            thinkingTimeTurn = roundStarter;

            if (gameMode === "AI" && thinkingTimeTurn === aiPlayer) {
              clearAllAITimeouts();
              aiTimeoutId = setTimeout(aiThinkingTimeTurn, 2000);
            }
            render();

            // âœ… [í•µì‹¬ ìˆ˜ì •]
            // ë‘ ë²ˆì§¸ AIì—ê²Œ í„´ì„ ë„˜ê²¼ìœ¼ë‹ˆ, í„´ ê´€ë¦¬ì(checkNextTurn)ë¥¼ í˜¸ì¶œí•´ì„œ
            // ë‘ ë²ˆì§¸ AIì˜ í„´ì„ ì‹¤ì œë¡œ ì‹œì‘ì‹œí‚µë‹ˆë‹¤.
            checkNextTurn();
          }
          return;
        }

        // --- ì´í•˜ ì¼ë°˜ í„´ ì¢…ë£Œ ë¡œì§ (ìˆ˜ì • ì—†ìŒ) ---
        if (cardsPlayedThisTurn[currentPlayer] === 0) return;

        audioManager.playSfx("end");

        const playerWhoEndedTurn = currentPlayer;
        cardsPlayedThisTurn[playerWhoEndedTurn] = 0;

        currentPlayer = currentPlayer === "A" ? "B" : "A";

        render();
        checkNextTurn();
      }

      function activateAbility(player) {
        if (inTutorialMode) {
          return; // íŠœí† ë¦¬ì–¼ ëª¨ë“œì—ì„œëŠ” ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šê³  ì¦‰ì‹œ í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.
        }
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;

        const state = abilityUsedState[player];
        if (state) {
          // í„ì˜ ê²½ìš° usedCountê°€ maxUses ì´ìƒì¸ì§€ í™•ì¸
          if (philosopherId === "hume" && state.usedCount >= state.maxUses) {
            showAlert(
              currentLang.langCode === "ko"
                ? "ì´ë¯¸ ëŠ¥ë ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
                : "Ability has already been used up."
            );
            return;
          }
          // ê·¸ ì™¸ ì² í•™ìëŠ” ê¸°ì¡´ ë°©ì‹ëŒ€ë¡œ used í”Œë˜ê·¸ í™•ì¸
          else if (philosopherId !== "hume" && state.used) {
            showAlert(
              currentLang.langCode === "ko"
                ? "ì´ë¯¸ ëŠ¥ë ¥ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
                : "Ability has already been used."
            );
            return;
          }
        }

        console.log(`Activating ability for ${philosopherId}`);
        switch (philosopherId) {
          case "plato":
            activatePlatoAbility(player); // ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
            break;
          case "socrates":
            activateSocratesAbility(player);
            break;
          case "descartes":
            activateDescartesAbility(player);
            break;
          case "wittgenstein":
            activateWittgensteinAbility(player);
            break;
          case "derrida":
            activateDerridaAbility(player);
            break;
          case "hume":
            activateHumeAbility(player);
            break;
          case "kuhn":
            activateKuhnAbility(player);
            break;
          case "kant":
            activateKantAbility(player);
            break;

          // ... ë‹¤ë¥¸ ëª¨ë“  ì² í•™ìë“¤ì˜ ëŠ¥ë ¥ í˜¸ì¶œ ...
          default:
            showAlert(
              currentLang.langCode === "ko"
                ? "ì´ ì² í•™ìëŠ” ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëŠ¥ë ¥ì´ ì—†ìŠµë‹ˆë‹¤."
                : "This philosopher has no active ability."
            );
        }
      }

      function updateAbilityButtonsState() {
        // í”Œë ˆì´ì–´ Aì˜ ëŠ¥ë ¥ ë²„íŠ¼ ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        const stateA = getAbilityButtonStateFor("A");
        const buttonA = document.getElementById("ability-a");
        buttonA.style.display = stateA.visible ? "block" : "none";
        buttonA.disabled = stateA.disabled;
        buttonA.textContent = stateA.text;

        // í”Œë ˆì´ì–´ Bì˜ ëŠ¥ë ¥ ë²„íŠ¼ ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        const stateB = getAbilityButtonStateFor("B");
        const buttonB = document.getElementById("ability-b");
        buttonB.style.display = stateB.visible ? "block" : "none";
        buttonB.disabled = stateB.disabled;
        buttonB.textContent = stateB.text;
      }

      function getAbilityButtonStateFor(player) {
        // ê¸°ë³¸ê°’: ë²„íŠ¼ì€ ë³´ì´ì§€ ì•Šê³  ë¹„í™œì„±í™” ìƒíƒœ
        const defaultState = { visible: false, disabled: true, text: "" };

        // í˜„ì¬ ê²Œì„ì´ ì§„í–‰ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜, í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ì² í•™ì ì •ë³´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìƒíƒœ ë°˜í™˜
        if (
          gameIsOver ||
          (player === "A" && !playerA_Data) ||
          (player === "B" && !playerB_Data)
        ) {
          return defaultState;
        }

        const philosopherData = player === "A" ? playerA_Data : playerB_Data;
        const philosopherId = philosopherData.id;

        // í•´ë‹¹ ì² í•™ìì˜ ëŠ¥ë ¥ì´ ì´ë¯¸ ì‚¬ìš©ë˜ì—ˆë‹¤ë©´ ê¸°ë³¸ ìƒíƒœ ë°˜í™˜
        if (abilityUsedState[player] && abilityUsedState[player].used) {
          return defaultState;
        }

        // â­ ì•ìœ¼ë¡œ ëª¨ë“  ëŠ¥ë ¥ì˜ ì¡°ê±´ì€ ì´ switch ë¬¸ ì•ˆì— ì¶”ê°€ë©ë‹ˆë‹¤.
        switch (philosopherId) {
          case "plato":
            // ëŠ¥ë ¥ ì‚¬ìš© ì¡°ê±´: 'ì‚¬ìœ  ì‹œê°„'ì¼ ë•Œ í•­ìƒ ë²„íŠ¼ì„ í‘œì‹œ
            if (isThinkingTime) {
              return {
                visible: true,
                // ìê¸° í„´ì´ ì•„ë‹ ë•Œ(!==) ë¹„í™œì„±í™”(disabled: true)
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }

            break; // platocase ë

          case "socrates":
            // ì‚¬ìœ  ì‹œê°„ì´ê³ , ì‚¬ìš© íšŸìˆ˜ê°€ ë‚¨ì•„ìˆì„ ë•Œ ë²„íŠ¼ í‘œì‹œ
            if (
              isThinkingTime &&
              abilityUsedState[player].usedCount <
                abilityUsedState[player].maxUses
            ) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          case "nietzsche":
            // ë‹ˆì²´ì˜ ëŠ¥ë ¥ì€ íŒ¨ì‹œë¸Œì´ë¯€ë¡œ, í™œì„±í™” ë²„íŠ¼ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
            // ë”°ë¼ì„œ ì•„ë¬´ê²ƒë„ ë°˜í™˜í•˜ì§€ ì•Šê³  ê·¸ëƒ¥ break í•©ë‹ˆë‹¤.
            break;

          case "descartes":
            if (isThinkingTime) {
              return {
                visible: true,
                // ìì‹ ì˜ ì‚¬ìœ  ì‹œê°„ í„´ì´ ì•„ë‹ ê²½ìš° ë²„íŠ¼ì„ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤.
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          case "wittgenstein":
            if (isThinkingTime) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // ìì‹ ì˜ í„´ì¼ ë•Œë§Œ í™œì„±í™”
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          case "derrida":
            if (isThinkingTime) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // ìì‹ ì˜ í„´ì¼ ë•Œë§Œ í™œì„±í™”
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;
          case "hume":
            // ì‚¬ìœ  ì‹œê°„ì´ê³ , ì‚¬ìš© íšŸìˆ˜ê°€ ë‚¨ì•„ìˆì„ ë•Œ ë²„íŠ¼ í‘œì‹œ
            if (
              isThinkingTime &&
              abilityUsedState[player].usedCount <
                abilityUsedState[player].maxUses
            ) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // ìì‹ ì˜ í„´ì¼ ë•Œë§Œ í™œì„±í™”
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;
          case "kuhn":
            // í”Œë ˆì´ì–´ê°€ ì¹´ë“œë¥¼ ë†“ì•„ ìƒì„±í•œ ëª…ì œë§Œ ì¹´ìš´íŠ¸
            const userMadePropsCount = truePropositions.filter(
              (p) => p.type === "user-made"
            ).length;

            if (isThinkingTime && userMadePropsCount >= 15) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // ìì‹ ì˜ í„´ì¼ ë•Œë§Œ í™œì„±í™”
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;
          case "kant":
            // ì‚¬ìœ  ì‹œê°„ì´ê³ , ì•„ì§ ëŠ¥ë ¥ì„ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ì„ ë•Œ ë²„íŠ¼ í‘œì‹œ
            if (isThinkingTime && !abilityUsedState[player]?.used) {
              return {
                visible: true,
                // ìì‹ ì˜ í„´ì´ ì•„ë‹ˆë©´ ë¹„í™œì„±í™”
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          // --- ì—¬ê¸°ì— ìƒˆë¡œìš´ ì² í•™ìë“¤ì˜ caseë¥¼ ê³„ì† ì¶”ê°€ ---
          // case 'descartes':
          //     if (isThinkingTime && thinkingTimeTurn === player) { ... }
          //     break;
        }

        // ìœ„ switch ë¬¸ì—ì„œ ì•„ë¬´ ì¡°ê±´ë„ ë§ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
        return defaultState;
      }

      /**
       * ìƒëŒ€ë°©ì˜ ì†íŒ¨ë¥¼ ë¶„ì„í•˜ì—¬ ìœ„í˜‘ì ì¸ ì¹´ë“œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
       * @param {Array} opponentHand - ìƒëŒ€ë°©ì˜ ì¹´ë“œ ê°ì²´ ë°°ì—´.
       * @param {string} myCorePredicate - AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ì§ê²°ëœ í•µì‹¬ ì„œìˆ ì–´.
       * @param {object} langData - í˜„ì¬ ì–¸ì–´ ì„¤ì • ë°ì´í„° (TEXTS.ko ë˜ëŠ” TEXTS.en).
       * @returns {{hasNegation: boolean, hasContradictoryToMyWinCon: boolean}}
       * - hasNegation: ë¶€ì • ì¹´ë“œ('ëŠ” ê±°ì§“ì´ë‹¤') ì¡´ì¬ ì—¬ë¶€
       * - hasContradictoryToMyWinCon: AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ëª¨ìˆœë˜ëŠ” ì„œìˆ ì–´ ì¡´ì¬ ì—¬ë¶€
       */
      function analyzeOpponentThreats(opponentHand, myCorePredicate, langData) {
        const threats = {
          hasNegation: false,
          hasContradictoryToMyWinCon: false,
        };

        // AIì˜ í•µì‹¬ ì„œìˆ ì–´ì™€ ëª¨ìˆœë˜ëŠ” ì„œìˆ ì–´ ì°¾ê¸°
        let contradictoryPredicate = null;
        const predicatePairs = langData.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === myCorePredicate) {
            contradictoryPredicate = predicatePairs[key];
            break;
          }
          if (predicatePairs[key] === myCorePredicate) {
            contradictoryPredicate = key;
            break;
          }
        }

        // ìƒëŒ€ë°© ì†íŒ¨ ìˆœíšŒ
        for (const card of opponentHand) {
          // ë¶€ì • ì¹´ë“œ í™•ì¸
          if (card.text === langData.keywords.not) {
            threats.hasNegation = true;
          }
          // AI ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ëª¨ìˆœë˜ëŠ” ì„œìˆ ì–´ ì¹´ë“œ í™•ì¸
          if (
            card.type === langData.cardTypes[3] /* ì„œìˆ ì–´ or Predicate */ &&
            card.text === contradictoryPredicate
          ) {
            threats.hasContradictoryToMyWinCon = true;
          }
        }

        return threats;
      }

      /**
       * AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ì„ ë‹¬ì„±í•˜ê¸° ìœ„í•œ ëª¨ë“  ì ì¬ì  'ê³„íš'ì„ ìƒì„±í•˜ê³  ì ìˆ˜ë¥¼ ë§¤ê¸°ëŠ” í•¨ìˆ˜
       * @returns {object | null} ê°€ì¥ ì ìˆ˜ê°€ ë†’ì€ ìµœì ì˜ ê³„íš ê°ì²´ ë˜ëŠ” null
       */
      function generateAndScorePlans() {
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        if (!myVictoryData) return null;
        const goalPredicate = myVictoryData.core_goal.predicate;

        // 'ëª¨ë“  [ê°œì²´]ëŠ” ...' ì´ ì´ë¯¸ ì°¸ ëª…ì œ ëª©ë¡ì— ìˆëŠ” ê²½ìš°ë§Œ ì°¾ìŠµë‹ˆë‹¤.
        const allUniversalProps = internalTruthSet.filter(
          (p) => p.type === "universal"
        );
        if (allUniversalProps.length === 0) return null;

        // ì˜ˆ: 'ëª¨ë“  ê°œëŠ” ë™ë¬¼ì´ë‹¤'ê°€ ì°¸ì¼ ë•Œ, 'ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤'ë§Œ ë§Œë“¤ë©´ ì´ê¸¸ ìˆ˜ ìˆëŠ” ê³„íš
        for (const universalProp of allUniversalProps) {
          // ë§Œì•½ 'ëª¨ë“  [A]ëŠ” [ë‚˜ì˜ ìŠ¹ë¦¬ì„œìˆ ì–´]' í˜•íƒœì˜ ëª…ì œê°€ ì´ë¯¸ ìˆë‹¤ë©´,
          if (universalProp.predicate === goalPredicate) {
            const entityText = universalProp.entity; // ì˜ˆ: 'ê°œëŠ”'
            let predicateText; // ì„œìˆ ì–´ í…ìŠ¤íŠ¸ë¥¼ ë‹´ì„ ë³€ìˆ˜ ì„ ì–¸

            if (currentLang.langCode === "ko") {
              // í•œêµ­ì–´ ëª¨ë“œ: ê¸°ì¡´ ë¡œì§ì„ ìœ ì§€ (ì™„ë²½í•˜ì§„ ì•Šì§€ë§Œ ì˜ë„ëŠ” ë³´ì¡´)
              // "ê°œëŠ”" -> "ê°œì´ë‹¤"
              predicateText = entityText.replace(/ëŠ”$/, "ì´ë‹¤");
            } else {
              // ì˜ì–´ ëª¨ë“œ: ìƒˆë¡œìš´ ë³€í™˜ ê·œì¹™ ì ìš©
              // "dog" -> "is a dog"
              predicateText = "is a " + entityText;
            }

            // ì™„ì„±ëœ ì„œìˆ ì–´ë¥¼ ì‚¬ìš©í•´ ìµœì¢… ëª…ì œë¥¼ êµ¬ì„±
            const neededPropText = `${myVictoryData.core_goal.subject} ${predicateText}`;
            const neededProp = parsePropositionFromString(neededPropText);

            // ê·¸ ëª…ì œê°€ ì•„ì§ ì°¸ì´ ì•„ë‹ˆë¼ë©´, ì´ê²ƒì„ ìµœìš°ì„  ê³„íšìœ¼ë¡œ ì‚¼ìŠµë‹ˆë‹¤.
            if (
              neededProp &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, neededProp))
            ) {
              return {
                name: `FINISH_HIM_${entityText}`,
                score: 9000, // ì••ë„ì ì¸ ì ìˆ˜
                // ì‹¤í–‰ ë¡œì§ì€ aiTurnì—ì„œ ì§ì ‘ ì²˜ë¦¬í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ëª©í‘œë§Œ ì œì‹œ
                targetPropositionText: neededPropText,
              };
            }
          }
        }
        return null;
      }
      function aiThinkingTimeTurn() {
        const summaryActions = []; // ì´ë²ˆ í„´ì— AIê°€ ìˆ˜í–‰í•œ ëª¨ë“  í–‰ë™ì„ ê¸°ë¡
        const aiPhilosopherData =
          thinkingTimeTurn === "A" ? playerA_Data : playerB_Data;
        const philosopherId = aiPhilosopherData.id;

        // 1ë‹¨ê³„: ìƒˆë¡œìš´ ì •ë¦¬ ë„ì¶œ ì‹œë„
        const candidateTheorems = generateCandidateTheorems();
        if (candidateTheorems.length > 0) {
          const scoredTheorems = scoreCandidateTheorems(candidateTheorems);
          const theoremActions = executeTheoremDerivation(scoredTheorems);
          if (theoremActions.length > 0) {
            summaryActions.push(...theoremActions);
          }
        }

        // --- 2ë‹¨ê³„: ëŠ¥ë ¥ ì‚¬ìš© ë¡œì§ (ìˆ˜ì •ëœ ë¶€ë¶„) ---

        // í”Œë¼í†¤ ëŠ¥ë ¥ ì²´í¬ (ë‹¨ì¼ ì‚¬ìš©)
        if (philosopherId === "plato") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // ğŸ‘ˆ ìˆ˜ì •
            const abilityAction = executePlatoAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }

        // ì†Œí¬ë¼í…ŒìŠ¤ ëŠ¥ë ¥ ì²´í¬ (ë‹¤ì¤‘ ì‚¬ìš©)
        if (philosopherId === "socrates") {
          while (
            abilityUsedState[thinkingTimeTurn] && // ğŸ‘ˆ ìˆ˜ì •
            abilityUsedState[thinkingTimeTurn].usedCount < // ğŸ‘ˆ ìˆ˜ì •
              abilityUsedState[thinkingTimeTurn].maxUses // ğŸ‘ˆ ìˆ˜ì •
          ) {
            const abilityAction = executeSocratesAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            } else {
              break;
            }
          }
        }

        // ë°ì¹´ë¥´íŠ¸ ëŠ¥ë ¥ ì²´í¬ (ë‹¨ì¼ ì‚¬ìš©)
        if (philosopherId === "descartes") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // ğŸ‘ˆ ìˆ˜ì •
            const abilityAction =
              executeDescartesAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        // í„ ëŠ¥ë ¥ ì²´í¬ (2íšŒ ì‚¬ìš©)
        if (philosopherId === "hume") {
          while (
            abilityUsedState[thinkingTimeTurn] && // ğŸ‘ˆ ìˆ˜ì •
            abilityUsedState[thinkingTimeTurn].usedCount < // ğŸ‘ˆ ìˆ˜ì •
              abilityUsedState[thinkingTimeTurn].maxUses // ğŸ‘ˆ ìˆ˜ì •
          ) {
            const abilityAction = executeHumeAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            } else {
              break;
            }
          }
        }
        if (philosopherId === "wittgenstein") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // ğŸ‘ˆ ìˆ˜ì •
            const abilityAction =
              executeWittgensteinAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        if (philosopherId === "kuhn") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // ğŸ‘ˆ ìˆ˜ì •
            const abilityAction = executeKuhnAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        // ë°ë¦¬ë‹¤ ëŠ¥ë ¥ ì²´í¬ (ë‹¨ì¼ ì‚¬ìš©)
        if (philosopherId === "derrida") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // ğŸ‘ˆ ìˆ˜ì •
            const abilityAction = executeDerridaAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        if (philosopherId === "kant") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // ğŸ‘ˆ ìˆ˜ì •
            const kantAction = executeKantAbilityCheck(thinkingTimeTurn);
            if (kantAction) {
              summaryActions.push(kantAction);
            }
          }
        }

        // ... ì—¬ê¸°ì— ë‹¤ë¥¸ ì² í•™ìë“¤ì˜ ëŠ¥ë ¥ ì²´í¬ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥ ...

        // 3ë‹¨ê³„: ìµœì¢…ì ìœ¼ë¡œ ê²Œì„ ìƒíƒœë¥¼ ë Œë”ë§í•˜ê³  í„´ì„ ë„˜ê¹€
        render();

        if (summaryActions.length > 0) {
          if (gameMode === "AI_VS_AI") {
            endTurn();
          } else {
            showAITurnSummary(summaryActions);
          }
        } else {
          console.log("AI found no valuable actions. Passing turn.");
          endTurn();
        }
      }
      function generateCandidateTheorems() {
        const knownTruths = [...internalTruthSet];
        const candidates = new Map(); // Mapì„ ì‚¬ìš©í•´ ì´ë²ˆ í„´ì— ì¤‘ë³µ ìƒì„±ë˜ëŠ” ê²ƒë§Œ ë§‰ìŠµë‹ˆë‹¤.

        // í›„ë³´ ëª©ë¡ì— 'ìƒˆë¡œìš´' ì •ë¦¬ë§Œ ì¶”ê°€í•˜ë˜ ê¸°ì¡´ ë¡œì§ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
        const addCandidate = (prop) => {
          // 1. ìœ íš¨í•œ ëª…ì œì¸ì§€, ê·¸ë¦¬ê³  ì´ë²ˆ í„´ì—ì„œ ì´ë¯¸ ìƒì„±ëœ í›„ë³´ê°€ ì•„ë‹Œì§€ í™•ì¸
          if (prop) {
            const propText = propositionToNaturalText(prop);
            if (candidates.has(propText)) {
              return; // ì´ë¯¸ ì´ë²ˆ í„´ì— ê³ ë ¤ëœ í›„ë³´ì´ë¯€ë¡œ ì¤‘ë‹¨
            }

            // 2. ì´ë¯¸ ê²Œì„ì˜ 'ì°¸ ëª…ì œ ëª©ë¡'ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸ (í•µì‹¬ ìˆ˜ì •)
            const isAlreadyKnown = truePropositions.some(
              (p) => p.proposition && arePropositionsEqual(p.proposition, prop)
            );
            // 3. ì•„ì§ ì•Œë ¤ì§€ì§€ ì•Šì€ ìƒˆë¡œìš´ ëª…ì œì¼ ê²½ìš°ì—ë§Œ í›„ë³´ë¡œ ì¶”ê°€
            if (!isAlreadyKnown) {
              candidates.set(propText, prop);
            }
          }
        };

        // --- ì´í•˜ ëª¨ë“  ì¶”ë¡  ê·œì¹™ ì ìš© ë¡œì§ì€ ê¸°ì¡´ê³¼ ë™ì¼í•©ë‹ˆë‹¤. ---

        // 1ê°œì˜ ì „ì œê°€ í•„ìš”í•œ ê·œì¹™ë“¤
        for (const p1 of knownTruths) {
          const onePremiseRules = [
            doubleNegationElimination,
            conjunctionElimination,
            existentialInstantiation,
          ];
          for (const rule of onePremiseRules) {
            const results = rule(p1);
            if (results) {
              const resultArray = Array.isArray(results) ? results : [results];
              resultArray.forEach(addCandidate);
            }
          }
        }

        // 2ê°œì˜ ì „ì œê°€ í•„ìš”í•œ ê·œì¹™ë“¤
        for (let i = 0; i < knownTruths.length; i++) {
          for (let j = 0; j < knownTruths.length; j++) {
            if (i === j) continue;
            const p1 = knownTruths[i];
            const p2 = knownTruths[j];
            const twoPremiseRules = [
              modusPonens,
              modusTollens,
              hypotheticalSyllogism,
              disjunctiveSyllogism,
              universalApplication,
            ];
            for (const rule of twoPremiseRules) {
              const result = rule(p1, p2);
              addCandidate(result);
            }
          }
        }

        // 3ê°œì˜ ì „ì œê°€ í•„ìš”í•œ ê·œì¹™ (ê²½ìš° ë…¼ì¦)
        const disjunctions = knownTruths.filter(
          (p) => p.type === "disjunction"
        );
        const conditionals = knownTruths.filter(
          (p) => p.type === "conditional"
        );

        if (disjunctions.length > 0 && conditionals.length >= 2) {
          for (const dis of disjunctions) {
            for (let i = 0; i < conditionals.length; i++) {
              for (let j = i + 1; j < conditionals.length; j++) {
                const result = proofByCases(
                  dis,
                  conditionals[i],
                  conditionals[j]
                );
                addCandidate(result);
              }
            }
          }
        }

        console.log(
          "Generated Candidate Theorems:",
          Array.from(candidates.values()).map((p) =>
            propositionToNaturalText(p)
          )
        );
        return Array.from(candidates.values());
      }

      function scoreCandidateTheorems(candidates) {
        const opponentPlayer = thinkingTimeTurn === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === thinkingTimeTurn
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryData || !opponentVictoryData) return [];

        const myCoreGoal = myVictoryData.core_goal;
        const myUltimateGoal = myVictoryData.ultimate_target;

        const opponentCoreGoal = opponentVictoryData.core_goal;
        const opponentUltimateGoal = opponentVictoryData.ultimate_target;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentUltimateGoal,
        };

        const opponentDefeatPredicate =
          currentLang.contradictoryPredicates[opponentCoreGoal.predicate] ||
          Object.keys(currentLang.contradictoryPredicates).find(
            (key) =>
              currentLang.contradictoryPredicates[key] ===
              opponentCoreGoal.predicate
          );

        const scored = candidates.map((candidate) => {
          let score = 10;

          if (arePropositionsEqual(candidate, myUltimateGoal)) score += 1000000;
          if (arePropositionsEqual(candidate, opponentLossCondition))
            score += 1000000;

          if (arePropositionsEqual(candidate, opponentUltimateGoal))
            score -= 500000;

          if (arePropositionsEqual(candidate, myCoreGoal)) score += 500;
          if (arePropositionsEqual(candidate, opponentCoreGoal)) score -= 1000;

          if (candidate.type === "universal") {
            if (candidate.predicate === myCoreGoal.predicate) {
              score += 200;
            }
            if (
              opponentDefeatPredicate &&
              candidate.predicate === opponentDefeatPredicate
            ) {
              score += 200;
            }
            if (candidate.predicate === opponentCoreGoal.predicate) {
              score -= 400;
            }
          } else if (candidate.type === "existential") {
            if (candidate.predicate === myCoreGoal.predicate) {
              score += 200;
            }
            if (
              opponentDefeatPredicate &&
              candidate.predicate === opponentDefeatPredicate
            ) {
              score += 200;
            }
            if (candidate.predicate === opponentCoreGoal.predicate) {
              score -= 400;
            }
          }

          const simulatedTruths = [...internalTruthSet, candidate];
          if (aiFindProof(opponentUltimateGoal, simulatedTruths)) {
            score -= 2000;
          }

          return { proposition: candidate, score: score };
        });

        scored.sort((a, b) => b.score - a.score);
        console.log("Scored Theorems:", scored);
        return scored;
      }
      function executeTheoremDerivation(scoredTheorems) {
        const MINIMUM_SCORE_THRESHOLD = 50;
        const actions = [];
        const addedThisTurn = [];

        for (const scoredTheorem of scoredTheorems) {
          if (scoredTheorem.score >= MINIMUM_SCORE_THRESHOLD) {
            const candidateProp = scoredTheorem.proposition;
            const isDuplicateThisTurn = addedThisTurn.some((p) =>
              arePropositionsEqual(p, candidateProp)
            );
            if (isDuplicateThisTurn) {
              continue;
            }

            actions.push({ type: "theorem", proposition: candidateProp });
            truePropositions.push({
              propId: `prop_${Date.now()}_${Math.random()}`,
              type: "theorem",
              round: currentRound,
              proposition: candidateProp,
            });
            addedThisTurn.push(candidateProp);
          }
        }
        return actions; // ì‹¤í–‰í•œ í–‰ë™ ëª©ë¡ì„ ë°˜í™˜
      }
      function showAITurnSummary(actions) {
        const modal = document.getElementById("ai-turn-summary-modal");
        const titleEl = document.getElementById("ai-summary-title");
        const contentEl = document.getElementById("ai-summary-content");
        const okBtn = document.getElementById("ai-summary-ok-btn");

        // ëª¨ë‹¬ ë‚´ìš© ì´ˆê¸°í™”
        contentEl.innerHTML = "";
        okBtn.textContent = currentLang.ui.okButton;

        // ì œëª© ì„¤ì •
        titleEl.textContent = currentLang.ui.aiSummaryTitleDefault; // ê¸°ë³¸ ì œëª©

        // í–‰ë™ ë‚´ì—­ì— ë”°ë¼ ë‚´ìš© ì±„ìš°ê¸° (í™•ì¥ì„± ê³ ë ¤)
        actions.forEach((action) => {
          const p = document.createElement("p");
          switch (action.type) {
            case "theorem":
              titleEl.textContent = currentLang.ui.aiSummaryTitleTheorem;
              p.innerHTML = `<strong>${
                currentLang.ui.theoremLabel
              }</strong> ${propositionToNaturalText(action.proposition)}`;
              break;
            case "ability":
              titleEl.textContent = currentLang.ui.aiSummaryTitleAbility;
              p.innerHTML = `<strong>${currentLang.ui.abilityLabel}</strong> ${action.description}`;
              break;
            // í–¥í›„ ë‹¤ë¥¸ í–‰ë™ ìœ í˜• ì¶”ê°€ ê°€ëŠ¥
          }
          contentEl.appendChild(p);
        });

        // í™•ì¸ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ì„¤ì • (ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±° í›„ ìƒˆë¡œ ì¶”ê°€)
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);

        newOkBtn.addEventListener("click", () => {
          modal.classList.remove("visible");
          // â˜…â˜…â˜… ì¤‘ìš”: ëª¨ë‹¬ì„ ë‹«ì€ í›„ì— í„´ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.
          endTurn();
        });

        modal.classList.add("visible");
      }

      function isBoardDangerous(opponentVictoryData) {
        if (currentProposition.length === 0) return null;
        const parsedProp = parsePropositionFromCards(currentProposition);
        if (!parsedProp || !opponentVictoryData) return null;

        // ìœ„í˜‘ ìœ í˜• 1: ìƒëŒ€ì˜ í•µì‹¬ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ 'ì§ì ‘ ì¼ì¹˜'í•˜ëŠ” ê²½ìš°
        if (arePropositionsEqual(parsedProp, opponentVictoryData.core_goal)) {
          console.log("Threat Detected (Type 1: Direct Match)");
          return parsedProp;
        }

        // ìœ„í˜‘ ìœ í˜• 2: ì´ ëª…ì œë¥¼ ì°¸ìœ¼ë¡œ ì¸ì •í•  ê²½ìš°, ìƒëŒ€ì˜ ìŠ¹ë¦¬ê°€ 'ì¶”ë¡  ê°€ëŠ¥'í•´ì§€ëŠ” ê²½ìš°
        const simulatedTruths = [...internalTruthSet, parsedProp];
        if (aiFindProof(opponentVictoryData.ultimate_target, simulatedTruths)) {
          console.log("Threat Detected (Type 2: Inferred Defeat)");
          return parsedProp;
        }

        return null;
      }

      function isBoardCompletable() {
        // ëª…ì œíŒì— ì¹´ë“œê°€ ì—†ìœ¼ë©´ ì™„ì„± ë¶ˆê°€ëŠ¥
        if (currentProposition.length === 0) return false;
        // AI ìì‹ ì´ ë§ˆì§€ë§‰ ì¹´ë“œë¥¼ ëƒˆë‹¤ë©´ ì™„ì„± ë¶ˆê°€ëŠ¥ (ìƒëŒ€ í„´ì—ë§Œ ì™„ì„± ê°€ëŠ¥)
        if (lastCardPlayer === aiPlayer) return false;

        // ë¬¸ë²•ì ìœ¼ë¡œ ì™„ì„± ê°€ëŠ¥í•œ ëª…ì œì¸ì§€ í™•ì¸
        const parsedProp = parsePropositionFromCards(currentProposition);
        return parsedProp !== null;
      }

      function assessOpponentAdvantage(proposition, opponentVictoryData) {
        if (!proposition || !opponentVictoryData) return 0;

        // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: í‰ê°€ ì „ì— ëª…ì œë¥¼ ì •ê·œí™”í•©ë‹ˆë‹¤. â˜…â˜…â˜…
        const normalizedProp = normalizeProposition(proposition);

        let penalty = 0;
        const opponentCoreGoal = opponentVictoryData.core_goal;
        const opponentSubject = opponentCoreGoal.subject;
        const opponentPredicate = opponentCoreGoal.predicate;

        if (normalizedProp.type === "atomic") {
          if (
            normalizedProp.subject === opponentSubject &&
            normalizedProp.predicate === opponentPredicate
          ) {
            penalty += 1500;
          }
        } else if (
          normalizedProp.type === "existential" ||
          normalizedProp.type === "universal"
        ) {
          if (normalizedProp.predicate === opponentPredicate) {
            penalty += normalizedProp.type === "universal" ? 3000 : 1800;
          }
        }
        return penalty;
      }
      function aiCanActuallyComplete() {
        if (!isBoardCompletable()) return false;

        const propToComplete = parsePropositionFromCards(currentProposition);
        if (!propToComplete) return false;

        const aiPhilosopherId =
          currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
        if (aiPhilosopherId !== "nietzsche") {
          const isAxiom = parsedAxioms.some((a) =>
            arePropositionsEqual(a.proposition, propToComplete)
          );
          const isAlreadyProven = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, propToComplete)
          );
          if (isAxiom || isAlreadyProven) {
            return false;
          }
        }

        // ëª¨ìˆœ ê²€ì‚¬ëŠ” ë‹ˆì²´ë¥¼ í¬í•¨í•œ ëª¨ë“  ì² í•™ìì—ê²Œ ë™ì¼í•˜ê²Œ ì ìš©ë©ë‹ˆë‹¤.
        const verificationResult = verifyAndExpandTruths(propToComplete);
        return verificationResult.success;
      }

      function isImmediateWinSecure(opponentHand, aiHand, langData) {
        const {
          if: ifKeyword,
          or: orKeyword,
          not: notKeyword,
        } = langData.keywords;

        // ì¡°ê±´ 1: ìƒëŒ€ í•¸ë“œì— 'ë¼ë©´' ë˜ëŠ” 'ë˜ëŠ”' ì¹´ë“œê°€ ìˆì–´ì„œ ëª…ì œë¥¼ ì´ì–´ê°ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
        const opponentCanExtend = opponentHand.some(
          (card) => card.text === ifKeyword || card.text === orKeyword
        );

        if (opponentCanExtend) {
          // ìƒëŒ€ê°€ ëª…ì œë¥¼ ì—°ì¥í•˜ì—¬ í„´ì„ ë„˜ê¸¸ ìˆ˜ ìˆë‹¤ë©´, ì¦‰ì‹œ ìŠ¹ë¦¬ê°€ ì•„ë‹˜
          return false;
        }

        // ì¡°ê±´ 2: ìƒëŒ€ì˜ ë¶€ì • ì¹´ë“œ('ëŠ” ê±°ì§“ì´ë‹¤') ë³´ìœ  ì—¬ë¶€ í™•ì¸
        const opponentHasNot = opponentHand.some(
          (card) => card.text === notKeyword
        );

        if (!opponentHasNot) {
          // ìƒëŒ€ì—ê²Œ ë¶€ì • ì¹´ë“œê°€ ì—†ìœ¼ë©´, ë‚´ ìŠ¹ë¦¬ë¥¼ ë§‰ì„ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì•ˆì „í•¨
          return true;
        } else {
          // ìƒëŒ€ì—ê²Œ ë¶€ì • ì¹´ë“œê°€ ìˆë‹¤ë©´, ë‚˜ì—ê²Œë„ ë¶€ì • ì¹´ë“œê°€ ìˆì–´ì•¼ë§Œ ì•ˆì „í•¨
          // (ìƒëŒ€ì˜ ë¶€ì •ì„ ë‚˜ì˜ ì´ì¤‘ ë¶€ì •ìœ¼ë¡œ ë˜ë°›ì•„ì¹  ìˆ˜ ìˆê¸° ë•Œë¬¸)
          const aiHasNot = aiHand.some((card) => card.text === notKeyword);
          return aiHasNot;
        }
      }

      function checkForGuaranteedWinMove() {
        // 1. ê¸°ë³¸ ì¡°ê±´ í™•ì¸: ëª…ì œíŒì— ì¹´ë“œê°€ 2ì¥ ì´ìƒ ìˆì–´ì•¼ í•¨
        if (currentProposition.length < 2) {
          return null;
        }

        const propLength = currentProposition.length;
        const lastCardInfo = currentProposition[propLength - 1];
        const secondLastCardInfo = currentProposition[propLength - 2];

        // 2. 'ëŠ” ê±°ì§“ì´ë‹¤' ì¹´ë“œ ë³´ìœ  ìƒí™© ëŒ€ì¹­ì„± í™•ì¸
        const { not: notKeyword } = currentLang.keywords;
        const aiHand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const opponentHand =
          currentPlayer === "A" ? playerB_Hand : playerA_Hand;

        const aiHasNot = aiHand.some((card) => card.text === notKeyword);
        const opponentHasNot = opponentHand.some(
          (card) => card.text === notKeyword
        );

        if (aiHasNot !== opponentHasNot) {
          return null;
        }

        // 3. ë§ˆì§€ë§‰ ì¹´ë“œê°€ 'ë‚˜' ë˜ëŠ” 'ìƒëŒ€'ì˜ ì´ë¦„(ê³ ìœ ëª…ì‚¬)ì¸ì§€ í™•ì¸
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner !== currentPlayer
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        const mySubject = myVictoryData.core_goal.subject;
        const opponentSubject = opponentVictoryData.core_goal.subject;

        if (
          lastCardInfo.card.type !==
            (currentLang.langCode === "ko" ? "ê³ ìœ ëª…ì‚¬" : "Proper Noun") ||
          (lastCardInfo.card.text !== mySubject &&
            lastCardInfo.card.text !== opponentSubject)
        ) {
          return null;
        }

        // 4. 3ê°€ì§€ íŒ¨í„´ í™•ì¸
        const {
          and: andKeyword,
          if: ifKeyword,
          or: orKeyword,
        } = currentLang.keywords;
        let isWinningOpportunity = false;

        // íŒ¨í„´ 1: ... ê·¸ë¦¬ê³  [ì´ë¦„]
        if (secondLastCardInfo.card.text === andKeyword) {
          isWinningOpportunity = true;
        } else {
          const firstPartCards = currentProposition.slice(0, propLength - 2);
          const parsedFirstPart = parsePropositionFromCards(firstPartCards);

          if (parsedFirstPart) {
            // íŒ¨í„´ 2: (ì°¸ì¸ ëª…ì œ) ë¼ë©´ [ì´ë¦„]
            if (
              secondLastCardInfo.card.text === ifKeyword &&
              aiFindProof(parsedFirstPart, internalTruthSet)
            ) {
              isWinningOpportunity = true;
            }
            // íŒ¨í„´ 3: (ê±°ì§“ì¸ ëª…ì œ) ë˜ëŠ” [ì´ë¦„]
            else if (secondLastCardInfo.card.text === orKeyword) {
              const negationOfFirstPart = {
                type: "negation",
                proposition: parsedFirstPart,
              };
              if (aiFindProof(negationOfFirstPart, internalTruthSet)) {
                isWinningOpportunity = true;
              }
            }
          }
        }

        // 5. ê¸°íšŒê°€ ë§ë‹¤ë©´, ìƒí™©ì— ë§ëŠ” ì˜¬ë°”ë¥¸ ìˆ ì–´ ì¹´ë“œë¥¼ ì°¾ì•„ ë°˜í™˜
        if (isWinningOpportunity) {
          const nameOnBoard = lastCardInfo.card.text;
          const myName = myVictoryData.core_goal.subject;
          let predicateToPlay = null;

          // Case 1: ëª…ì œíŒì˜ ì´ë¦„ì´ ë‚´ ì´ë¦„ì¼ ê²½ìš°
          if (nameOnBoard === myName) {
            // ë‚˜ì˜ ìŠ¹ë¦¬ ìˆ ì–´ë¥¼ ì°¾ëŠ”ë‹¤.
            predicateToPlay = myVictoryData.core_goal.predicate;
            console.log(
              `[AI Logic] Pattern matched with my name. Seeking predicate: ${predicateToPlay}`
            );
          }
          // Case 2: ëª…ì œíŒì˜ ì´ë¦„ì´ ìƒëŒ€ ì´ë¦„ì¼ ê²½ìš°
          else {
            // ìƒëŒ€ì˜ ìŠ¹ë¦¬ ìˆ ì–´ì™€ 'ë°˜ëŒ€'ë˜ëŠ” ìˆ ì–´ë¥¼ ì°¾ëŠ”ë‹¤.
            const opponentWinPredicate =
              opponentVictoryData.core_goal.predicate;
            const predicatePairs = currentLang.contradictoryPredicates;

            predicateToPlay =
              predicatePairs[opponentWinPredicate] ||
              Object.keys(predicatePairs).find(
                (key) => predicatePairs[key] === opponentWinPredicate
              );
            console.log(
              `[AI Logic] Pattern matched with opponent's name. Seeking contradictory predicate: ${predicateToPlay}`
            );
          }

          // ì°¾ì•„ë‚¸ ìˆ ì–´ ì¹´ë“œê°€ ë‚´ ì†ì— ìˆëŠ”ì§€ í™•ì¸í•˜ê³ , ìˆë‹¤ë©´ ê·¸ ì¹´ë“œë¥¼ ë°˜í™˜í•œë‹¤.
          if (predicateToPlay) {
            const winningMove = aiHand.find(
              (card) => card.text === predicateToPlay
            );

            if (winningMove && isValidPlay(winningMove, currentProposition)) {
              console.log("í™•ì • ìŠ¹ë¦¬ íŒ¨í„´ ë°œê²¬! ìŠ¹ë¦¬ ìˆ˜ë¥¼ ë‘¡ë‹ˆë‹¤.");
              return winningMove;
            }
          }
        }

        return null; // ì¡°ê±´ì— ë§ì§€ ì•Šìœ¼ë©´ null ë°˜í™˜
      }

      function scorePlans(plans, aiHand) {
        const aiHandTexts = aiHand.map((c) => c.text);

        const scored = plans.map((plan) => {
          let score = 500; // ê³„íšì´ ì¡´ì¬ ìì²´ë¡œ ê¸°ë³¸ ì ìˆ˜ íšë“

          // 1. ê³„íšì˜ ë‹¨ê³„ê°€ ì§§ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜ë¥¼ ë¶€ì—¬í•©ë‹ˆë‹¤. (ë‹¨ê³„ë‹¹ 200ì  ê°ì )
          score -= plan.steps.length * 200;

          // 2. ê³„íšì˜ ìµœì¢… ë‹¨ê³„ë¥¼ ì†íŒ¨ì˜ ì¹´ë“œë¡œ ì™„ì„±í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
          const finalStep = plan.steps[plan.steps.length - 1];
          const finalStepText = propositionToNaturalText(finalStep);
          const cardsNeeded = finalStepText.split(" ");

          const canMakeFinalStep = cardsNeeded.every((cardText) =>
            aiHandTexts.includes(cardText)
          );

          if (canMakeFinalStep) {
            // ìµœì¢… ë‹¨ê³„ë¥¼ ì™„ì„±í•  ì¹´ë“œë¥¼ ëª¨ë‘ ë“¤ê³  ìˆë‹¤ë©´ ë§¤ìš° ë†’ì€ ë³´ë„ˆìŠ¤ë¥¼ ë¶€ì—¬í•©ë‹ˆë‹¤.
            score += 1000;
          } else {
            // ê³„íšì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ë¥¼ ì™„ì„±í•  ìˆ˜ ì—†ë‹¤ë©´, ì´ ê³„íšì€ í˜„ì¬ ì‹¤í–‰ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
            // ì ìˆ˜ë¥¼ ë§¤ìš° ë‚®ê²Œ ì±…ì •í•˜ì—¬ ì„ íƒë˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
            score = -1;
          }

          // 3. í˜„ì¬ ëª…ì œíŒì˜ ìƒí™©ì„ ê³ ë ¤í•˜ì—¬ ì ìˆ˜ë¥¼ ê°€ê°í•©ë‹ˆë‹¤.
          const currentBoardText = currentProposition
            .map((info) => info.card.text)
            .join(" ");
          if (currentBoardText === "") {
            // ëª…ì œíŒì´ ë¹„ì–´ìˆë‹¤ë©´, ê³„íšì„ ë°”ë¡œ ì‹œì‘í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•½ê°„ì˜ ë³´ë„ˆìŠ¤ë¥¼ ì¤ë‹ˆë‹¤.
            score += 500;
          } else {
            // ëª…ì œíŒì— ì¹´ë“œê°€ ìˆì„ ë•Œ, ê·¸ ìœ„ì— ë°”ë¡œ ì´ì–´ê°ˆ ìˆ˜ ìˆëŠ” ê³„íšì´ë¼ë©´ ë†’ì€ ë³´ë„ˆìŠ¤ë¥¼ ì¤ë‹ˆë‹¤.
            if (finalStepText.startsWith(currentBoardText)) {
              score += 1000;
            }
          }

          plan.score = score;
          plan.targetPropositionText = finalStepText; // aiTurnì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í…ìŠ¤íŠ¸ ì €ì¥

          return plan;
        });

        // ì‹¤í–‰ ë¶ˆê°€ëŠ¥í•œ ê³„íš(ì ìˆ˜ -1)ì„ ê±¸ëŸ¬ëƒ…ë‹ˆë‹¤.
        return scored.filter((p) => p.score > 0);
      }

      function generateWinningPlan() {
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        if (!myVictoryData) return null;

        const myCoreGoal = myVictoryData.core_goal;
        let allPossiblePlans = [];
        findAllProofPaths(myCoreGoal, [], allPossiblePlans, 0);

        if (allPossiblePlans.length === 0) return null;

        // ê° ê³„íšì˜ ì ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        const scoredPlans = scorePlans(
          allPossiblePlans,
          currentPlayer === "A" ? playerA_Hand : playerB_Hand
        );

        if (scoredPlans.length === 0) return null;

        // ê°€ì¥ ì ìˆ˜ê°€ ë†’ì€ ê³„íšì„ ì„ íƒí•©ë‹ˆë‹¤.
        scoredPlans.sort((a, b) => b.score - a.score);
        return scoredPlans[0];
      }

      function findAllProofPaths(goal, path, allPlans, depth) {
        if (depth > 5) return; // íƒìƒ‰ ê¹Šì´ ì œí•œ

        // ê¸°ì € ì¡°ê±´ 1: ëª©í‘œê°€ ì´ë¯¸ ì°¸ìœ¼ë¡œ ì¦ëª…ë˜ì—ˆë‹¤ë©´, ì´ ê²½ë¡œëŠ” ì™„ì „í•œ ê³„íšì…ë‹ˆë‹¤.
        if (internalTruthSet.some((p) => arePropositionsEqual(p, goal))) {
          allPlans.push({ steps: [...path] }); // ë” ì´ìƒ í•˜ìœ„ ëª©í‘œê°€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
          return;
        }

        // ê¸°ì € ì¡°ê±´ 2: ëª©í‘œë¥¼ í˜„ì¬ ì†íŒ¨ì˜ ì¹´ë“œë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤ë©´, ê³„íšìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
        const cardsNeededForGoal = propositionToNaturalText(goal).split(" ");
        const aiHand = (
          currentPlayer === "A" ? playerA_Hand : playerB_Hand
        ).map((c) => c.text);
        if (cardsNeededForGoal.every((card) => aiHand.includes(card))) {
          allPlans.push({ steps: [...path, goal] });
          return;
        }

        // ìˆœí™˜ ê²½ë¡œ ë°©ì§€: í˜„ì¬ ì°¾ìœ¼ë ¤ëŠ” ëª©í‘œê°€ ì´ë¯¸ ê²½ë¡œì— ìˆë‹¤ë©´ íƒìƒ‰ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.
        if (path.some((p) => arePropositionsEqual(p, goal))) {
          return;
        }

        const newPath = [...path, goal]; // í˜„ì¬ ëª©í‘œë¥¼ ê²½ë¡œì— ì¶”ê°€í•©ë‹ˆë‹¤.

        // **ì¬ê·€ ë‹¨ê³„**: ë‹¤ì–‘í•œ ì¶”ë¡  ê·œì¹™ì„ ì—­ìœ¼ë¡œ ì ìš©í•˜ì—¬ í•˜ìœ„ ëª©í‘œë¥¼ ì°¾ìŠµë‹ˆë‹¤.

        // 1. ì „ê±´ ê¸ì •(Modus Ponens) ì—­ì¶”ì 
        const modusPonensBridges = internalTruthSet.filter(
          (p) => p.type === "conditional" && arePropositionsEqual(p.right, goal)
        );
        for (const bridge of modusPonensBridges) {
          const subGoal = bridge.left;
          findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
        }

        // 2. í›„ê±´ ë¶€ì •(Modus Tollens) ì—­ì¶”ì 
        if (goal.type === "negation") {
          const p = goal.proposition; // goal = ~p
          const modusTollensBridges = internalTruthSet.filter(
            (prop) =>
              prop.type === "conditional" && arePropositionsEqual(prop.left, p)
          );
          for (const bridge of modusTollensBridges) {
            const subGoal = { type: "negation", proposition: bridge.right }; // new sub-goal = ~q
            findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
          }
        }

        // 3. ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²•(Disjunctive Syllogism) ì—­ì¶”ì 
        const disjunctiveBridges = internalTruthSet.filter(
          (p) => p.type === "disjunction"
        );
        for (const bridge of disjunctiveBridges) {
          let subGoal = null;
          // (P âˆ¨ goal)ì„ ì°¾ì•˜ë‹¤ë©´, í•˜ìœ„ ëª©í‘œëŠ” ~P
          if (arePropositionsEqual(bridge.right, goal)) {
            subGoal = { type: "negation", proposition: bridge.left };
          }
          // (goal âˆ¨ P)ë¥¼ ì°¾ì•˜ë‹¤ë©´, í•˜ìœ„ ëª©í‘œëŠ” ~P
          else if (arePropositionsEqual(bridge.left, goal)) {
            subGoal = { type: "negation", proposition: bridge.right };
          }
          if (subGoal) {
            findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
          }
        }

        // 4. ë³´í¸ ì ìš©(Universal Application) ì—­ì¶”ì 
        if (goal.type === "atomic") {
          const universalBridges = internalTruthSet.filter(
            (p) => p.type === "universal" && p.predicate === goal.predicate
          );
          for (const bridge of universalBridges) {
            // ì˜ˆ: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤"ë¥¼ ì¦ëª…í•˜ê¸° ìœ„í•´ "ëª¨ë“  ì² í•™ìëŠ” ì§€í˜œë¡­ë‹¤"ë¥¼ ì°¾ìŒ
            // ìƒˆë¡œìš´ í•˜ìœ„ ëª©í‘œ: "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì² í•™ìì´ë‹¤"
            let newPredicateText;
            const entityText = bridge.entity;
            if (currentLang.langCode === "ko") {
              newPredicateText = entityText.slice(0, -1) + "ì´ë‹¤"; // 'ì² í•™ìëŠ”' -> 'ì² í•™ìì´ë‹¤'
            } else {
              newPredicateText = `is a ${entityText}`; // 'philosopher' -> 'is a philosopher'
            }
            const subGoal = {
              type: "atomic",
              subject: goal.subject,
              predicate: newPredicateText,
            };
            findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
          }
        }

        // 5. ì¡´ì¬í™”(Existential Instantiation) ì—­ì¶”ì 
        if (goal.type === "existential") {
          const subGoal = {
            type: "universal",
            entity: goal.entity,
            predicate: goal.predicate,
          };
          findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
        }

        // 6. ì´ì¤‘ ë¶€ì • ì œê±°(Double Negation) ì—­ì¶”ì 
        const doubleNegationSubGoal = {
          type: "negation",
          proposition: { type: "negation", proposition: goal },
        };
        findAllProofPaths(doubleNegationSubGoal, newPath, allPlans, depth + 1);
      }
      function assessSelfDisadvantage(proposition, myVictoryData) {
        if (!proposition || !myVictoryData) return 0;

        // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: í‰ê°€ ì „ì— ëª…ì œë¥¼ ì •ê·œí™”í•©ë‹ˆë‹¤. â˜…â˜…â˜…
        const normalizedProp = normalizeProposition(proposition);

        let penalty = 0;
        const myCoreGoal = myVictoryData.core_goal;
        const mySubject = myCoreGoal.subject;
        const myPredicate = myCoreGoal.predicate;

        const oppositePredicate =
          currentLang.contradictoryPredicates[myPredicate] ||
          Object.keys(currentLang.contradictoryPredicates).find(
            (key) => currentLang.contradictoryPredicates[key] === myPredicate
          );

        if (!oppositePredicate) return 0;

        if (normalizedProp.type === "atomic") {
          if (
            normalizedProp.subject === mySubject &&
            normalizedProp.predicate === oppositePredicate
          ) {
            penalty += 1500;
          }
        } else if (
          normalizedProp.type === "existential" ||
          normalizedProp.type === "universal"
        ) {
          if (normalizedProp.predicate === oppositePredicate) {
            penalty += normalizedProp.type === "universal" ? 3000 : 1800;
          }
        }
        return penalty;
      }
      function normalizeProposition(prop) {
        if (
          prop &&
          prop.type === "negation" &&
          prop.proposition.type === "negation"
        ) {
          // ~~P í˜•íƒœì´ë¯€ë¡œ, ì•ˆìª½ì˜ Pì— ëŒ€í•´ ë‹¤ì‹œ ì •ê·œí™”ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.
          return normalizeProposition(prop.proposition.proposition);
        }
        // ì´ì¤‘ ë¶€ì •ì´ ì•„ë‹ˆê±°ë‚˜, ë” ì´ìƒ ì œê±°í•  ì´ì¤‘ ë¶€ì •ì´ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
        return prop;
      }
      function aiTurn() {
        if (gameIsOver || isThinkingTime) return;

        // --- 1. ìƒˆë¡œìš´ ê°¬ë¹— ê³„íš ìˆ˜ë¦½ ë° ê¸°ì¡´ ê³„íš ìœ íš¨ì„± ê²€ì‚¬ ---
        activeGambitPlan = findBestGambitPlan(currentPlayer);
        if (activeGambitPlan) {
          console.log(
            `%c[AI GAMBIT] New Plan Adopted: ${
              activeGambitPlan.gambitName
            }. Goal: Prove '${propositionToNaturalText(
              activeGambitPlan.subGoal
            )}'`,
            "color: #8A2BE2; font-weight: bold;"
          );
        }

        console.log(
          `%c--- AI TURN DEBUG START (Round ${currentRound}, Player: ${currentPlayer}) ---`,
          "color: blue; font-weight: bold; font-size: 1.2em;"
        );
        console.log(
          "%c1. AI's Knowledge Base (internalTruthSet):",
          "color: green; font-weight: bold;"
        );
        console.log(internalTruthSet.map((p) => propositionToNaturalText(p)));
        console.log(
          "%c2. Proposition on Board to be Evaluated:",
          "color: green; font-weight: bold;"
        );
        console.log(currentProposition.map((c) => c.card.text).join(" "));

        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        const aiHand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const notKeyword = currentLang.keywords.not;
        const notCardInHand = aiHand.find((c) => c.text === notKeyword);

        if (notCardInHand && currentProposition.length > 0 && myVictoryData) {
          const propOnBoard = parsePropositionFromCards(currentProposition);
          if (propOnBoard && propOnBoard.type === "negation") {
            const newTruthFromDoubleNegation = propOnBoard.proposition;
            const hypotheticalTruths = [
              ...internalTruthSet,
              newTruthFromDoubleNegation,
            ];
            const myUltimateTarget = myVictoryData.ultimate_target;
            if (aiFindProof(myUltimateTarget, hypotheticalTruths)) {
              console.log(
                `%c[AI OVERRIDE] Derived Win via Double Negation DETECTED! Playing '${notKeyword}'`,
                "background: #ff0000; color: #ffffff; font-size: 1.3em;"
              );
              playCard(currentPlayer, notCardInHand);
              setTimeout(completeProposition, 250);
              return;
            }
          }
        }

        const guaranteedMove = checkForGuaranteedWinMove();
        if (guaranteedMove) {
          playCard(currentPlayer, guaranteedMove);
          setTimeout(endTurn, 500);
          return;
        }

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        const hasValidCardMove = aiHand.some((card) =>
          isValidPlay(card, currentProposition)
        );
        const canActuallyComplete = aiCanActuallyComplete();

        if (!hasValidCardMove && !canActuallyComplete) {
          console.log(
            "ğŸ”’ FORCED BY RULES: Round end (no actions available for AI)"
          );
          checkRoundEndConditions();
          return;
        }

        if (aiDeclareEureka()) {
          return;
        }

        let isRiskyToComplete = false;
        if (isBoardCompletable()) {
          const propToComplete = parsePropositionFromCards(currentProposition);
          const verificationResult = verifyAndExpandTruths(propToComplete);
          const myLossCondition = myVictoryData
            ? { type: "negation", proposition: myVictoryData.core_goal }
            : null;
          if (
            !verificationResult.success ||
            (opponentVictoryData &&
              aiFindProof(
                opponentVictoryData.ultimate_target,
                verificationResult.expandedSet
              )) ||
            (myLossCondition &&
              aiFindProof(myLossCondition, verificationResult.expandedSet))
          ) {
            isRiskyToComplete = true;
          }
        }

        let bestCardAction = null;
        const validMoves = aiHand.filter((card) =>
          isValidPlay(card, currentProposition)
        );

        if (validMoves.length > 0) {
          const scoredMoves = validMoves.map((move) => {
            let score = 100;

            // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: í˜„ì¬ í–‰ë™ì´ ê°¬ë¹— ê³„íšì˜ ì¼ë¶€ì¸ì§€ í™•ì¸í•˜ê³  ë³´ë„ˆìŠ¤ ë¶€ì—¬ â˜…â˜…â˜…
            if (activeGambitPlan) {
              const firstStepOfPlan = activeGambitPlan.path[0];
              const cardsNeededForStep =
                propositionToNaturalText(firstStepOfPlan).split(" ");

              // í˜„ì¬ ë³´ë“œ + ì´ë²ˆì— ë‚¼ ì¹´ë“œê°€ ê³„íšì˜ ì²« ë‹¨ê³„ë¥¼ êµ¬ì„±í•˜ëŠ”ê°€?
              const expectedNextStep = [
                ...currentProposition.map((c) => c.card.text),
                move.text,
              ].join(" ");
              if (cardsNeededForStep.join(" ").startsWith(expectedNextStep)) {
                console.log(
                  `%c[AI GAMBIT] Move '${move.text}' follows the plan. BIG BONUS!`,
                  "color: #8A2BE2;"
                );
                score += 40000; // ê°¬ë¹— ê³„íšì„ ë”°ë¥´ëŠ” í–‰ë™ì— ë§¤ìš° ë†’ì€ ë³´ë„ˆìŠ¤ ì ìˆ˜
              }
            }
            // â˜…â˜…â˜… ì—¬ê¸°ê¹Œì§€ ìˆ˜ì • â˜…â˜…â˜…

            if (move.text === notKeyword) {
              const propOnBoard = parsePropositionFromCards(currentProposition);

              // 1. ëª…ì œíŒì— ë˜ë°›ì•„ì¹  ë¶€ì • ëª…ì œ(~P)ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
              if (propOnBoard && propOnBoard.type === "negation") {
                const resultingProp = propOnBoard.proposition; // ì´ì¤‘ ë¶€ì •ìœ¼ë¡œ ë§Œë“¤ì–´ì§ˆ ëª…ì œ (P)
                const normalizedResultingProp =
                  normalizeProposition(resultingProp); // ì˜ë¯¸ë¥¼ ì •í™•íˆ íŒŒì•…í•˜ê¸° ìœ„í•´ ì •ê·œí™”

                // 2. í•„ìŠ¹ í™•ì¸: ì´ ìˆ˜ë¡œ ì¦‰ì‹œ ì´ê¸¸ ìˆ˜ ìˆëŠ”ì§€ ë¨¼ì € í™•ì¸í•©ë‹ˆë‹¤.
                const hypotheticalTruths = [
                  ...internalTruthSet,
                  normalizedResultingProp,
                ];
                if (
                  myVictoryData &&
                  aiFindProof(myVictoryData.ultimate_target, hypotheticalTruths)
                ) {
                  score += 1000000; // ì´ê¸¸ ìˆ˜ ìˆë‹¤ë©´ ë§‰ëŒ€í•œ ë³´ë„ˆìŠ¤
                } else {
                  // 3. ì†Œì†Œí•œ ì´ë“ ê³„ì‚°: ì¦‰ì‹œ ì´ê¸°ëŠ” ê²Œ ì•„ë‹ˆë¼ë©´, ì „ëµì  ê°€ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
                  const benefitScore = calculateStrategicValue(
                    normalizedResultingProp,
                    currentPlayer
                  );

                  // ê³„ì‚°ëœ ê°€ì¹˜ë§Œí¼ í–‰ë™ ì ìˆ˜ì— ë³´ë„ˆìŠ¤ë¥¼ ë¶€ì—¬í•©ë‹ˆë‹¤.
                  score += benefitScore;

                  if (benefitScore > 0) {
                    console.log(
                      `%c[Double Negation Gambit] Countering with 'not' creates a beneficial prop '${propositionToNaturalText(
                        normalizedResultingProp
                      )}'. Bonus: +${benefitScore}`,
                      "color: #00aaff"
                    );
                  }
                }
              }
            }

            if (currentProposition.length > 0 && myVictoryData) {
              const myName = myVictoryData.core_goal.subject;
              if (move.text === myName) {
                const lastCardOnBoard =
                  currentProposition[currentProposition.length - 1].card;
                if (lastCardOnBoard.text === currentLang.keywords.if) {
                  const propOnBoard = parsePropositionFromCards(
                    currentProposition.slice(0, -1)
                  );
                  if (
                    propOnBoard &&
                    arePropositionsEqual(propOnBoard, myVictoryData.core_goal)
                  ) {
                    console.warn(
                      `AI SUICIDE PREVENTION: Penalizing move '${move.text}' after own win condition + 'then'.`
                    );
                    score -= 900000;
                  }
                }
              }
            }

            if (
              move.type ===
              (currentLang.langCode === "ko" ? "ê³ ìœ ëª…ì‚¬" : "Proper Noun")
            ) {
              const opponentHand =
                currentPlayer === "A" ? playerB_Hand : playerA_Hand;
              const { not: notKeyword } = currentLang.keywords;
              const aiHasNot = aiHand.some((card) => card.text === notKeyword);
              const opponentHasNot = opponentHand.some(
                (card) => card.text === notKeyword
              );
              if (
                aiHasNot === opponentHasNot &&
                currentProposition.length > 0
              ) {
                const propLength = currentProposition.length;
                const lastCardInfo = currentProposition[propLength - 1];
                const {
                  and: andKeyword,
                  if: ifKeyword,
                  or: orKeyword,
                } = currentLang.keywords;
                let isTrap = false;
                if (lastCardInfo.card.text === andKeyword) {
                  isTrap = true;
                } else {
                  const firstPartCards = currentProposition.slice(
                    0,
                    propLength - 1
                  );
                  const parsedFirstPart =
                    parsePropositionFromCards(firstPartCards);
                  if (parsedFirstPart) {
                    if (
                      lastCardInfo.card.text === ifKeyword &&
                      aiFindProof(parsedFirstPart, internalTruthSet)
                    ) {
                      isTrap = true;
                    } else if (lastCardInfo.card.text === orKeyword) {
                      const negationOfFirstPart = {
                        type: "negation",
                        proposition: parsedFirstPart,
                      };
                      if (aiFindProof(negationOfFirstPart, internalTruthSet)) {
                        isTrap = true;
                      }
                    }
                  }
                }
                if (isTrap) {
                  console.log(
                    `ë°©ì–´ ë¡œì§ ë°œë™: ìƒëŒ€ì—ê²Œ í•„ìŠ¹ ê¸°íšŒë¥¼ ì¤„ ìˆ˜ ìˆëŠ” '${move.text}' ì¹´ë“œì˜ ì ìˆ˜ë¥¼ ì‚­ê°í•©ë‹ˆë‹¤.`
                  );
                  score -= 50000;
                }
              }
            }

            const aiPhilosopherId =
              currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
            const opponentPhilosopherId =
              opponentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
            const bourgeoisText =
              currentLang.langCode === "ko" ? "ë¸Œë£¨ì£¼ì•„ëŠ”" : "Bourgeois";
            const evilText =
              currentLang.langCode === "ko" ? "ì•…í•˜ë‹¤" : "is evil";
            const goodText =
              currentLang.langCode === "ko" ? "ì„ í•˜ë‹¤" : "is good";
            const existentialQuantifier =
              currentLang.langCode === "ko" ? "ì–´ë–¤" : "Some";
            const andKeyword = currentLang.keywords.and;
            if (currentProposition.length > 0) {
              const lastCardText =
                currentProposition[currentProposition.length - 1].card.text;
              const isQuantifiedBourgeois =
                currentProposition.length === 2 &&
                currentProposition[0].card.text === existentialQuantifier &&
                currentProposition[1].card.text === bourgeoisText;
              if (lastCardText === bourgeoisText || isQuantifiedBourgeois) {
                if (aiPhilosopherId === "marx") {
                  if (move.text === evilText) score += 15000;
                  else if (move.text === goodText) score -= 15000;
                } else if (opponentPhilosopherId === "marx") {
                  if (move.text === evilText) score -= 15000;
                  else if (move.text === goodText) score += 15000;
                }
              }
            }
            if (move.text === andKeyword) {
              const propOnBoard = parsePropositionFromCards(currentProposition);
              if (propOnBoard) {
                if (aiPhilosopherId === "marx") {
                  const antiGoalUniversal = {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: goodText,
                  };
                  const antiGoalExistential = {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: goodText,
                  };
                  if (
                    arePropositionsEqual(propOnBoard, antiGoalUniversal) ||
                    arePropositionsEqual(propOnBoard, antiGoalExistential)
                  ) {
                    score -= 18000;
                  }
                } else if (opponentPhilosopherId === "marx") {
                  const opponentGoalUniversal = {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: evilText,
                  };
                  const opponentGoalExistential = {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: evilText,
                  };
                  if (
                    arePropositionsEqual(propOnBoard, opponentGoalUniversal) ||
                    arePropositionsEqual(propOnBoard, opponentGoalExistential)
                  ) {
                    console.log(
                      "AI vs Marx: Preventing adding 'and' after a pro-revolution proposition. Massive Penalty!"
                    );
                    score -= 200000;
                  }
                }
              }
            }

            if (isRiskyToComplete) {
              if (move.text === currentLang.keywords.and) score -= 5000;
              if (move.text === currentLang.keywords.if) score += 200;
            }
            if (move.text === currentLang.keywords.and) {
              const propOnBoard = parsePropositionFromCards(currentProposition);
              if (propOnBoard) {
                if (opponentVictoryData) {
                  const opponentAdvantagePenalty = assessOpponentAdvantage(
                    propOnBoard,
                    opponentVictoryData
                  );
                  score -= opponentAdvantagePenalty;
                  const opponentWinPredicate =
                    opponentVictoryData.core_goal.predicate;
                  const predicatePairs = currentLang.contradictoryPredicates;
                  let oppositePredicate =
                    Object.keys(predicatePairs).find(
                      (key) => predicatePairs[key] === opponentWinPredicate
                    ) || predicatePairs[opponentWinPredicate];
                  if (
                    oppositePredicate &&
                    propOnBoard.type === "negation" &&
                    propOnBoard.proposition.type === "existential" &&
                    propOnBoard.proposition.predicate === oppositePredicate
                  ) {
                    score -= 3000;
                  }
                }
                if (myVictoryData) {
                  const myWinPredicate = myVictoryData.core_goal.predicate;
                  if (
                    propOnBoard.type === "negation" &&
                    propOnBoard.proposition.type === "existential" &&
                    propOnBoard.proposition.predicate === myWinPredicate
                  ) {
                    score -= 3000;
                  }
                }
              }
            }
            const hypotheticalProposition = [
              ...currentProposition,
              { card: move, player: currentPlayer },
            ];
            const parsedHypothetical = parsePropositionFromCards(
              hypotheticalProposition
            );
            if (!parsedHypothetical) return { move, score };
            const verificationResult =
              verifyAndExpandTruths(parsedHypothetical);
            if (!verificationResult.success) {
              score = -999999;
              return { move, score };
            }
            if (
              myVictoryData &&
              aiFindProof(
                myVictoryData.ultimate_target,
                verificationResult.expandedSet
              )
            ) {
              const opponentHand =
                currentPlayer === "A" ? playerB_Hand : playerA_Hand;
              if (isImmediateWinSecure(opponentHand, aiHand, currentLang)) {
                score += 1000000;
              }
            }
            if (
              opponentVictoryData &&
              aiFindProof(
                opponentVictoryData.ultimate_target,
                verificationResult.expandedSet
              )
            )
              score -= 999999;
            if (myVictoryData) {
              const myLossCondition = {
                type: "negation",
                proposition: myVictoryData.core_goal,
              };
              if (aiFindProof(myLossCondition, verificationResult.expandedSet))
                score -= 750000;
            }
            if (opponentVictoryData) {
              const advantagePenalty = assessOpponentAdvantage(
                parsedHypothetical,
                opponentVictoryData
              );
              if (advantagePenalty > 0) score -= advantagePenalty;
            }
            if (myVictoryData) {
              const disadvantagePenalty = assessSelfDisadvantage(
                parsedHypothetical,
                myVictoryData
              );
              if (disadvantagePenalty > 0) {
                console.log(
                  `Evaluation: Move creates self-disadvantage. Applying penalty: -${disadvantagePenalty}`
                );
                score -= disadvantagePenalty;
              }
            }
            const isNewClauseStart =
              currentProposition.length === 0 ||
              [
                currentLang.keywords.and,
                currentLang.keywords.or,
                currentLang.keywords.if,
              ].includes(
                currentProposition[currentProposition.length - 1]?.card.text
              );
            if (isNewClauseStart) {
              if (move.type === currentLang.cardTypes[1]) {
                if (move.text === currentLang.keywords.universal_q) score += 60;
                else score += 30;
              } else if (move.type === currentLang.cardTypes[0]) {
                score -= 40;
              }
            }
            if (parsedHypothetical) {
              const verificationResult = verifyAndExpandTruths(
                parsedHypothetical,
                internalTruthSet
              );
              if (verificationResult.success) {
                const expandedSet = verificationResult.expandedSet;
                const myVictoryData = truePropositions.find(
                  (p) => p.type === "victory" && p.owner === currentPlayer
                );
                if (myVictoryData) {
                  const myCoreGoal = myVictoryData.core_goal;
                  const contradictoryPredicate =
                    currentLang.contradictoryPredicates[myCoreGoal.predicate] ||
                    Object.keys(currentLang.contradictoryPredicates).find(
                      (key) =>
                        currentLang.contradictoryPredicates[key] ===
                        myCoreGoal.predicate
                    );
                  if (contradictoryPredicate) {
                    const selfHarmProposition = {
                      type: "atomic",
                      subject: myCoreGoal.subject,
                      predicate: contradictoryPredicate,
                    };
                    if (aiFindProof(selfHarmProposition, expandedSet)) {
                      console.warn(
                        `AI SUICIDE PREVENTION: Move '${
                          move.text
                        }' proves '${propositionToNaturalText(
                          selfHarmProposition
                        )}', which is self-destructive. Applying massive penalty.`
                      );
                      score -= 1000000;
                    }
                  }
                }
              }
            }
            return { move, score };
          });

          scoredMoves.sort((a, b) => b.score - a.score);
          if (scoredMoves.length > 0) {
            const topScore = scoredMoves[0].score;
            const bestMoves = scoredMoves.filter(
              (move) => move.score === topScore
            );
            bestCardAction =
              bestMoves[Math.floor(Math.random() * bestMoves.length)];
          } else {
            bestCardAction = null;
          }
        }

        let completeAction = null;
        if (isBoardCompletable()) {
          console.log(
            "%c3. Evaluating 'Complete Proposition' Action:",
            "color: orange; font-weight: bold;"
          );
          if (!aiCanActuallyComplete()) {
            console.log(
              "âŒ AI cannot actually complete this proposition (duplicate/contradiction)"
            );
            completeAction = null;
          } else {
            let completeScore = 120;
            const aiPhilosopherId =
              currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
            if (aiPhilosopherId === "nietzsche") {
              const propToComplete =
                parsePropositionFromCards(currentProposition);
              if (propToComplete) {
                const isAlreadyProven = truePropositions.some(
                  (p) =>
                    p.proposition &&
                    arePropositionsEqual(p.proposition, propToComplete)
                );
                if (isAlreadyProven) {
                  console.log(
                    "ë‹ˆì²´ ëŠ¥ë ¥ í™œì„±í™”: ì¤‘ë³µ ëª…ì œ ì™„ì„±ì— ë³´ë„ˆìŠ¤ ì ìˆ˜ ë¶€ì—¬!"
                  );
                  completeScore += 5000;
                }
              }
            }

            if (isRiskyToComplete) {
              console.log(
                "Evaluation: Completing is too risky. Assigning massive penalty."
              );
              completeScore = -999999;
            } else {
              const propToComplete =
                parsePropositionFromCards(currentProposition);
              if (propToComplete) {
                if (opponentVictoryData) {
                  const opponentAdvantagePenalty = assessOpponentAdvantage(
                    propToComplete,
                    opponentVictoryData
                  );
                  if (opponentAdvantagePenalty > 0) {
                    console.log(
                      `Evaluation: Completing helps opponent. Applying penalty: -${opponentAdvantagePenalty}`
                    );
                    completeScore -= opponentAdvantagePenalty;
                  }
                }
                if (myVictoryData) {
                  const selfDisadvantagePenalty = assessSelfDisadvantage(
                    propToComplete,
                    myVictoryData
                  );
                  if (selfDisadvantagePenalty > 0) {
                    console.log(
                      `Evaluation: Completing is self-disadvantageous. Applying penalty: -${selfDisadvantagePenalty}`
                    );
                    completeScore -= selfDisadvantagePenalty;
                  }
                  const myWinPredicate = myVictoryData.core_goal.predicate;
                  if (
                    propToComplete.type === "negation" &&
                    propToComplete.proposition.type === "existential" &&
                    propToComplete.proposition.predicate === myWinPredicate
                  ) {
                    console.log(
                      `Evaluation: Completing contradicts own win condition path. Applying penalty: -3000`
                    );
                    completeScore -= 3000;
                  }
                }
                if (opponentVictoryData) {
                  const opponentWinPredicate =
                    opponentVictoryData.core_goal.predicate;
                  const predicatePairs = currentLang.contradictoryPredicates;
                  let oppositePredicate =
                    Object.keys(predicatePairs).find(
                      (key) => predicatePairs[key] === opponentWinPredicate
                    ) || predicatePairs[opponentWinPredicate];
                  if (
                    oppositePredicate &&
                    propToComplete.type === "negation" &&
                    propToComplete.proposition.type === "existential" &&
                    propToComplete.proposition.predicate === oppositePredicate
                  ) {
                    console.log(
                      `Evaluation: Completing implies a universal proposition that helps opponent. Applying penalty: -3000`
                    );
                    completeScore -= 3000;
                  }
                }
                const opponentPhilosopherId =
                  opponentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
                const bourgeoisText =
                  currentLang.langCode === "ko" ? "ë¸Œë£¨ì£¼ì•„ëŠ”" : "Bourgeois";
                const evilText =
                  currentLang.langCode === "ko" ? "ì•…í•˜ë‹¤" : "is evil";
                const goodText =
                  currentLang.langCode === "ko" ? "ì„ í•˜ë‹¤" : "is good";
                const notText = currentLang.keywords.not;
                const marxGoalProp = {
                  type: "universal",
                  entity: bourgeoisText,
                  predicate: evilText,
                };
                const marxExistentialGoalProp = {
                  type: "existential",
                  entity: bourgeoisText,
                  predicate: evilText,
                };
                const marxHelpfulNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: goodText,
                  },
                };
                const marxHelpfulExistentialNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: goodText,
                  },
                };
                const marxAntiGoalProp = {
                  type: "universal",
                  entity: bourgeoisText,
                  predicate: goodText,
                };
                const marxExistentialAntiGoalProp = {
                  type: "existential",
                  entity: bourgeoisText,
                  predicate: goodText,
                };
                const marxHarmfulNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: evilText,
                  },
                };
                const marxHarmfulExistentialNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: evilText,
                  },
                };

                if (aiPhilosopherId === "marx") {
                  if (
                    arePropositionsEqual(propToComplete, marxGoalProp) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxExistentialGoalProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing a pro-revolution proposition. Bonus!"
                    );
                    completeScore += 200000;
                  } else if (
                    arePropositionsEqual(
                      propToComplete,
                      marxHelpfulNegationProp
                    ) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxHelpfulExistentialNegationProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing a helpful negated proposition. Bonus!"
                    );
                    completeScore += 200000;
                  } else if (
                    arePropositionsEqual(propToComplete, marxAntiGoalProp) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxExistentialAntiGoalProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing an anti-revolution proposition. Penalty!"
                    );
                    completeScore -= 20000;
                  } else if (
                    arePropositionsEqual(
                      propToComplete,
                      marxHarmfulNegationProp
                    ) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxHarmfulExistentialNegationProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing a harmful negated proposition. Penalty!"
                    );
                    completeScore -= 20000;
                  }
                } else if (opponentPhilosopherId === "marx") {
                  if (
                    arePropositionsEqual(propToComplete, marxGoalProp) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxExistentialGoalProp
                    )
                  ) {
                    console.log(
                      "AI vs Marx: Completing a pro-revolution proposition helps the opponent. Penalty!"
                    );
                    completeScore -= 200000;
                  }
                }
                const verificationResult =
                  verifyAndExpandTruths(propToComplete);
                if (verificationResult.success && myVictoryData) {
                  if (
                    aiFindProof(
                      myVictoryData.ultimate_target,
                      verificationResult.expandedSet
                    )
                  ) {
                    completeScore += 1000000;
                  }
                }
              }
            }
            completeAction = { action: "complete", score: completeScore };
            console.log(
              `%c>>> Calculated Score for COMPLETING: ${completeScore}`,
              "color: red; font-weight: bold;"
            );
          }
        }

        if (
          bestCardAction &&
          (!completeAction || bestCardAction.score >= completeAction.score)
        ) {
          console.log(
            `%c--- AI FINAL DECISION: PLAY CARD '${bestCardAction.move.text}' (Score: ${bestCardAction.score}) ---`,
            "background: #222; color: #bada55; font-size: 1.2em;"
          );
          playCard(currentPlayer, bestCardAction.move);
          setTimeout(endTurn, 500);
        } else if (completeAction) {
          console.log(
            `%c--- AI FINAL DECISION: COMPLETE PROPOSITION (Score: ${completeAction.score}) ---`,
            "background: #222; color: #bada55; font-size: 1.2em;"
          );
          completeProposition();
        } else {
          checkRoundEndConditions();
        }
      }

      function playCard(player, cardToPlay) {
        if (player !== currentPlayer || gameIsOver || isThinkingTime) return;

        if (cardsPlayedThisTurn[player] >= 1) {
          showAlert(currentLang.alerts.oneCardPerTurn);
          return;
        }

        if (!isValidPlay(cardToPlay, currentProposition)) {
          if (player !== aiPlayer) {
            showAlert(currentLang.alerts.invalidCard);
          }
          return;
        }
        if (currentProposition.length === 0) propositionStarter = player;
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (card) =>
            card.text === cardToPlay.text && card.type === cardToPlay.type
        );
        if (cardIndex === -1) return;
        currentProposition.push({
          card: hand.splice(cardIndex, 1)[0],
          player: player,
          originalIndex: cardIndex, // ì¹´ë“œì˜ ì›ë˜ ìœ„ì¹˜ë¥¼ í•¨ê»˜ ì €ì¥
        });

        audioManager.playSfx("playCard");

        lastCardPlayer = player;
        cardsPlayedThisTurn[player]++;

        render();
      }

      function completeProposition() {
        if (currentProposition.length === 0 || gameIsOver || isThinkingTime)
          return false;

        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (!parsedProp) {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.incompleteProposition);
          }
          return false;
        }

        const isAxiom = parsedAxioms.some((a) =>
          arePropositionsEqual(a.proposition, parsedProp)
        );
        const isAlreadyInTrueList = truePropositions.some(
          (p) =>
            p.proposition && arePropositionsEqual(p.proposition, parsedProp)
        );

        // ê³µë¦¬ì´ê±°ë‚˜, ì´ë¯¸ ì°¸ ëª©ë¡ì— ìˆìœ¼ë©´ 'ì¦ëª…ëœ ê²ƒ'ìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
        const isAlreadyProven = isAxiom || isAlreadyInTrueList;
        const currentPlayerId =
          currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;

        // 1. "ë¶ˆê°€ëŠ¥í•œ ê²½ìš°"ë¥¼ ë¨¼ì € í™•ì¸í•˜ê³  í•¨ìˆ˜ë¥¼ ì¦‰ì‹œ ì¢…ë£Œì‹œí‚µë‹ˆë‹¤.
        // í˜„ì¬ í”Œë ˆì´ì–´ê°€ ë‹ˆì²´ê°€ "ì•„ë‹Œë°" ì¤‘ë³µ ëª…ì œë¥¼ ì™„ì„±í•˜ë ¤ëŠ” ê²½ìš° -> ê±°ë¶€
        if ((isAxiom || isAlreadyProven) && currentPlayerId !== "nietzsche") {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.duplicateProposition);
          }
          return false;
        }

        // 2. ì—¬ê¸°ê¹Œì§€ ì™”ë‹¤ë©´, ì•„ë˜ ë‘ ê²½ìš° ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤:
        //    - ìƒˆë¡œìš´ ëª…ì œì¸ ê²½ìš° (ëª¨ë“  í”Œë ˆì´ì–´)
        //    - ì¤‘ë³µ ëª…ì œì¸ ê²½ìš° (ë‹ˆì²´ë§Œ í•´ë‹¹)

        const verificationResult = verifyAndExpandTruths(parsedProp);

        if (verificationResult.success) {
          // 3. ë…¼ë¦¬ì ìœ¼ë¡œ ì°¸ì„ì´ ì¦ëª…ë˜ì—ˆìœ¼ë¯€ë¡œ, ëª…ì œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
          internalTruthSet = verificationResult.expandedSet;

          // ì¶”ê°€í•  ëª…ì œ ê°ì²´ë¥¼ ê¸°ë³¸ í˜•íƒœë¡œ ìƒì„±í•©ë‹ˆë‹¤.
          const propToAdd = {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          };

          // ë§Œì•½ "ë‹ˆì²´ê°€ ì¤‘ë³µ ëª…ì œë¥¼ ì™„ì„±"í•œ ê²½ìš°, 'source'ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
          if (isAlreadyProven && currentPlayerId === "nietzsche") {
            propToAdd.source = "nietzsche_ability";
          }

          console.log("ë‹ˆì²´ ëª…ì œ ìƒì„± ì‹œì : ", propToAdd);

          truePropositions.push(propToAdd);

          // --- ëª…ì œ ì¶”ê°€ ì„±ê³µ í›„ ê³µí†µ ë¡œì§ ---
          audioManager.playSfx("complete");
          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
          const truePropositionsEl =
            document.getElementById("true-propositions");
          truePropositionsEl.scrollTop = truePropositionsEl.scrollHeight;
          checkNextTurn();
          return true;
        } else {
          // 4. ëª¨ìˆœì´ ë°œê²¬ëœ ê²½ìš°
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.contradictionFound);
          }
          return false;
        }
      }

      function undoProposition() {
        if (gameIsOver || isThinkingTime) return;
        if (gameMode === "AI" && currentPlayer === aiPlayer) return;

        if (currentProposition.length > 0) {
          audioManager.playSfx("undo");
          const lastPlayedInfo = currentProposition.pop();
          if (gameMode === "AI" && lastPlayedInfo.player === aiPlayer) {
            currentProposition.push(lastPlayedInfo);
            return;
          }
          const hand =
            lastPlayedInfo.player === "A" ? playerA_Hand : playerB_Hand;

          // hand.push ëŒ€ì‹  spliceë¥¼ ì‚¬ìš©í•˜ì—¬ ì›ë˜ ìœ„ì¹˜ì— ì¹´ë“œë¥¼ ì‚½ì…í•©ë‹ˆë‹¤.
          if (typeof lastPlayedInfo.originalIndex !== "undefined") {
            hand.splice(lastPlayedInfo.originalIndex, 0, lastPlayedInfo.card);
          } else {
            // í˜¹ì‹œ ëª¨ë¥¼ ì˜ˆì™¸ ìƒí™©ì„ ìœ„í•œ ëŒ€ë¹„ ì½”ë“œ
            hand.push(lastPlayedInfo.card);
          }
          cardsPlayedThisTurn[lastPlayedInfo.player]--;
          currentPlayer = lastPlayedInfo.player;

          if (currentProposition.length > 0) {
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
          } else {
            lastCardPlayer = null;
          }

          render();
        } else {
          let lastUserMadePropIndex = -1;
          for (let i = truePropositions.length - 1; i >= 0; i--) {
            if (truePropositions[i].type === "user-made") {
              lastUserMadePropIndex = i;
              break;
            }
          }
          if (lastUserMadePropIndex !== -1) {
            const propToUndo = truePropositions[lastUserMadePropIndex];
            const lastMaker =
              propToUndo.original_cards[propToUndo.original_cards.length - 1]
                .player;
            if (gameMode === "AI" && lastMaker === aiPlayer) {
              showAlert(currentLang.alerts.nothingToUndo);
              return;
            }
            audioManager.playSfx("undo");
            truePropositions.splice(lastUserMadePropIndex, 1);
            let newTruthSet = parsedAxioms.map((a) => a.proposition);
            const propositionsToReverify = truePropositions
              .filter(
                (p) =>
                  p.type === "victory" ||
                  p.type === "theorem" ||
                  p.type === "user-made"
              )
              .map((p) => p.proposition);
            for (const prop of propositionsToReverify) {
              internalTruthSet = JSON.parse(JSON.stringify(newTruthSet));
              const verificationResult = verifyAndExpandTruths(prop);
              if (verificationResult.success) {
                newTruthSet = verificationResult.expandedSet;
              } else {
                console.error(
                  "Critical error: Inconsistency found while rebuilding truth set after undo.",
                  prop
                );
                showAlert(currentLang.alerts.criticalErrorUndo);
                truePropositions.splice(lastUserMadePropIndex, 0, propToUndo);
                return;
              }
            }
            internalTruthSet = newTruthSet;
            currentProposition = propToUndo.original_cards;
            currentPlayer =
              currentProposition[currentProposition.length - 1].player;
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
            cardsPlayedThisTurn = { A: 0, B: 0 };
            showAlert(currentLang.alerts.undoLastProposition);
            render();
          } else {
            showAlert(currentLang.alerts.nothingToUndo);
          }
        }
      }

      function declareEureka(player) {
        if (gameIsOver) return;

        if (!isThinkingTime && player !== currentPlayer) return;

        if (gameMode === "AI" && player === aiPlayer) return;

        if (!isThinkingTime) {
          if (eurekaUsedInRound[player]) {
            return;
          }

          showConfirm(currentLang.alerts.confirmDeclareEureka, (event) => {
            // ğŸ’¡ ë³€ê²½ì : event ê°ì²´ë¥¼ ë°›ë„ë¡ ìˆ˜ì •
            event.stopPropagation(); // ğŸ’¡ ë³€ê²½ì : ì´ë²¤íŠ¸ ì „íŒŒë¥¼ ë§‰ì•„ ì¤‘ë³µ ì†Œë¦¬ë¥¼ ì œê±°

            audioManager.playSfx("eureka");
            eurekaUsedInRound[player] = true;
            openEurekaModal();
            render();
          });
        } else {
          openEurekaModal();
          render();
        }
      }
      function getTemporaryUsableTruths() {
        // 'ë¬´ì§€ì˜ ìê°'ì´ ì‚¬ìš©ë˜ì§€ ì•Šì•˜ë‹¤ë©´, AIë„ internalTruthSetì„ ê·¸ëŒ€ë¡œ ì”ë‹ˆë‹¤.
        if (socratesDisabledProps.length === 0) {
          return internalTruthSet;
        }

        // --- 'ë¬´ì§€ì˜ ìê°'ì´ ì‚¬ìš©ëœ ê²½ìš°, AIì˜ ì§€ì‹ì„ ì¬êµ¬ì„±í•©ë‹ˆë‹¤. ---

        // 1. í™”ë©´ì˜ ì°¸ ëª…ì œ ëª©ë¡ì—ì„œ ë¹„í™œì„±í™”ëœ ëª…ì œë¥¼ ë¨¼ì € ì œì™¸í•©ë‹ˆë‹¤.
        const filteredUserMadeProps = truePropositions.filter(
          (p) =>
            !p.propId ||
            !socratesDisabledProps.some((dp) => dp.propId === p.propId)
        );

        // 2. ê³µë¦¬ì™€ í•„í„°ë§ëœ ëª…ì œë¥¼ í•©ì³ AIê°€ ì‚¬ìš©í•  ìµœì¢… ì „ì œ ëª©ë¡ì„ ë§Œë“­ë‹ˆë‹¤.
        const filteredPremises = [
          ...parsedAxioms.map((a) => a.proposition),
          ...filteredUserMadeProps.map((p) => p.proposition).filter(Boolean),
        ];

        // 3. í•„í„°ë§ëœ ì „ì œë¡œë¶€í„° ëª¨ë“  ê²°ë¡ ì„ ì¬êµ¬ì„±
        const { success, expandedSet } = verifyAndExpandTruths(
          null,
          filteredPremises
        );

        if (success) {
          return expandedSet;
        } else {
          console.error("AI: Truth set reconstruction failed.");
          return internalTruthSet; // ì˜¤ë¥˜ ì‹œ ì•ˆì „í•˜ê²Œ ê¸°ì¡´ ê°’ ë°˜í™˜
        }
      }
      function aiDeclareEureka() {
        if (isThinkingTime) return false;

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryCondition || !opponentVictoryCondition) return false;

        const temporaryTruthSetForAI = getTemporaryUsableTruths();

        const myGoal = myVictoryCondition.ultimate_target;
        const opponentGoal = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        if (aiFindProof(myGoal, temporaryTruthSetForAI)) {
          console.log(
            "AI Eureka! Proved own victory based on fair, reconstructed knowledge."
          );
          audioManager.playSfx("eureka");

          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(currentPlayer)
          );
          return true;
        }

        if (aiFindProof(opponentGoal, temporaryTruthSetForAI)) {
          console.log(
            "AI Eureka! Proved opponent's defeat based on fair, reconstructed knowledge."
          );
          audioManager.playSfx("eureka");

          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(currentPlayer)
          );
          return true;
        }

        return false;
      }
      function aiFindProof(
        targetProposition,
        initialTruths = internalTruthSet
      ) {
        let knownTruths = [...initialTruths];
        let newTruthsFoundInIteration = true;
        let iterations = 0;
        const maxIterations = 50; // ë¬´í•œ ë£¨í”„ ë°©ì§€

        while (newTruthsFoundInIteration && iterations < maxIterations) {
          newTruthsFoundInIteration = false;
          iterations++;

          const currentTruthsCount = knownTruths.length;
          let tempTruths = [...knownTruths];

          // ëª©í‘œë¥¼ ì´ë¯¸ ë‹¬ì„±í–ˆëŠ”ì§€ í™•ì¸
          if (
            tempTruths.some((p) => arePropositionsEqual(p, targetProposition))
          ) {
            return true;
          }

          // 1ê°œ ì „ì œ ê·œì¹™ ì ìš©
          for (const p of knownTruths) {
            const rules = [
              conjunctionElimination,
              doubleNegationElimination,
              existentialInstantiation,
            ];
            for (const rule of rules) {
              const result = rule(p);
              if (result) {
                const results = Array.isArray(result) ? result : [result];
                results.forEach((res) => {
                  if (!tempTruths.some((t) => arePropositionsEqual(t, res))) {
                    tempTruths.push(res);
                    newTruthsFoundInIteration = true;
                  }
                });
              }
            }
          }

          // 2ê°œ ì „ì œ ê·œì¹™ ì ìš©
          for (let i = 0; i < knownTruths.length; i++) {
            for (let j = 0; j < knownTruths.length; j++) {
              if (i === j) continue;
              const p1 = knownTruths[i];
              const p2 = knownTruths[j];
              const rules = [
                modusPonens,
                modusTollens,
                hypotheticalSyllogism,
                disjunctiveSyllogism,
                universalApplication,
              ];
              for (const rule of rules) {
                const result = rule(p1, p2);
                if (
                  result &&
                  !tempTruths.some((t) => arePropositionsEqual(t, result))
                ) {
                  tempTruths.push(result);
                  newTruthsFoundInIteration = true;
                }
              }
            }
          }

          // â˜…â˜…â˜… ìˆ˜ì •ëœ ë¶€ë¶„: ê²½ìš° ë…¼ì¦ (Proof by Cases) ìµœì í™” â˜…â˜…â˜…
          // 1. ëª¨ë“  'ë˜ëŠ”' ëª…ì œì™€ 'ë¼ë©´' ëª…ì œë¥¼ ë¯¸ë¦¬ ë¶„ë¥˜í•˜ì—¬ ê²€ìƒ‰ ë²”ìœ„ë¥¼ ì¤„ì…ë‹ˆë‹¤.
          const disjunctions = knownTruths.filter(
            (p) => p.type === "disjunction"
          );
          const conditionals = knownTruths.filter(
            (p) => p.type === "conditional"
          );

          // 2. 'ë˜ëŠ”' ëª…ì œë¥¼ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤.
          for (const disjunction of disjunctions) {
            // ì˜ˆ: (P âˆ¨ Q)
            const p = disjunction.left;
            const q = disjunction.right;

            // 3. Pë¡œ ì‹œì‘í•˜ëŠ” 'ë¼ë©´' ëª…ì œë“¤ (P â†’ R)ì„ ì°¾ìŠµë‹ˆë‹¤.
            const pConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, p)
            );
            if (pConditionals.length === 0) continue; // ì—†ìœ¼ë©´ ë‹¤ìŒ 'ë˜ëŠ”' ëª…ì œë¡œ ë„˜ì–´ê°

            // 4. Që¡œ ì‹œì‘í•˜ëŠ” 'ë¼ë©´' ëª…ì œë“¤ (Q â†’ R)ì„ ì°¾ìŠµë‹ˆë‹¤.
            const qConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, q)
            );
            if (qConditionals.length === 0) continue; // ì—†ìœ¼ë©´ ë‹¤ìŒ 'ë˜ëŠ”' ëª…ì œë¡œ ë„˜ì–´ê°

            // 5. ì°¾ì•„ë‚¸ ë‘ 'ë¼ë©´' ëª…ì œ ê·¸ë£¹ì„ ë¹„êµí•˜ì—¬ ê²°ë¡ (R)ì´ ê°™ì€ ìŒì„ ì°¾ìŠµë‹ˆë‹¤.
            for (const pCond of pConditionals) {
              for (const qCond of qConditionals) {
                // ê²°ë¡ (pCond.rightì™€ qCond.right)ì´ ë™ì¼í•œì§€ í™•ì¸
                if (arePropositionsEqual(pCond.right, qCond.right)) {
                  const result = pCond.right; // ìµœì¢… ê²°ë¡  R
                  // ìƒˆë¡œìš´ ê²°ë¡ ì´ë¼ë©´ ì°¸ ëª©ë¡ì— ì¶”ê°€
                  if (
                    result &&
                    !tempTruths.some((t) => arePropositionsEqual(t, result))
                  ) {
                    tempTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }
          }

          knownTruths = tempTruths;
        }

        // ìµœì¢…ì ìœ¼ë¡œ ëª©í‘œê°€ ë‹¬ì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
        return knownTruths.some((p) =>
          arePropositionsEqual(p, targetProposition)
        );
      }

      function endGame(winner, winningProposition) {
        audioManager.playSfx("victory");
        audioManager.fadeOut("game-play");
        audioManager.fadeOut("thinking-time");
        gameIsOver = true;
        document.getElementById("eureka-modal").classList.remove("visible");
        const statusEl = document.getElementById("status");
        let winnerName;
        const isMirrorMatch = playerA_Data.id === playerB_Data.id;

        if (winner === "A") {
          winnerName = getLastName(playerA_Data.name[currentLang.langCode]);
          if (isMirrorMatch) {
            // ë¯¸ëŸ¬ì „ì¼ ê²½ìš°, Aí”Œë ˆì´ì–´(ì„ ê³µ)ì—ê²Œ ìƒ‰ìƒ ì‹ë³„ìë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
            winnerName += currentLang.langCode === "ko" ? "(ë°±)" : " (White)";
          }
        } else {
          // winner === 'B'
          winnerName = getLastName(playerB_Data.name[currentLang.langCode]);
          if (isMirrorMatch) {
            // ë¯¸ëŸ¬ì „ì¼ ê²½ìš°, Bí”Œë ˆì´ì–´(í›„ê³µ)ì—ê²Œ ìƒ‰ìƒ ì‹ë³„ìë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
            winnerName += currentLang.langCode === "ko" ? "(í‘)" : " (Black)";
          }
        }
        const victoryText = `${winnerName} ${currentLang.ui.victoryMessage}<br>${currentLang.ui.victorySubMessage}`;
        statusEl.innerHTML = `<span class="turn-indicator">${victoryText}</span>`;
        render();

        // 1. ëª¨ë“  ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ë¥¼ ì¼ë‹¨ ìˆ¨ê¹ë‹ˆë‹¤.
        document.querySelectorAll(".overlay-image").forEach((img) => {
          img.classList.add("hidden");
        });

        // 2. â˜…â˜…â˜… ìˆ˜ì •ëœ í•µì‹¬ ë¡œì§ â˜…â˜…â˜…
        //    ìŠ¹ë¦¬í•œ ì² í•™ìì˜ 'ìŠ¹ë¦¬' ì˜¤ë²„ë ˆì´ë¥¼ ë…¼ë¦¬ ì¦ëª…ê³¼ ê´€ê³„ì—†ì´ ì¦‰ì‹œ í‘œì‹œí•©ë‹ˆë‹¤.
        const winnerOverlayId =
          winner === "A" ? "socrates-win-overlay" : "plato-win-overlay";
        const winnerOverlay = document.getElementById(winnerOverlayId);
        if (winnerOverlay) {
          winnerOverlay.classList.remove("hidden");
          // z-indexë¥¼ ë‹¤ë¥¸ ìŠ¹ë¦¬ ì´ë¯¸ì§€ë³´ë‹¤ ë†’ê²Œ ì„¤ì •í•˜ì—¬ í•­ìƒ ìœ„ì— ì˜¤ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.
          // (CSSì—ì„œ ì´ë¯¸ z-index: 3ìœ¼ë¡œ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì´ ì¤„ì€ ì„ íƒì ì…ë‹ˆë‹¤.)
          winnerOverlay.style.zIndex = "5";
        }

        // 3. 'ìŠ¹ë¦¬'ë¥¼ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ìƒíƒœ ì˜¤ë²„ë ˆì´ë“¤ì€ ê¸°ì¡´ì²˜ëŸ¼ ë…¼ë¦¬ì  ì°¸/ê±°ì§“ì— ë”°ë¼ í‘œì‹œí•©ë‹ˆë‹¤.
        const characters = [
          currentLang.keywords.socrates,
          currentLang.keywords.plato,
        ];
        const predicates = [
          ...currentLang.cards
            .filter(
              (card) =>
                card.type === currentLang.cardTypes[3] ||
                card.type === "Predicate"
            )
            // â˜…â˜…â˜… 'ìŠ¹ë¦¬í•œë‹¤' ì„œìˆ ì–´ëŠ” ìœ„ì—ì„œ ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ, ë°˜ë³µë¬¸ì—ì„œ ì œì™¸í•©ë‹ˆë‹¤.
            .filter(
              (card) =>
                card.text !== currentLang.keywords.wins &&
                card.text !== "ìŠ¹ë¦¬í•œë‹¤"
            )
            .map((card) => card.text),
        ];

        characters.forEach((subjectText) => {
          predicates.forEach((predicateText) => {
            const targetProposition = {
              type: "atomic",
              subject: subjectText,
              predicate: predicateText,
            };

            if (aiFindProof(targetProposition, internalTruthSet)) {
              const subjectId =
                subjectText === currentLang.keywords.socrates
                  ? "socrates"
                  : "plato";
              const predicateMap = {
                ì„ í•˜ë‹¤: "good",
                "is good": "good",
                ì•…í•˜ë‹¤: "evil",
                "is evil": "evil",
                ì§€í˜œë¡­ë‹¤: "wise",
                "is wise": "wise",
                ì–´ë¦¬ì„ë‹¤: "foolish",
                "is foolish": "foolish",
                ìƒˆì´ë‹¤: "bird",
                "is a bird": "bird",
                ë¬¼ê³ ê¸°ì´ë‹¤: "fish",
                "is a fish": "fish",
                ê°œì´ë‹¤: "dog",
                "is a dog": "dog",
              };
              const predicateId = predicateMap[predicateText];

              if (predicateId) {
                const overlayId = `${subjectId}-${predicateId}-overlay`;
                const overlayToShow = document.getElementById(overlayId);
                if (overlayToShow) {
                  overlayToShow.classList.remove("hidden");
                }
              }
            }
          });
        });
      }
      function checkRoundEndConditions() {
        if (
          gameIsOver ||
          isThinkingTime ||
          cardsPlayedThisTurn[currentPlayer] > 0
        )
          return;

        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const hasValidCardMove = hand.some((card) =>
          isValidPlay(card, currentProposition)
        );

        let canComplete = false;
        if (currentProposition.length > 0 && lastCardPlayer !== currentPlayer) {
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (parsedProp) {
            const verificationResult = verifyAndExpandTruths(parsedProp);
            if (verificationResult.success) {
              canComplete = true;
            }
          }
        }

        if (!hasValidCardMove && !canComplete) {
          const playerName =
            currentPlayer === "A"
              ? playerA_Data.name[currentLang.langCode]
              : playerB_Data.name[currentLang.langCode];

          // 'AI vs AI' ëª¨ë“œì¼ ê²½ìš°ì—ë§Œ ê²½ê³ ì°½ì„ ê±´ë„ˆëœë‹ˆë‹¤.
          if (gameMode === "AI_VS_AI") {
            console.log(
              `AI (${currentPlayer}) has no moves. Starting Thinking Time automatically in AI_VS_AI mode.`
            );
            startThinkingTime();
          } else {
            // ê·¸ ì™¸ì˜ ëª¨ë“  ëª¨ë“œ(ì‚¬ëŒ vs AI í¬í•¨)ì—ì„œëŠ” ê²½ê³ ì°½ì„ ë„ì›ë‹ˆë‹¤.
            showAlert(
              currentLang.alerts.roundEndNoMoves.replace(
                "{player}",
                playerName
              ),
              () => startThinkingTime()
            );
          }
        }
      }

      function startThinkingTime() {
        audioManager.fadeOut("game-play");
        audioManager.play("thinking-time");

        currentProposition = [];
        lastCardPlayer = null;
        isThinkingTime = true;
        cardsPlayedThisTurn = { A: 0, B: 0 };

        const thinkingTimeEl = document.getElementById(
          "thinking-time-controls"
        );
        thinkingTimeEl.classList.remove("hidden");
        thinkingTimeEl.style.display = "";

        // í›„ê³µ í”Œë ˆì´ì–´ë¶€í„° ì‚¬ìœ  ì‹œê°„ í„´ì„ ì‹œì‘
        const roundStarter = currentRound % 2 === 1 ? "A" : "B";
        const thinkingTimeStarter = roundStarter === "A" ? "B" : "A";
        thinkingTimeTurn = thinkingTimeStarter;

        render();

        // âœ… [í•µì‹¬ ìˆ˜ì •] í„´ ì‹œì‘ì€ ì´ì œ checkNextTurn í•¨ìˆ˜ê°€ ì „ë‹´í•˜ë¯€ë¡œ,
        // ìƒíƒœ ë³€ê²½ í›„ checkNextTurnì„ í˜¸ì¶œí•˜ì—¬ í„´ ê´€ë¦¬ë¥¼ ë„˜ê²¨ì¤ë‹ˆë‹¤.
        checkNextTurn();
      }
      function endThinkingTime() {
        audioManager.fadeOut("thinking-time"); // ê¸°ì¡´ ì½”ë“œ
        audioManager.play("game-play"); // ê¸°ì¡´ ì½”ë“œ

        socratesDisabledProps = socratesDisabledProps.filter(
          (prop) => prop.reEnableRound > currentRound + 1
        ); // ê¸°ì¡´ ì½”ë“œ

        isThinkingTime = false; // ê¸°ì¡´ ì½”ë“œ
        thinkingTimeTurn = null; // ê¸°ì¡´ ì½”ë“œ

        document
          .getElementById("thinking-time-controls")
          .classList.add("hidden"); // ê¸°ì¡´ ì½”ë“œ

        currentRound++; // ê¸°ì¡´ ì½”ë“œ
        eurekaUsedInRound = { A: false, B: false }; // ê¸°ì¡´ ì½”ë“œ

        // ì†íŒ¨ë¥¼ ìƒˆë¡œ ë¶„ë°°í•˜ëŠ” ë¶€ë¶„ (ê¸°ì¡´ ì½”ë“œ)
        const nonPlayerCards = [currentLang.keywords.wins]; // ê¸°ì¡´ ì½”ë“œ
        playerA_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        ); // ê¸°ì¡´ ì½”ë“œ
        playerB_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        ); // ê¸°ì¡´ ì½”ë“œ

        // í˜„ì¬ ê²Œì„ì— ë§ˆë¥´í¬ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        const isMarxInGame =
          playerA_Data.id === "marx" || playerB_Data.id === "marx"; // playerA_Dataì™€ playerB_Dataë¥¼ ì°¸ì¡°í•˜ì—¬ ë§ˆë¥´í¬ìŠ¤ ì¡´ì¬ ì—¬ë¶€ í™•ì¸

        // ë§ˆë¥´í¬ìŠ¤ê°€ ìˆë‹¤ë©´, ìƒˆë¡œ ë¶„ë°°ëœ ì†íŒ¨ì—ì„œ í”Œë ˆì´ ë¶ˆê°€ëŠ¥í•œ ì¹´ë“œë“¤ì„ ì œê±°í•©ë‹ˆë‹¤.
        if (isMarxInGame) {
          const unplayableCardTexts = [
            currentLang.langCode === "ko" ? "í˜ëª…ì´" : "A revolution",
            currentLang.langCode === "ko" ? "ì¼ì–´ë‚œë‹¤" : "occurs",
          ]; // ì œê±°í•  ì¹´ë“œ ëª©ë¡ ì •ì˜

          playerA_Hand = playerA_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          ); // ì†íŒ¨ Aì—ì„œ í•„í„°ë§
          playerB_Hand = playerB_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          ); // ì†íŒ¨ Bì—ì„œ í•„í„°ë§
        }

        currentPlayer = currentRound % 2 === 1 ? "A" : "B"; // ê¸°ì¡´ ì½”ë“œ
        render(); // ê¸°ì¡´ ì½”ë“œ
        checkNextTurn(); // ê¸°ì¡´ ì½”ë“œ
      }
      function openEurekaModal() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";
        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions
            .map((p) => ({ ...p, proposition: p.proposition }))
            .filter((p) => p.proposition),
        ].filter(
          (propData) =>
            // âœ… propDataì— propIdê°€ ìˆê³ , ê·¸ IDê°€ socratesDisabledProps ë°°ì—´ì— í¬í•¨ë˜ì§€ ì•Šì€ ê²½ìš°ë§Œ trueë¥¼ ë°˜í™˜
            !propData.propId ||
            !socratesDisabledProps.some((dp) => dp.propId === propData.propId)
        );
        
        // ê³µë¦¬ë“¤ì„ ê·¸ë£¹ë³„ë¡œ ë¶„ë¥˜í•˜ê³  ìˆœì„œëŒ€ë¡œ ì¶”ê°€
        const axioms = allSelectablePropositions.filter(p => p.type === "axiom");
        const nonAxioms = allSelectablePropositions.filter(p => p.type !== "axiom");
        
        // ê³µë¦¬ë¥¼ ê·¸ë£¹í™”í•˜ì—¬ ì¶”ê°€ - ì‘ì€ ì„œë¸Œê·¸ë£¹ë³„ë¡œ êµ¬ë¶„ì„  ì¶”ê°€
        if (currentAxioms.groups && axioms.length > 0) {
          const groups = currentAxioms.groups;
          const templates = currentLang.axiom_templates;
          let axiomIndex = 0;
          
          // ì •ì²´ì„± ê³µë¦¬ ê·¸ë£¹
          if (groups.identity && groups.identity.length > 0) {
            for (let i = 0; i < groups.identity.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì •ì²´ì„± ê·¸ë£¹ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ - ì„œë¸Œê·¸ë£¹ë³„ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.subjectOpposition && groups.subjectOpposition.length > 0) {
            // ì²« ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ì²« ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë‘ ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë‘ ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ - ì„œë¸Œê·¸ë£¹ë³„ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.quantifierOpposition && groups.quantifierOpposition.length > 0) {
            // ìƒˆ ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.bird_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ìƒˆ ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.bird_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.fish_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.fish_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ê°œ ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.dog_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ê°œ ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.dog_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ë§ˆë¥´í¬ìŠ¤ ê³µë¦¬ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            const remainingAxioms = axioms.slice(axiomIndex);
            const marxAxioms = remainingAxioms.filter(a => {
              const text = propositionToNaturalText(a.proposition);
              return text.includes("ë¸Œë£¨ì£¼ì•„") || text.includes("Bourgeois");
            });
            
            if (marxAxioms.length > 0) {
              // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
              addPremiseToWorkbench({
                type: "separator",
                label: "",
                proposition: null,
                isSeparator: true
              });
              
              marxAxioms.forEach((axiomData) => {
                addPremiseToWorkbench({
                  ...axiomData,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              });
            }
            
            // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ ë§ˆì§€ë§‰ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        } else {
          // ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ê³µë¦¬ ì¶”ê°€ (í•˜ìœ„ í˜¸í™˜ì„±)
          axioms.forEach((propData) => {
            addPremiseToWorkbench({
              ...propData,
              label: currentLang.labels.axiom
            });
          });
          
          // ê³µë¦¬ ë§ˆì§€ë§‰ êµ¬ë¶„ì„  ì¶”ê°€
          if (axioms.length > 0) {
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        }
        
        // ê³µë¦¬ê°€ ì•„ë‹Œ ëª…ì œë“¤ ì¶”ê°€
        nonAxioms.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });
        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        if (isThinkingTime) {
          modalTitle.textContent = currentLang.modals.eurekaTitleTheorem;
          confirmBtn.textContent = currentLang.modals.confirmTheoremButton;
          confirmBtn.onclick = addTheoremsToList;
        } else {
          modalTitle.textContent = currentLang.modals.eurekaTitleVictory;
          confirmBtn.textContent = currentLang.modals.confirmVictoryButton;
          confirmBtn.onclick = proveVictory;
        }
        renderModal();
        document.getElementById("inference-rule-select").onchange =
          updateConclusionPreview;
        updateConclusionPreview(); // Initialize preview
        modal.classList.add("visible");
      }

      function addAssumption() {
        if (currentAssumption) {
          showAlert(currentLang.alerts.oneAssumptionOnly);
          return;
        }
        showPrompt(
          currentLang.modals.promptInputPlaceholder,
          (propositionText) => {
            if (propositionText) {
              const parsedProp = parsePropositionFromString(propositionText);
              if (parsedProp) {
                currentAssumption = parsedProp;
                addPremiseToWorkbench({
                  proposition: parsedProp,
                  type: "assumption",
                  dependsOnAssumption: true,
                  isAssumption: true,
                  label: currentLang.labels.assumption,
                });
                renderModal();
                updateConclusionPreview();
              } else {
                showAlert(currentLang.alerts.parsingFailed);
              }
            }
          }
        );
      }

      function cancelAssumption() {
        if (inTutorialMode) return;
        currentAssumption = null;
        derivedPropositionsInModal = derivedPropositionsInModal.filter(
          (p) => !p.dependsOnAssumption
        );
        renderModal();
        updateConclusionPreview();
      }

      function addPremiseToWorkbench(propObject) {
        derivedPropositionsInModal.push(propObject);
      }

      function applyRule() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;

        // ì´ ì¦ëª…ì— ì§ì ‘ì ìœ¼ë¡œ ì‚¬ìš©ëœ ì „ì œ ë°ì´í„° (ì´ê²ƒì´ ë¶€ëª¨ ì „ì œê°€ ë¨)
        const premisesData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );
        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];

        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "conditionalIntroduction",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (rule === "conditionalIntroduction") {
          if (premises.length !== 1) {
            showAlert(currentLang.alerts.premiseNeededForIntro);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForIntro);
            return;
          }
          const conclusionData = premisesData[0];
          if (!conclusionData.dependsOnAssumption) {
            showAlert(currentLang.alerts.premiseNotFromAssumption);
            return;
          }
          const newConditional = {
            type: "conditional",
            left: currentAssumption,
            right: conclusionData.proposition,
          };

          // 'ê°€ì •'ê³¼ ê·¸ë¡œë¶€í„° ë„ì¶œëœ 'ê²°ë¡ ' ëª¨ë‘ë¥¼ sourceë¡œ ì¶”ì 
          const assumptionData = derivedPropositionsInModal.find(
            (p) => p.isAssumption
          );
          const sourcePremisesForCI = [assumptionData, conclusionData];

          derivedPropositionsInModal = derivedPropositionsInModal.filter(
            (p) => !p.dependsOnAssumption
          );
          currentAssumption = null;
          addPremiseToWorkbench({
            proposition: newConditional,
            type: "theorem",
            dependsOnAssumption: false,
            isAssumption: false,
            label: currentLang.labels.ci_theorem,
            sourcePremises: sourcePremisesForCI, // source ì •ë³´ ì¶”ê°€
          });
          // ì¡°ê±´ë¶€ ë„ì… ì„±ê³µ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
          audioManager.playSfx("pop");
        } else if (rule === "reductioAdAbsurdum") {
          if (premises.length !== 2) {
            showAlert(currentLang.alerts.contradictionNeededForRAA);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForRAA);
            return;
          }

          // 'ê°€ì •'ê³¼ ëª¨ìˆœì„ ì´ëŒì–´ë‚¸ 'ë‘ ì „ì œ' ëª¨ë‘ë¥¼ sourceë¡œ ì¶”ì 
          const assumptionData = derivedPropositionsInModal.find(
            (p) => p.isAssumption
          );
          const sourcePremisesForRAA = [assumptionData, ...premisesData];

          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
              sourcePremises: sourcePremisesForRAA, // source ì •ë³´ ì¶”ê°€
            });
            // ê·€ë¥˜ë²• ì„±ê³µ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
            audioManager.playSfx("pop");
          } else {
            showAlert(currentLang.alerts.notAContradiction);
          }
        } else if (threePremiseRules.includes(rule)) {
          if (premises.length !== 3) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 3)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          if (premises.length !== 2) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 2)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          if (premises.length !== 1) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 1)
            );
            return;
          }
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }

        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
              sourcePremises: premisesData, // source ì •ë³´ ì¶”ê°€
            });
          });
          // ì¶”ë¡  ê·œì¹™ ì ìš© ì„±ê³µ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
          audioManager.playSfx("pop");
        } else if (
          rule !== "reductioAdAbsurdum" &&
          rule !== "conditionalIntroduction" &&
          conclusions.length === 0
        ) {
          showAlert(currentLang.alerts.ruleFailed);
        }

        renderModal();
        updateConclusionPreview();
      }

      function addTheoremsToList() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        if (selectedLis.length === 0) {
          showAlert(currentLang.alerts.noTheoremsToAdd);
          return;
        }

        const selectedPropsData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );

        let potentialTheorems = selectedPropsData.filter(
          (p) => p.type === "theorem" && !p.dependsOnAssumption
        );

        const trulyNewTheorems = potentialTheorems.filter((theoremData) => {
          const isAxiom = parsedAxioms.some((a) =>
            arePropositionsEqual(a.proposition, theoremData.proposition)
          );
          const isAlreadyProven = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          return !isAxiom && !isAlreadyProven;
        });

        if (trulyNewTheorems.length === 0) {
          showAlert(currentLang.alerts.duplicateProposition);
          return;
        }

        let theoremsAdded = 0;
        for (const theoremData of trulyNewTheorems) {
          const verificationResult = verifyAndExpandTruths(
            theoremData.proposition
          );

          if (verificationResult.success) {
            truePropositions.push({
              propId: `prop_${Date.now()}_${Math.random()}`, // âœ… ì´ ì¤„ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
            internalTruthSet = verificationResult.expandedSet;
            theoremsAdded++;
          } else {
            console.error(
              "Contradiction detected while adding a new theorem.",
              theoremData.proposition
            );
            showAlert(currentLang.alerts.contradictionFound);
            break;
          }
        }

        if (theoremsAdded > 0) {
          document.getElementById("eureka-modal").classList.remove("visible");
          render();
        }
      }

      function populatePuzzleLevels() {
        const grid = document.getElementById("puzzle-level-grid");
        grid.innerHTML = ""; // ê¸°ì¡´ ë ˆë²¨ ë²„íŠ¼ë“¤ ì´ˆê¸°í™”

        const clearedPuzzles =
          JSON.parse(localStorage.getItem("logos_cleared_puzzles")) || {};

        Object.keys(PUZZLES).forEach((levelNum) => {
          const levelBtn = document.createElement("div");
          levelBtn.className = "puzzle-level-btn";
          levelBtn.textContent = levelNum;
          if (clearedPuzzles[levelNum]) {
            levelBtn.classList.add("cleared");
          }
          levelBtn.addEventListener("click", () => {
            audioManager.playSfx("hover");
            startPuzzle(levelNum, PUZZLES[levelNum]);
          });
          grid.appendChild(levelBtn);
        });
      }

      /**
       * ì„ íƒëœ ë ˆë²¨ ë°ì´í„°ë¡œ í¼ì¦ì„ ì‹œì‘í•©ë‹ˆë‹¤.
       * @param {object} levelData - PUZZLES ê°ì²´ì—ì„œ ê°€ì ¸ì˜¨ ë ˆë²¨ ì •ë³´
       */
      function startPuzzle(levelNum, levelData) {
        currentPuzzleLevel = levelNum;

        const masterDeck = currentLang.cards;
        // 'ì†Œí¬ë¼í…ŒìŠ¤ëŠ”', 'í”Œë¼í†¤ì€' ì¹´ë“œë¥¼ ê¸°ë³¸ ë±ì—ì„œ ì°¾ìŠµë‹ˆë‹¤.
        const socratesCard = masterDeck.find(
          (c) => c.text === currentLang.keywords.socrates
        );
        const platoCard = masterDeck.find(
          (c) => c.text === currentLang.keywords.plato
        );
        // ëª¨ë“  ì² í•™ì ì´ë¦„ì„ ì œì™¸í•œ ê¸°ë³¸ ì¹´ë“œ ëª©ë¡ì„ ë§Œë“­ë‹ˆë‹¤.
        const allPhilosopherCardTexts = Object.values(PHILOSOPHERS).map(
          (p) => p.cardText[currentLang.langCode]
        );
        const baseDeck = masterDeck.filter(
          (card) => !allPhilosopherCardTexts.includes(card.text)
        );
        // ê¸°ë³¸ ì¹´ë“œ ëª©ë¡ì— ì†Œí¬ë¼í…ŒìŠ¤ì™€ í”Œë¼í†¤ ì¹´ë“œë§Œ ì¶”ê°€í•˜ì—¬ fullDeckì„ ì¬ì„¤ì •í•©ë‹ˆë‹¤.
        fullDeck = [...baseDeck, socratesCard, platoCard];

        // 1. í¼ì¦ì— í•„ìš”í•œ ê³µë¦¬ë¥¼ ë¨¼ì € ìƒì„±í•©ë‹ˆë‹¤. (íŠœí† ë¦¬ì–¼ ë¡œì§ ì¬í™œìš©)
        const socratesSubject = currentLang.keywords.socrates;
        const platoSubject = currentLang.keywords.plato;
        currentAxioms = generateAxioms(
          socratesSubject,
          platoSubject,
          currentLang
        );
        parsedAxioms = currentAxioms
          .map((str) => ({
            type: "axiom",
            proposition: parsePropositionFromString(str),
          }))
          .filter((a) => a.proposition);

        inPuzzleMode = true;
        document
          .getElementById("puzzle-level-select-modal")
          .classList.remove("visible");

        // í¼ì¦ ëª©í‘œ ë©”ì‹œì§€ ë°•ìŠ¤ í‘œì‹œ ë° ë‚´ìš© ì±„ìš°ê¸°
        const goalBox = document.getElementById("puzzle-goal-box");
        const goalText = document.getElementById("puzzle-goal-text"); // p íƒœê·¸ë¥¼ ì„ íƒ

        goalText.innerHTML = levelData.goalDescription[currentLang.langCode]; // p íƒœê·¸ì— í…ìŠ¤íŠ¸ ì„¤ì •
        goalBox.classList.remove("hidden"); // ì „ì²´ ë°•ìŠ¤ë¥¼ ë³´ì´ê²Œ í•¨

        // í¼ì¦ ë°ì´í„°ë¡œ ê²Œì„ ìƒíƒœ ì„¤ì •
        truePropositions = [];

        // 1. ìŠ¹ë¦¬ ì¡°ê±´ ì„¤ì •
        const socratesVC_Text =
          levelData.victoryConditions.socrates[currentLang.langCode];
        const socratesVC_Parsed = parsePropositionFromString(socratesVC_Text);
        if (socratesVC_Parsed) {
          truePropositions.push({
            type: "victory",
            owner: "A",
            text: socratesVC_Text,
            proposition: socratesVC_Parsed,
            ultimate_target: {
              type: "atomic",
              subject: currentLang.keywords.socrates,
              predicate: currentLang.keywords.wins,
            },
          });
        }

        const platoVC_Text =
          levelData.victoryConditions.plato[currentLang.langCode];
        const platoVC_Parsed = parsePropositionFromString(platoVC_Text);
        if (platoVC_Parsed) {
          truePropositions.push({
            type: "victory",
            owner: "B",
            text: platoVC_Text,
            proposition: platoVC_Parsed,
            ultimate_target: {
              type: "atomic",
              subject: currentLang.keywords.plato,
              predicate: currentLang.keywords.wins,
            },
          });
        }

        // 2. ì „ì œ ëª…ì œ ì„¤ì •
        const premises = levelData.premises[currentLang.langCode];
        premises.forEach((pText) => {
          const parsed = parsePropositionFromString(pText);
          if (parsed) {
            truePropositions.push({ type: "user-made", proposition: parsed });
          }
        });

        // 3. ë‚´ë¶€ ì§„ë¦¬ ì§‘í•© ì¬êµ¬ì„±
        internalTruthSet = parsedAxioms.map((a) => a.proposition);
        truePropositions.forEach((p) => internalTruthSet.push(p.proposition));
        internalTruthSet = verifyAndExpandTruths(
          null,
          internalTruthSet
        ).expandedSet;

        // 4. ìœ ë ˆì¹´ ëª¨ë‹¬ ë°”ë¡œ ì—´ê¸°
        openEurekaModal();
      }

      function proveVictory() {
        if (isThinkingTime) return;

        if (inPuzzleMode) {
          const myVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === "A"
          );
          const opponentVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === "B"
          );

          if (!myVictoryCondition || !opponentVictoryCondition) return;

          const myUltimateTarget = myVictoryCondition.ultimate_target;
          const opponentLossCondition = {
            type: "negation",
            proposition: opponentVictoryCondition.ultimate_target,
          };

          const isMyVictoryProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, myUltimateTarget)
          );
          const isOpponentLossProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, opponentLossCondition)
          );

          if (isMyVictoryProven || isOpponentLossProven) {
            try {
              // 1. ê¸°ì¡´ í´ë¦¬ì–´ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° (ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´)
              const clearedPuzzles =
                JSON.parse(localStorage.getItem("logos_cleared_puzzles")) || {};
              // 2. í˜„ì¬ í´ë¦¬ì–´í•œ í¼ì¦ ë²ˆí˜¸ ê¸°ë¡
              clearedPuzzles[currentPuzzleLevel] = true;
              // 3. ë‹¤ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
              localStorage.setItem(
                "logos_cleared_puzzles",
                JSON.stringify(clearedPuzzles)
              );
            } catch (e) {
              console.error("í¼ì¦ í´ë¦¬ì–´ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:", e);
            }

            showAlert(currentLang.alerts.puzzleCleared, () => {
              document
                .getElementById("eureka-modal")
                .classList.remove("visible");
              document
                .getElementById("puzzle-goal-box")
                .classList.add("hidden");
              inPuzzleMode = false;
              populatePuzzleLevels();
              document
                .getElementById("puzzle-level-select-modal")
                .classList.add("visible");
            });
          } else {
            showAlert(
              currentLang.alerts.proofIncomplete
                .replace("{myGoal}", propositionToPlainText(myUltimateTarget))
                .replace(
                  "{opponentGoal}",
                  propositionToPlainText(opponentLossCondition)
                )
            );
          }
          return; // í¼ì¦ ëª¨ë“œì¼ ê²½ìš° ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ
        }

        // --- íŠœí† ë¦¬ì–¼ ë§ˆì§€ë§‰ ë‹¨ê³„ ì„±ê³µ ì²˜ë¦¬ ë¡œì§ (ìƒˆë¡œ ì¶”ê°€ëœ ë¶€ë¶„) ---
        if (inTutorialMode && tutorialStep === 8) {
          const myVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === currentPlayer
          );
          const opponentPlayer = currentPlayer === "A" ? "B" : "A";
          const opponentVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === opponentPlayer
          );

          if (!myVictoryCondition || !opponentVictoryCondition) return;

          const myUltimateTarget = myVictoryCondition.ultimate_target;
          const opponentLossCondition = {
            type: "negation",
            proposition: opponentVictoryCondition.ultimate_target,
          };

          const isMyVictoryProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, myUltimateTarget)
          );
          const isOpponentLossProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, opponentLossCondition)
          );

          if (isMyVictoryProven || isOpponentLossProven) {
            // ì„±ê³µ ì‹œ, ìƒˆë¡œ ì¶”ê°€í•œ ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ë„ìš°ê³  í™•ì¸ì„ ëˆ„ë¥´ë©´ íŠœí† ë¦¬ì–¼ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.
            showAlert(currentLang.alerts.tutorialVictory, endTutorial);
          } else {
            // ì‹¤íŒ¨ ì‹œ, ê¸°ì¡´ì²˜ëŸ¼ ì¦ëª… ë¯¸ì™„ë£Œ ë©”ì‹œì§€ë¥¼ ë„ì›ë‹ˆë‹¤.
            showAlert(
              currentLang.alerts.proofIncomplete
                .replace("{myGoal}", propositionToPlainText(myUltimateTarget))
                .replace(
                  "{opponentGoal}",
                  propositionToPlainText(opponentLossCondition)
                )
            );
          }
          return; // íŠœí† ë¦¬ì–¼ ì¼€ì´ìŠ¤ ì²˜ë¦¬ê°€ ëë‚˜ë©´ í•¨ìˆ˜ë¥¼ ì¦‰ì‹œ ì¢…ë£Œí•©ë‹ˆë‹¤.
        }
        // --- íŠœí† ë¦¬ì–¼ ë¡œì§ ë ---

        // --- ì´í•˜ ê¸°ì¡´ì˜ ì¼ë°˜ ê²Œì„ ìŠ¹ë¦¬ ì¦ëª… ë¡œì§ ---
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        if (!myVictoryCondition) return;
        const myUltimateTarget = myVictoryCondition.ultimate_target;

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        if (!opponentVictoryCondition) return;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        const isMyVictoryProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, myUltimateTarget)
        );
        const isOpponentLossProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, opponentLossCondition)
        );

        if (isMyVictoryProven || isOpponentLossProven) {
          const newTheorems = derivedPropositionsInModal.filter(
            (p) =>
              p.type === "theorem" &&
              !p.dependsOnAssumption &&
              !truePropositions.some((existing) =>
                arePropositionsEqual(p.proposition, existing.proposition)
              )
          );

          for (const theoremData of newTheorems) {
            const verificationResult = verifyAndExpandTruths(
              theoremData.proposition
            );
            if (verificationResult.success) {
              internalTruthSet = verificationResult.expandedSet;
            } else {
              console.error(
                "ì¹˜ëª…ì  ì˜¤ë¥˜: ìŠ¹ë¦¬ ì¦ëª…ì— ì‚¬ìš©ëœ ì •ë¦¬ê°€ ê¸°ì¡´ ì‚¬ì‹¤ê³¼ ëª¨ìˆœë©ë‹ˆë‹¤.",
                theoremData
              );
              showAlert(currentLang.alerts.criticalErrorUndo);
              return;
            }
          }
          endGame(currentPlayer);
          return;
        }

        showAlert(
          currentLang.alerts.proofIncomplete
            .replace("{myGoal}", propositionToPlainText(myUltimateTarget))
            .replace(
              "{opponentGoal}",
              propositionToPlainText(opponentLossCondition)
            )
        );
      }

      function render() {
        if (playerA_Data && playerB_Data) {
          // ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
          const isMirrorMatch = playerA_Data.id === playerB_Data.id;
          if (isMirrorMatch) {
            // ë¯¸ëŸ¬ì „ì¼ ê²½ìš°
            document.getElementById("player-a-title").innerHTML = `âšªï¸ ${
              playerA_Data.name[currentLang.langCode]
            }(ë°±)`;
            document.getElementById("player-b-title").innerHTML = `âš«ï¸ ${
              playerB_Data.name[currentLang.langCode]
            }(í‘)`;
          } else {
            // ì¼ë°˜ ëŒ€ì „ì¼ ê²½ìš°
            document.getElementById("player-a-title").innerHTML = `âšªï¸ ${
              playerA_Data.name[currentLang.langCode]
            }`;
            document.getElementById("player-b-title").innerHTML = `âš«ï¸ ${
              playerB_Data.name[currentLang.langCode]
            }`;
          }
        }
        document.getElementById("round-display").textContent =
          currentLang.ui.roundDisplay.replace("{round}", currentRound);
        const handA_El = document.getElementById("player-a-hand"),
          handB_El = document.getElementById("player-b-hand");
        handA_El.innerHTML = "";
        handB_El.innerHTML = "";
        playerA_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        playerB_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        let lastTypeA = null;
        playerA_Hand.forEach((card) => {
          if (card.type !== lastTypeA) {
            if (lastTypeA !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handA_El.appendChild(br);
            }
            lastTypeA = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-white";
          cardEl.textContent = card.text;
          // ì‚¬ìœ  ì‹œê°„ì—ëŠ” ëª¨ë“  ì¹´ë“œë¥¼ ë¹„í™œì„±í™”
          if (isThinkingTime) {
            cardEl.classList.add("unplayable");
          } else {
            // ì‚¬ìœ  ì‹œê°„ì´ ì•„ë‹ ë•Œì˜ ê¸°ì¡´ ë¡œì§
            if (gameMode === "AI" && aiPlayer === "A") {
              cardEl.classList.add("ai-hand");
            } else {
              if (currentPlayer === "A" && !gameIsOver) {
                if (cardsPlayedThisTurn["A"] >= 1) {
                  cardEl.classList.add("unplayable");
                } else {
                  if (isValidPlay(card, currentProposition)) {
                    cardEl.addEventListener("click", () => {
                      if (!inTutorialMode) playCard("A", card);
                    });
                  } else {
                    cardEl.classList.add("unplayable");
                  }
                }
              }
            }
          }
          handA_El.appendChild(cardEl);
        });
        let lastTypeB = null;
        playerB_Hand.forEach((card) => {
          if (card.type !== lastTypeB) {
            if (lastTypeB !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handB_El.appendChild(br);
            }
            lastTypeB = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-black";
          cardEl.textContent = card.text;
          // ì‚¬ìœ  ì‹œê°„ì—ëŠ” ëª¨ë“  ì¹´ë“œë¥¼ ë¹„í™œì„±í™”
          if (isThinkingTime) {
            cardEl.classList.add("unplayable");
          } else {
            // ì‚¬ìœ  ì‹œê°„ì´ ì•„ë‹ ë•Œì˜ ê¸°ì¡´ ë¡œì§
            if (gameMode === "AI" && aiPlayer === "B") {
              cardEl.classList.add("ai-hand");
            } else {
              if (currentPlayer === "B" && !gameIsOver) {
                if (cardsPlayedThisTurn["B"] >= 1) {
                  cardEl.classList.add("unplayable");
                } else {
                  if (isValidPlay(card, currentProposition)) {
                    cardEl.addEventListener("click", () => {
                      if (!inTutorialMode) playCard("B", card);
                    });
                  } else {
                    cardEl.classList.add("unplayable");
                  }
                }
              }
            }
          }
          handB_El.appendChild(cardEl);
        });
        const propositionEl = document.getElementById("proposition-display");
        propositionEl.innerHTML = "";
        currentProposition.forEach((info) => {
          const cardEl = document.createElement("div");
          const colorClass = info.player === "A" ? "card-white" : "card-black";
          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = info.card.text;
          propositionEl.appendChild(cardEl);
        });
        const trueList_El = document.getElementById("true-list");
        trueList_El.innerHTML = "";
        const liAxiom = document.createElement("li");
        liAxiom.className = "axiom-wrapper";
        const details = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = currentLang.ui.axiomTitle;
        details.appendChild(summary);
        const axiomContainer = document.createElement("div");
        axiomContainer.className = "axiom-list";

        // ê³µë¦¬ë“¤ì„ ê·¸ë£¹ë³„ë¡œ í‘œì‹œ
        if (currentAxioms.groups) {
          const groups = currentAxioms.groups;

          // ì •ì²´ì„± ê³µë¦¬
          if (groups.identity.length > 0) {
            groups.identity.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const separator = document.createElement("hr");
            separator.style.margin = "8px 0";
            separator.style.border = "none";
            separator.style.borderTop = "1px solid #ddd";
            axiomContainer.appendChild(separator);
          }

          // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ - ì„¸ë¶€ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.subjectOpposition.length > 0) {
            const templates = currentLang.axiom_templates;
            const subjectA = playerA_Data
              ? playerA_Data.cardText[currentLang.langCode]
              : "";
            const subjectB = playerB_Data
              ? playerB_Data.cardText[currentLang.langCode]
              : "";

            // ì²« ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            templates.subject_good_evil.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectA);
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep1 = document.createElement("hr");
            sep1.style.margin = "4px 0";
            sep1.style.border = "none";
            sep1.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep1);

            // ì²« ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            templates.subject_wise_foolish.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectA);
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep2 = document.createElement("hr");
            sep2.style.margin = "4px 0";
            sep2.style.border = "none";
            sep2.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep2);

            // ë‘ ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            templates.subject_good_evil.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectB);
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep3 = document.createElement("hr");
            sep3.style.margin = "4px 0";
            sep3.style.border = "none";
            sep3.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep3);

            // ë‘ ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            templates.subject_wise_foolish.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectB);
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const separator = document.createElement("hr");
            separator.style.margin = "8px 0";
            separator.style.border = "none";
            separator.style.borderTop = "1px solid #ddd";
            axiomContainer.appendChild(separator);
          }

          // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ - ì„¸ë¶€ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.quantifierOpposition.length > 0) {
            const templates = currentLang.axiom_templates;

            // ìƒˆ ì§‘ë‹¨ ìˆœë°©í–¥
            templates.bird_good_evil_forward.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep4 = document.createElement("hr");
            sep4.style.margin = "4px 0";
            sep4.style.border = "none";
            sep4.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep4);

            // ìƒˆ ì§‘ë‹¨ ì—­ë°©í–¥
            templates.bird_good_evil_reverse.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep5 = document.createElement("hr");
            sep5.style.margin = "4px 0";
            sep5.style.border = "none";
            sep5.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep5);

            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ìˆœë°©í–¥
            templates.fish_good_evil_forward.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep6 = document.createElement("hr");
            sep6.style.margin = "4px 0";
            sep6.style.border = "none";
            sep6.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep6);

            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ì—­ë°©í–¥
            templates.fish_good_evil_reverse.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep7 = document.createElement("hr");
            sep7.style.margin = "4px 0";
            sep7.style.border = "none";
            sep7.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep7);

            // ê°œ ì§‘ë‹¨ ìˆœë°©í–¥
            templates.dog_good_evil_forward.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep8 = document.createElement("hr");
            sep8.style.margin = "4px 0";
            sep8.style.border = "none";
            sep8.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep8);

            // ê°œ ì§‘ë‹¨ ì—­ë°©í–¥
            templates.dog_good_evil_reverse.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `â€¢ ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            // ë§ˆë¥´í¬ìŠ¤ ê³µë¦¬ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            if (
              currentAxioms.some(
                (axiom) =>
                  axiom.includes("ë¸Œë£¨ì£¼ì•„") || axiom.includes("Bourgeois")
              )
            ) {
              const sep9 = document.createElement("hr");
              sep9.style.margin = "4px 0";
              sep9.style.border = "none";
              sep9.style.borderTop = "1px solid #ccc";
              axiomContainer.appendChild(sep9);

              currentAxioms
                .filter(
                  (axiom) =>
                    axiom.includes("ë¸Œë£¨ì£¼ì•„") || axiom.includes("Bourgeois")
                )
                .forEach((axiomText) => {
                  const p = document.createElement("p");
                  p.textContent = `â€¢ ${axiomText}`;
                  axiomContainer.appendChild(p);
                });
            }
          }
        } else {
          // ê¸°ì¡´ ë°©ì‹ (í•˜ìœ„ í˜¸í™˜ì„±)
          currentAxioms.forEach((axiomText) => {
            const p = document.createElement("p");
            p.textContent = `â€¢ ${axiomText}`;
            axiomContainer.appendChild(p);
          });
        }

        details.appendChild(axiomContainer);
        liAxiom.appendChild(details);
        trueList_El.appendChild(liAxiom);

        truePropositions.forEach((propData) => {
          if (propData.source === "nietzsche_ability") {
            console.log("ë‹ˆì²´ ëª…ì œ ë Œë”ë§ ì‹œì : ", propData);
          }
          const li = document.createElement("li");

          // ì´ì œ propDataì— IDê°€ ìˆëŠ”ì§€, ê·¸ë¦¬ê³  ê·¸ IDê°€ ë¹„í™œì„±í™” ëª©ë¡ì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
          const isDisabled =
            propData.propId &&
            socratesDisabledProps.some((dp) => dp.propId === propData.propId);

          if (isDisabled) {
            li.classList.add("socrates-disabled");
          }

          if (propData.type === "victory") {
            li.classList.add("victory-condition");

            if (propData.source === "marx_revolution") {
              li.classList.add("marx-victory-condition");
            }
            const ownerName = getLastName(
              propData.owner === "A"
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data.name[currentLang.langCode]
            );
            const ownerPrefix =
              propData.owner === "A" ? `âšªï¸ ${ownerName}` : `âš«ï¸ ${ownerName}`;
            li.innerHTML = currentLang.labels.victory_text
              .replace("{owner}", ownerPrefix)
              .replace("{text}", propData.text);
          } else if (propData.type === "user-made") {
            // 1. ëª¨ë“  'user-made' ëª…ì œì— ëŒ€í•´ ë‹¨ì–´ ìƒ‰ìƒì„ ë¨¼ì € ì…í™ë‹ˆë‹¤.
            if (propData.original_cards && propData.original_cards.length > 0) {
              propData.original_cards.forEach((info) => {
                const wordSpan = document.createElement("span");
                wordSpan.textContent = info.card.text + " ";
                wordSpan.className = info.player === "A" ? "word-a" : "word-b";
                li.appendChild(wordSpan);
              });
            } else if (propData.proposition) {
              li.textContent = propositionToPlainText(propData.proposition);
            }

            // 2. ë§Œì•½ ë‹ˆì²´ì˜ ëŠ¥ë ¥ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ëª…ì œë¼ë©´, ìŠ¤íƒ€ì¼ í´ë˜ìŠ¤ì™€ ë¼ë²¨ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
            if (propData.source === "nietzsche_ability") {
              li.classList.add("nietzsche-theorem"); // [ì¶”ê°€] ë‹ˆì²´ ëª…ì œì— ì „ìš© í´ë˜ìŠ¤ ì¶”ê°€

              const rawLabel = currentLang.labels.nietzsche_ability_source;
              const labelText = rawLabel.replace("{text}", "").trim();

              const labelSpan = document.createElement("span");
              labelSpan.textContent = ` ${labelText}`;
              li.appendChild(labelSpan);
            }
          } else if (propData.type === "theorem") {
            let theoremText = propositionToPlainText(propData.proposition);

            // 2. ì •ê·œì‹ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ê´„í˜¸ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
            let strippedText = theoremText.replace(/\(|\)/g, "");

            // 3. ëŠ¥ë ¥ì˜ ì¢…ë¥˜ì— ë”°ë¼ ì ì ˆí•œ ë¼ë²¨ì„ ë¶™ì—¬ ìµœì¢… í…ìŠ¤íŠ¸ë¥¼ ì™„ì„±í•©ë‹ˆë‹¤.
            if (propData.source === "plato_ability") {
              li.classList.add("plato-theorem");
              li.textContent = currentLang.labels.plato_ability_source.replace(
                "{text}",
                strippedText // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
              );
            } else if (propData.source === "wittgenstein_ability") {
              li.classList.add("wittgenstein-theorem");
              li.textContent =
                currentLang.labels.wittgenstein_ability_source.replace(
                  "{text}",
                  strippedText // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
                );
            } else if (propData.source === "derrida_ability") {
              li.classList.add("derrida-theorem");
              li.textContent =
                currentLang.labels.derrida_ability_source.replace(
                  "{text}",
                  strippedText // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
                );
            } else if (propData.source === "hume_ability") {
              li.classList.add("hume-theorem");
              li.textContent = currentLang.labels.hume_ability_source.replace(
                "{text}",
                strippedText // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
              );
            } else if (propData.source === "kuhn_ability") {
              li.classList.add("kuhn-theorem");
              li.textContent = currentLang.labels.kuhn_ability_source.replace(
                "{text}",
                strippedText // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
              );
            } else if (propData.source === "kant_ability") {
              li.classList.add("kant-theorem");
              li.textContent = currentLang.labels.kant_ability_source.replace(
                "{text}",
                strippedText // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
              );
            } else {
              // ì¼ë°˜ì ì¸ ì •ë¦¬ì¼ ê²½ìš°
              li.classList.add("theorem");
              li.textContent = currentLang.labels.theorem_source
                .replace("{text}", strippedText) // ê´„í˜¸ê°€ ëª¨ë‘ ì œê±°ëœ í…ìŠ¤íŠ¸ ì‚¬ìš©
                .replace("{round}", propData.round);
            }
          }

          if (isDisabled) {
            li.textContent +=
              currentLang.langCode === "ko"
                ? " (ë¬´ì§€ì˜ ìê°)"
                : " (Awareness of Ignorance)";
          }

          trueList_El.appendChild(li);
        });

        const playerATitleBox = document.querySelector(
          "#player-a-area .player-title-box"
        );
        const playerBTitleBox = document.querySelector(
          "#player-b-area .player-title-box"
        );

        if (playerATitleBox && playerBTitleBox) {
          // ì‚¬ìœ  ì‹œê°„ì¸ì§€ ì¼ë°˜ í„´ì¸ì§€ì— ë”°ë¼ í˜„ì¬ í™œì„±í™”ëœ í”Œë ˆì´ì–´ë¥¼ ê²°ì •
          const activePlayer = isThinkingTime
            ? thinkingTimeTurn
            : currentPlayer;

          // ê²Œì„ì˜¤ë²„ê°€ ì•„ë‹ ë•Œ, í™œì„±í™”ëœ í”Œë ˆì´ì–´ì—ê²Œë§Œ 'active-turn' í´ë˜ìŠ¤ë¥¼ ì ìš©
          playerATitleBox.classList.toggle(
            "active-turn",
            activePlayer === "A" && !gameIsOver
          );
          playerBTitleBox.classList.toggle(
            "active-turn",
            activePlayer === "B" && !gameIsOver
          );
        }

        const statusEl = document.getElementById("status");
        const mainCenter = document.querySelector(".main-center-bg");

        if (mainCenter && !mainCenter.classList.contains("hidden")) {
          statusEl.innerHTML = "";
        } else {
          const playerAreaA = document.getElementById("player-a-area"),
            playerAreaB = document.getElementById("player-b-area");
          const eurekaBtnA = document.getElementById("eureka-a"),
            eurekaBtnB = document.getElementById("eureka-b");
          const completeBtn = document.getElementById("complete-btn"),
            undoBtn = document.getElementById("undo-btn"),
            endTurnBtn = document.getElementById("end-turn-btn");

          let winnerName = "";
          if (gameIsOver) {
            statusEl.style.color = "#c0392b";
            playerAreaA.classList.add("disabled");
            playerAreaB.classList.add("disabled");
            eurekaBtnA.disabled = true;
            eurekaBtnB.disabled = true;
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled = true;
          } else if (isThinkingTime) {
            // 1. ì „ìš© UIì˜ ì œëª©ê³¼ ì„¤ëª…ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
            document.getElementById("thinking-time-title").textContent =
              currentLang.ui.thinkingTimeTitle;
            document.getElementById("thinking-time-desc").innerHTML =
              currentLang.ui.thinkingTimeDesc;

            // 2. í•˜ë‹¨ ìƒíƒœë°”ì— í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
            const thinkingPlayerName = getLastName(
              thinkingTimeTurn === "A"
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data.name[currentLang.langCode]
            );
            const thinkingPlayerColor =
              thinkingTimeTurn === "A" ? "âšªï¸" : "âš«ï¸";
            statusEl.innerHTML = `<span class="turn-indicator">${thinkingPlayerColor} ${thinkingPlayerName}${currentLang.ui.thinkingTimeTurnMessage}</span>`;

            // 3. í˜„ì¬ í„´ì¸ í”Œë ˆì´ì–´ì˜ ì˜ì—­ë§Œ í™œì„±í™”í•©ë‹ˆë‹¤.
            if (thinkingTimeTurn === "A") {
              playerAreaA.classList.remove("disabled");
              playerAreaB.classList.add("disabled");
              eurekaBtnA.disabled = gameMode === "AI" && aiPlayer === "A";
              eurekaBtnB.disabled = true;
            } else {
              // thinkingTimeTurn === 'B'
              playerAreaA.classList.add("disabled");
              playerAreaB.classList.remove("disabled");
              eurekaBtnA.disabled = true;
              eurekaBtnB.disabled = gameMode === "AI" && aiPlayer === "B";
            }

            // 'ìœ ë ˆì¹´!' ë²„íŠ¼ í…ìŠ¤íŠ¸ë¥¼ 'ì •ë¦¬ ì¶”ê°€'ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
            eurekaBtnA.textContent = currentLang.ui.addTheoremButton;
            eurekaBtnB.textContent = currentLang.ui.addTheoremButton;

            // 4. ì¤‘ì•™ í•˜ë‹¨ì˜ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ìƒíƒœë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
            // 'ëª…ì œ ì™„ì„±', 'ë˜ëŒë¦¬ê¸°' ë²„íŠ¼ì€ ë¹„í™œì„±í™”í•˜ê³ , 'í„´ ì¢…ë£Œ' ë²„íŠ¼ì€ í™œì„±í™”í•©ë‹ˆë‹¤.
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled =
              (gameMode === "AI" && thinkingTimeTurn === aiPlayer) ||
              (inTutorialMode && thinkingTimeTurn !== "A");
          } else {
            statusEl.style.color = "#333";
            eurekaBtnA.textContent = currentLang.ui.eurekaButton;
            eurekaBtnB.textContent = currentLang.ui.eurekaButton;
            const isAITurn = gameMode === "AI" && currentPlayer === aiPlayer;
            const isCompletable =
              currentProposition.length > 0 &&
              parsePropositionFromCards(currentProposition) !== null;

            if (isAITurn) {
              statusEl.innerHTML = `<span class="turn-indicator">${currentLang.ui.statusAITurn}</span>`;
              playerAreaA.classList.add("disabled");
              playerAreaB.classList.add("disabled");
              eurekaBtnA.disabled = true;
              eurekaBtnB.disabled = true;
              completeBtn.disabled = true;
              undoBtn.disabled = true;
              endTurnBtn.disabled = true;
            } else {
              if (currentPlayer === "A") {
                const playerAName = playerA_Data
                  ? getLastName(playerA_Data.name[currentLang.langCode])
                  : currentLang.ui.playerAName;
                statusEl.innerHTML = `<span class="turn-indicator">âšªï¸ ${playerAName}${currentLang.ui.statusTurn}</span>`;
                playerAreaA.classList.remove("disabled");
                playerAreaB.classList.add("disabled");
                // â­ï¸ í•µì‹¬ ìˆ˜ì •: eurekaUsedInRound['A']ê°€ trueì´ë©´ ë²„íŠ¼ ë¹„í™œì„±í™”
                eurekaBtnA.disabled = eurekaUsedInRound["A"];
                eurekaBtnB.disabled = true;
              } else {
                const playerBName = playerB_Data
                  ? getLastName(playerB_Data.name[currentLang.langCode])
                  : currentLang.ui.playerBName;
                statusEl.innerHTML = `<span class="turn-indicator">âš«ï¸ ${playerBName}${currentLang.ui.statusTurn}</span>`;
                playerAreaB.classList.remove("disabled");
                playerAreaA.classList.add("disabled");
                eurekaBtnA.disabled = true;
                // â­ï¸ í•µì‹¬ ìˆ˜ì •: eurekaUsedInRound['B']ê°€ trueì´ë©´ ë²„íŠ¼ ë¹„í™œì„±í™”
                eurekaBtnB.disabled = eurekaUsedInRound["B"];
              }
              completeBtn.disabled =
                !isCompletable || lastCardPlayer === currentPlayer;
              undoBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
              endTurnBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
            }
          }
          updateAbilityButtonsState();
        }
      }

      function setupTutorialScenario(step) {
        if (step === 4) {
          // 4ë‹¨ê³„ëŠ” 'ì‚¬ìœ  ì‹œê°„' íŠœí† ë¦¬ì–¼ì´ë¯€ë¡œ, ì‚¬ìœ  ì‹œê°„ ìŒì•…ìœ¼ë¡œ ë³€ê²½
          audioManager.fadeOut("game-play");
          audioManager.play("thinking-time");
        } else if (step === 5) {
          // 5ë‹¨ê³„ëŠ” ë‹¤ì‹œ ì¼ë°˜ ê²Œì„ ê·œì¹™ìœ¼ë¡œ ëŒì•„ì˜¤ë¯€ë¡œ, ê²Œì„ ìŒì•…ìœ¼ë¡œ ë³€ê²½
          audioManager.fadeOut("thinking-time");
          audioManager.play("game-play");
        }
        if (step === 1) {
          playerA_Hand = [];
          playerB_Hand = [];
          truePropositions = [];

          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );

          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);

          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          const {
            if: ifKeyword,
            and: andKeyword,
            wins: winsKeyword,
            socrates: socratesKeyword,
            plato: platoKeyword,
          } = currentLang.keywords;

          const goodPredicate =
            currentLang.langCode === "ko" ? "ì„ í•˜ë‹¤" : "is good";
          const evilPredicate =
            currentLang.langCode === "ko" ? "ì•…í•˜ë‹¤" : "is evil";

          // ì†Œí¬ë¼í…ŒìŠ¤ ìŠ¹ë¦¬ ì¡°ê±´
          const socratesVCText = `((${socratesKeyword} ${goodPredicate}) ${ifKeyword} (${socratesKeyword} ${winsKeyword})) ${andKeyword} ((${socratesKeyword} ${winsKeyword}) ${ifKeyword} (${socratesKeyword} ${goodPredicate}))`;
          const parsedSocratesVC = parsePropositionFromString(socratesVCText);
          if (parsedSocratesVC) {
            truePropositions.push({
              type: "victory",
              text: socratesVCText,
              owner: "A",
              proposition: parsedSocratesVC,
              ultimate_target: {
                type: "atomic",
                subject: socratesKeyword,
                predicate: winsKeyword,
              },
              core_goal: {
                type: "atomic",
                subject: socratesKeyword,
                predicate: goodPredicate,
              },
            });
            internalTruthSet.push(parsedSocratesVC);
          }

          // í”Œë¼í†¤ ìŠ¹ë¦¬ ì¡°ê±´
          const platoVCText = `((${platoKeyword} ${evilPredicate}) ${ifKeyword} (${platoKeyword} ${winsKeyword})) ${andKeyword} ((${platoKeyword} ${winsKeyword}) ${ifKeyword} (${platoKeyword} ${evilPredicate}))`;
          const parsedPlatoVC = parsePropositionFromString(platoVCText);
          if (parsedPlatoVC) {
            truePropositions.push({
              type: "victory",
              text: platoVCText,
              owner: "B",
              proposition: parsedPlatoVC,
              ultimate_target: {
                type: "atomic",
                subject: platoKeyword,
                predicate: winsKeyword,
              },
              core_goal: {
                type: "atomic",
                subject: platoKeyword,
                predicate: evilPredicate,
              },
            });
            internalTruthSet.push(parsedPlatoVC);
          }
          currentProposition = [];
          currentPlayer = "A";
          propositionStarter = "A";
          gameIsOver = false;
          currentRound = 1;
          isThinkingTime = false;
          lastPropositionMaker = null;
          currentAssumption = null;
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          gameMode = "2P";

          // íŠœí† ë¦¬ì–¼ì„ ìœ„í•œ ê¸°ë³¸ ì² í•™ì ë°ì´í„° ì„¤ì •
          playerA_Data = PHILOSOPHERS["socrates"];
          playerB_Data = PHILOSOPHERS["plato"];

          const portraitA_El = document.getElementById("player-a-portrait");
          if (portraitA_El) {
            portraitA_El.style.backgroundImage = `url('${playerA_Data.image.p1}')`;
          }
          const portraitB_El = document.getElementById("player-b-portrait");
          if (portraitB_El) {
            portraitB_El.style.backgroundImage = `url('${playerB_Data.image.p2}')`;
          }

          const socratesCardText = currentLang.keywords.socrates;
          const requiredA_CardTexts = [
            socratesCardText,
            currentLang.keywords.and,
            currentLang.keywords.or,
            currentLang.keywords.if,
            currentLang.keywords.not,
            currentLang.langCode === "ko" ? "ê°œëŠ”" : "dog",
            currentLang.langCode === "ko" ? "ìƒˆëŠ”" : "bird",
            currentLang.langCode === "ko" ? "ë¬¼ê³ ê¸°ëŠ”" : "fish",
            currentLang.keywords.universal_q,
            currentLang.keywords.existential_q,
          ];
          playerA_Hand = fullDeck.filter((c) =>
            requiredA_CardTexts.includes(c.text)
          );

          const wiseCardText =
            currentLang.langCode === "ko" ? "ì§€í˜œë¡­ë‹¤" : "is wise";
          const requiredB_CardTexts = [
            wiseCardText,
            currentLang.keywords.plato,
          ];
          playerB_Hand = fullDeck.filter((c) =>
            requiredB_CardTexts.includes(c.text)
          );
          playerB_Hand.push(
            ...fullDeck
              .filter(
                (c) =>
                  !requiredB_CardTexts.includes(c.text) &&
                  c.type ===
                    (currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate")
              )
              .slice(0, 2)
          );
        } else if (step === 2) {
          const socratesCardInfo = currentProposition.find(
            (info) => info.card.text === currentLang.keywords.socrates
          );
          const wiseCardText =
            currentLang.langCode === "ko" ? "ì§€í˜œë¡­ë‹¤" : "is wise";
          const wiseCardIndex = playerB_Hand.findIndex(
            (c) => c.text === wiseCardText
          );

          if (socratesCardInfo && wiseCardIndex > -1) {
            const [wiseCard] = playerB_Hand.splice(wiseCardIndex, 1);
            currentProposition = [
              socratesCardInfo,
              { card: wiseCard, player: "B" },
            ];
            lastCardPlayer = "B";
            currentPlayer = "A";
          }
        } else if (step === 4) {
          currentProposition = [];
          playerA_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "ì—°ì‚°ì" : "Operator") &&
              c.text !== currentLang.keywords.not
          );
          playerB_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "ì„œìˆ ì–´" : "Predicate") &&
              c.text !== (currentLang.langCode === "ko" ? "ê°œì´ë‹¤" : "is a dog")
          );

          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);

          const premises = [
            currentLang.langCode === "ko"
              ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ê°œì´ë‹¤"
              : "Socrates is a dog",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤"
              : "Every dog is wise",
          ];
          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          startThinkingTime();
        } else if (step === 5) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises = [
            currentLang.langCode === "ko"
              ? "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤"
              : "Socrates is good",
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤) ë¼ë©´ (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤)"
              : "(Socrates is good) then (Socrates wins)",
            currentLang.langCode === "ko"
              ? "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Plato is wise is false",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)"
              : "(Plato wins) then (Plato is wise)",
            currentLang.langCode === "ko"
              ? "(ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤) ë˜ëŠ” (ì–´ë–¤ ìƒˆëŠ” ìƒˆì´ë‹¤)"
              : "(Some bird is a fish) or (Some bird is a bird)",
            currentLang.langCode === "ko"
              ? "ì–´ë–¤ ìƒˆëŠ” ë¬¼ê³ ê¸°ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Some bird is a fish is false",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)"
              : "(Plato is a dog) then (Plato is good)",
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤)"
              : "(Plato is good) then (Plato wins)",
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)"
              : "(Socrates is wise) and (Plato is foolish)",
            currentLang.langCode === "ko"
              ? "ì–´ë–¤ ë¬¼ê³ ê¸°ëŠ” ì„ í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤"
              : "Some fish is good is false is false",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ìƒˆëŠ” ì„ í•˜ë‹¤"
              : "Every bird is good",
            currentLang.langCode === "ko"
              ? "í”Œë¼í†¤ì€ ìƒˆì´ë‹¤"
              : "Plato is a bird",
            currentLang.langCode === "ko"
              ? "ëª¨ë“  ê°œëŠ” ì„ í•˜ë‹¤"
              : "Every dog is good",
          ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
        } else if (step === 6) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises =
            currentLang.langCode === "ko"
              ? [
                  "í”Œë¼í†¤ì€ ì„ í•˜ë‹¤ ë˜ëŠ” í”Œë¼í†¤ì€ ì•…í•˜ë‹¤",
                  "(í”Œë¼í†¤ì€ ì„ í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                  "(í”Œë¼í†¤ì€ ì•…í•˜ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                ]
              : [
                  "Plato is good or Plato is evil",
                  "(Plato is good) then (Plato is wise)",
                  "(Plato is evil) then (Plato is wise)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 7) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì§€í˜œë¡­ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ê°œì´ë‹¤)",
                  "(í”Œë¼í†¤ì€ ê°œì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì„ í•˜ë‹¤)",
                ]
              : [
                  "(Socrates is wise) then (Plato is a dog)",
                  "(Plato is a dog) then (Plato is good)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: propositionToNaturalText(parsed),
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 8) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤) ë¼ë©´ (í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤)",
                  "í”Œë¼í†¤ì€ ì§€í˜œë¡­ë‹¤ ëŠ” ê±°ì§“ì´ë‹¤",
                ]
              : [
                  "(Socrates is evil is false) then (Plato is wise)",
                  "Plato is wise is false",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 9) {
          // Stage 9 - Final Puzzle
          truePropositions = [];

          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );
          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);

          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          // ìŠ¹ë¦¬ ì¡°ê±´ ì„¤ì •
          const socratesVC_Text =
            currentLang.langCode === "ko"
              ? "(ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì„ í•˜ë‹¤)"
              : "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)";
          const socratesVC_Parsed = parsePropositionFromString(socratesVC_Text);
          if (socratesVC_Parsed) {
            truePropositions.push({
              type: "victory",
              owner: "A",
              text: propositionToPlainText(socratesVC_Parsed),
              proposition: socratesVC_Parsed,
              ultimate_target: {
                type: "atomic",
                subject: currentLang.keywords.socrates,
                predicate: currentLang.keywords.wins,
              },
              core_goal: {
                type: "atomic",
                subject: currentLang.keywords.socrates,
                predicate: currentLang.langCode === "ko" ? "ì„ í•˜ë‹¤" : "is good",
              },
            });
            internalTruthSet.push(socratesVC_Parsed);
          }

          const platoVC_Text =
            currentLang.langCode === "ko"
              ? "(í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤) ê·¸ë¦¬ê³  (í”Œë¼í†¤ì€ ìŠ¹ë¦¬í•œë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ì–´ë¦¬ì„ë‹¤)"
              : "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)";
          const platoVC_Parsed = parsePropositionFromString(platoVC_Text);
          if (platoVC_Parsed) {
            truePropositions.push({
              type: "victory",
              owner: "B",
              text: propositionToPlainText(platoVC_Parsed),
              proposition: platoVC_Parsed,
              ultimate_target: {
                type: "atomic",
                subject: currentLang.keywords.plato,
                predicate: currentLang.keywords.wins,
              },
              core_goal: {
                type: "atomic",
                subject: currentLang.keywords.plato,
                predicate:
                  currentLang.langCode === "ko" ? "ì–´ë¦¬ì„ë‹¤" : "is foolish",
              },
            });
            internalTruthSet.push(platoVC_Parsed);
          }

          // ì „ì œ ëª…ì œ ì„¤ì •
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "ì†Œí¬ë¼í…ŒìŠ¤ëŠ” ì•…í•˜ë‹¤ ë¼ë©´ ëª¨ë“  ê°œëŠ” ì–´ë¦¬ì„ë‹¤",
                  "ì–´ë–¤ ê°œëŠ” ì§€í˜œë¡­ë‹¤ ë¼ë©´ í”Œë¼í†¤ì€ ê°œì´ë‹¤",
                  "ëª¨ë“  ê°œëŠ” ì§€í˜œë¡­ë‹¤",
                ]
              : [
                  "(Socrates is evil) then (Every dog is foolish)",
                  "(Some dog is wise) then (Plato is a dog)",
                  "Every dog is wise",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });

          openEurekaModalTutorial();
        }

        render();
      }

      function renderModal() {
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const hasAssumption = !!currentAssumption;
        document.getElementById("add-assumption-btn").disabled = hasAssumption;
        document.getElementById("cancel-assumption-btn").style.display =
          hasAssumption ? "inline-block" : "none";

        derivedPropositionsInModal.forEach((propData) => {
          // êµ¬ë¶„ì„ ì¸ ê²½ìš° íŠ¹ë³„íˆ ì²˜ë¦¬
          if (propData.isSeparator) {
            const li = document.createElement("li");
            li.style.height = "8px";
            li.style.background = "transparent";
            li.style.border = "none";
            li.style.padding = "0";
            li.style.margin = "4px 0";
            li.style.pointerEvents = "none"; // í´ë¦­ ë¶ˆê°€ëŠ¥
            li.style.listStyle = "none";
            li.innerHTML = "<hr style='border: none; border-top: 1px solid rgba(221, 221, 221, 0.3); margin: 0;'>";
            premiseList.appendChild(li);
            return;
          }
          
          const li = document.createElement("li");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          li.dataset.propObject = JSON.stringify(propData);

          if (propData.isAssumption) li.classList.add("assumption-itself");
          else if (propData.dependsOnAssumption)
            li.classList.add("assumption-dependent");

          // ì²´í¬ë°•ìŠ¤ ë¹„í™œì„±í™”ëŠ” handleTutorialRuleApplicationì—ì„œ ì²˜ë¦¬

          li.appendChild(checkbox);
          let tagClass = "";
          // propData.typeì— ë”°ë¼ ì ì ˆí•œ CSS í´ë˜ìŠ¤ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.
          switch (propData.type) {
            case "axiom":
              tagClass = "tag-axiom";
              break;
            case "victory":
              tagClass = "tag-victory";
              break;
            case "theorem":
              tagClass = "tag-theorem";
              break;
            case "assumption": // ê°€ì •ì„ ìœ„í•œ case ë¶„ë¦¬
              tagClass = "tag-assumption";
              break;
            default: // "user-made" ë“± ë‚˜ë¨¸ì§€ëŠ” "proposition"ìœ¼ë¡œ ì²˜ë¦¬
              tagClass = "tag-proposition";
              break;
          }

          // í´ë˜ìŠ¤ê°€ ì ìš©ëœ span íƒœê·¸ë¡œ ê°ì‹¸ì„œ HTMLì— ì¶”ê°€í•©ë‹ˆë‹¤.
          li.innerHTML += ` <span class="${tagClass}">${
            propData.label
          }</span> ${propositionToNaturalText(propData.proposition)}`;

          premiseList.appendChild(li);
        });
      }
      function updateConclusionPreview() {
        const titleEl = document.getElementById("conclusion-preview-title");
        const textEl = document.getElementById("conclusion-preview-text");

        // UI í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ë‹¤êµ­ì–´ ì§€ì›)
        titleEl.innerHTML =
          currentLang.langCode === "ko"
            ? "<strong>ê²°ë¡  ë¯¸ë¦¬ë³´ê¸°</strong>"
            : "<strong>Conclusion Preview</strong>";

        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premises = selectedLis
          .map((chk) => {
            const propString = chk.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString).proposition : null;
          })
          .filter(Boolean);

        let conclusion = null;
        let requiredPremises = 0;

        // ê° ê·œì¹™ì— í•„ìš”í•œ ì „ì œ ê°œìˆ˜ í™•ì¸
        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (onePremiseRules.includes(rule)) requiredPremises = 1;
        else if (twoPremiseRules.includes(rule)) requiredPremises = 2;
        else if (threePremiseRules.includes(rule)) requiredPremises = 3;
        else if (rule === "conditionalIntroduction") requiredPremises = 1;
        else if (rule === "reductioAdAbsurdum") requiredPremises = 2;

        if (premises.length === requiredPremises && requiredPremises > 0) {
          try {
            if (rule === "conditionalIntroduction") {
              if (currentAssumption) {
                conclusion = {
                  type: "conditional",
                  left: currentAssumption,
                  right: premises[0],
                };
              }
            } else if (rule === "reductioAdAbsurdum") {
              conclusion = reductioAdAbsurdum(
                premises[0],
                premises[1],
                currentAssumption
              );
            } else if (threePremiseRules.includes(rule)) {
              conclusion = window[rule](premises[0], premises[1], premises[2]);
            } else if (twoPremiseRules.includes(rule)) {
              conclusion = window[rule](premises[0], premises[1]);
            } else if (onePremiseRules.includes(rule)) {
              conclusion = window[rule](premises[0]);
            }
          } catch (e) {
            console.error("Preview calculation error:", e);
            conclusion = null;
          }
        }

        if (conclusion) {
          if (Array.isArray(conclusion)) {
            // ë‹¨ìˆœí™” ê·œì¹™ì²˜ëŸ¼ ê²°ê³¼ê°€ ì—¬ëŸ¬ ê°œì¼ ê²½ìš°
            textEl.innerHTML = conclusion
              .map((c) => propositionToNaturalText(c))
              .join("<br>");
          } else {
            textEl.innerHTML = propositionToNaturalText(conclusion);
          }
        } else {
          textEl.innerHTML = `<i>${
            currentLang.langCode === "ko"
              ? "ê·œì¹™ì„ ì ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
              : "Cannot apply rule."
          }</i>`;
        }
      }

      // --- ìœ ë ˆì¹´ ëª¨ë‹¬ ë¦¬ìŠ¤íŠ¸ í´ë¦­ í¸ì˜ì„± ê°œì„  ì½”ë“œ ---
      const eurekaPremiseList = document.getElementById("premise-list");

      if (eurekaPremiseList) {
        eurekaPremiseList.addEventListener("click", function (event) {
          // í´ë¦­ëœ ì§€ì ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ <li> ìš”ì†Œë¥¼ ì°¾ìŠµë‹ˆë‹¤.
          const targetLi = event.target.closest("li");

          // <li> ìš”ì†Œ ì•ˆì—ì„œ í´ë¦­ì´ ë°œìƒí–ˆë‹¤ë©´,
          if (targetLi) {
            // ê·¸ <li> ì•ˆì— ìˆëŠ” ì²´í¬ë°•ìŠ¤ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
            const checkbox = targetLi.querySelector('input[type="checkbox"]');

            // ì²´í¬ë°•ìŠ¤ê°€ ì¡´ì¬í•œë‹¤ë©´,
            if (checkbox) {
              // ì²´í¬ë°•ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ í´ë¦­ ë¬´ì‹œ
              if (checkbox.disabled) {
                return;
              }

              // ì¤‘ìš”: ì‹¤ì œ í´ë¦­ëœ ìš”ì†Œ(event.target)ê°€ ì²´í¬ë°•ìŠ¤ ìì²´ê°€ ì•„ë‹ ë•Œë§Œ ì½”ë“œë¡œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
              // ì´ë ‡ê²Œ í•´ì•¼ ì²´í¬ë°•ìŠ¤ë¥¼ ì§ì ‘ í´ë¦­í–ˆì„ ë•Œ ìƒíƒœê°€ ë‘ ë²ˆ ë°”ë€ŒëŠ” í˜„ìƒì„ ë§‰ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              if (event.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
              }

              targetLi.classList.toggle("selected", checkbox.checked);

              updateConclusionPreview();
            }
          }
        });
        // --- ì „ì²´ í™”ë©´ ê¸°ëŠ¥ ë¡œì§ ---
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        fullscreenBtn.addEventListener("click", toggleFullScreen);

        function toggleFullScreen() {
          // ë¶€ëª¨ ì°½(index.html)ì— 'toggle-fullscreen' ë©”ì‹œì§€ë¥¼ ë³´ëƒ„
          window.parent.postMessage("toggle-fullscreen", "*");
        }

        // --- UI í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ë‹¤êµ­ì–´ ì§€ì›) ---
        function updateUIText() {
          document.querySelectorAll("[data-i18n]").forEach((element) => {
            const key = element.getAttribute("data-i18n");
            if (TEXTS.hasOwnProperty(key)) {
              element.textContent =
                TEXTS[`${key}_${currentLanguage}`] || TEXTS[`${key}_ko`]; // í˜„ì¬ ì–¸ì–´ ì—†ìœ¼ë©´ í•œêµ­ì–´ ê¸°ë³¸
            }
          });
        }

        // ì´ˆê¸° ë¡œë“œ ì‹œ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        updateUIText();

        // ì–¸ì–´ ë³€ê²½ ì‹œ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ í˜¸ì¶œ (ê¸°ì¡´ ì–¸ì–´ ë³€ê²½ ë¡œì§ì— ì¶”ê°€ í•„ìš”)
        // ì˜ˆì‹œ:
        // function changeLanguage(lang) {
        //     currentLanguage = lang;
        //     localStorage.setItem('languagePreference', lang);
        //     updateUIText(); // í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        //     // ... ê¸°ì¡´ ì–¸ì–´ ë³€ê²½ ë¡œì§ ...
        // }
      }
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // âœ… 1ì¸ ëŒ€ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ìƒˆë¡œìš´ ìºë¦­í„° ì„ íƒ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden"); // ë©”ì¸ ì„¼í„° ìˆ¨ê¹€
        document.getElementById("credits-btn").classList.add("hidden");
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      function updateMainMenuBtnVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const mainMenuBtn = document.getElementById("main-menu-btn");
        if (mainCenter && mainMenuBtn) {
          if (!mainCenter.classList.contains("hidden")) {
            mainMenuBtn.style.display = "none";
          } else {
            mainMenuBtn.style.display = "";
          }
        }
      }

      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // âœ… 1ì¸ ëŒ€ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ìƒˆë¡œìš´ ìºë¦­í„° ì„ íƒ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");
        updateMainMenuBtnVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      function updateMainCenterVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const hideList = [
          "#player-a-area .player-title-box",
          "#player-a-area .hand",
          "#player-a-portrait",
          "#player-b-area .player-title-box",
          "#player-b-area .hand",
          "#player-b-portrait",
          "#status > *",
          "#round-display",
          "#new-game-btn",
          "#player-a-area .button-wrapper",
          "#player-b-area .button-wrapper",
        ];
        const shouldHide = !mainCenter.classList.contains("hidden");
        hideList.forEach((sel) => {
          const el = document.querySelector(sel);
          if (el) el.style.visibility = shouldHide ? "hidden" : "visible";
        });
      }
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        // 1. íŠœí† ë¦¬ì–¼ ì¤‘ì´ì—ˆë‹¤ë©´ íŠœí† ë¦¬ì–¼ì„ ì¢…ë£Œí•˜ê³  ë©”ì¸ ë©”ë‰´ë¡œ ê°‘ë‹ˆë‹¤.
        if (inTutorialMode) {
          endTutorial(); // endTutorial í•¨ìˆ˜ê°€ ìŒì•… ì „í™˜ì„ í¬í•¨í•œ ëª¨ë“  ê²ƒì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
          return;
        }
        isTestMode = false;

        // 2. ê²Œì„ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        clearAllAITimeouts();
        aiPlayer = null;
        gameMode = null;
        gameIsOver = true; // ê²Œì„ì´ ëë‚¬ìŒì„ ëª…ì‹œ

        // 3. ë©”ì¸ ë©”ë‰´ UIë¥¼ í‘œì‹œí•˜ê³  ê´€ë ¨ ìŒì•…ì„ ì¬ìƒí•©ë‹ˆë‹¤.
        // ì´ í•¨ìˆ˜ê°€ ê²Œì„ ìŒì•… fade-outê³¼ ë©”ë‰´ ìŒì•… fade-inì„ ëª¨ë‘ ë‹´ë‹¹í•©ë‹ˆë‹¤.
        showMainMenu();
      });
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // âœ… 1ì¸ ëŒ€ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ìƒˆë¡œìš´ ìºë¦­í„° ì„ íƒ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      // ì´ˆê¸°í™” ì‹œì—ë„ í˜¸ì¶œ
      updateMainCenterVisibility();

      // ì´ˆê¸°í™” ì‹œì—ë„ í˜¸ì¶œ
      updateMainMenuBtnVisibility();

      function clearAllAITimeouts() {
        if (aiTimeoutId) {
          clearTimeout(aiTimeoutId);
          aiTimeoutId = null;
        }
      }
      function goToMainMenu() {
        isTestMode = false;

        document
          .getElementById("character-selection-screen")
          .classList.add("hidden");
        document
          .getElementById("character-select-indicator")
          .classList.add("hidden");
        document.getElementById("turn-order-modal").classList.remove("visible");

        showMainMenu();

        tempSelections = { p1: null, p2: null };
        characterSelectionTurn = null;
        selectionMode = null;
        gameMode = null;
        aiPlayer = null;
        humanPlayerId = null;

        clearAllAITimeouts();
      }

      function promptAndSetupTestGame(selectedCharacters) {
        try {
          const victoryA = prompt(
            "í”Œë ˆì´ì–´ A(1P)ì˜ ìŠ¹ë¦¬ ì¡°ê±´ ì„œìˆ ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: ì„ í•˜ë‹¤, is wise)"
          );
          const victoryB = prompt(
            "í”Œë ˆì´ì–´ B(AI)ì˜ ìŠ¹ë¦¬ ì¡°ê±´ ì„œìˆ ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: ì•…í•˜ë‹¤, is evil)"
          );
          const handA = prompt(
            "í”Œë ˆì´ì–´ Aì˜ ì´ˆê¸° ì†íŒ¨ë¥¼ ì‰¼í‘œ(,)ë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: ì†Œí¬ë¼í…ŒìŠ¤ëŠ”, ì§€í˜œë¡­ë‹¤, ë¼ë©´)"
          );
          const handB = prompt(
            "í”Œë ˆì´ì–´ Bì˜ ì´ˆê¸° ì†íŒ¨ë¥¼ ì‰¼í‘œ(,)ë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš”."
          );
          const trueProps = prompt(
            "ì´ˆê¸° ì°¸ ëª…ì œë“¤ì„ ì„¸ë¯¸ì½œë¡ (;)ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš”. (ì—†ìœ¼ë©´ ë¹„ì›Œë‘ì„¸ìš”)"
          );

          const testConfig = {
            victoryA: victoryA || null,
            victoryB: victoryB || null,
            handA: handA || null,
            handB: handB || null,
            trueProps: trueProps || null,
          };

          resetGame(selectedCharacters, testConfig); // ì…ë ¥ë°›ì€ ì„¤ì •ìœ¼ë¡œ resetGame í˜¸ì¶œ
        } catch (e) {
          console.error("í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì„¤ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", e);
          alert(
            "í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì„¤ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤."
          );
          goToMainMenu();
        }
      }
      function calculateStrategicValue(proposition, perspectivePlayer) {
        if (!proposition) return 0;

        // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: ì–´ë–¤ ëª…ì œë“  í‰ê°€í•˜ê¸° ì „ì— ë¨¼ì € ì •ê·œí™”í•©ë‹ˆë‹¤. â˜…â˜…â˜…
        const normalizedProp = normalizeProposition(proposition);

        const opponentPlayer = perspectivePlayer === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === perspectivePlayer
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryData || !opponentVictoryData) return 0;

        let score = 0;
        const myUltimateGoal = myVictoryData.ultimate_target;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentVictoryData.ultimate_target,
        };

        // 1. ì§ì ‘ì ì¸ ìŠ¹/íŒ¨ ì¡°ê±´ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ (ì •ê·œí™”ëœ ëª…ì œë¡œ ë¹„êµ)
        if (arePropositionsEqual(normalizedProp, myUltimateGoal))
          score += 50000;
        if (arePropositionsEqual(normalizedProp, opponentLossCondition))
          score += 50000;

        // 2. ì „ì¹­ ì–‘í™”ë¬¸('ëª¨ë“ ')ì˜ ê°€ì¹˜ í‰ê°€ (ì •ê·œí™”ëœ ëª…ì œë¡œ ë¹„êµ)
        if (normalizedProp.type === "universal") {
          const myWinPredicate = myVictoryData.core_goal.predicate;
          const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
          const predicatePairs = currentLang.contradictoryPredicates;
          const opponentDefeatPredicate =
            predicatePairs[opponentWinPredicate] ||
            Object.keys(predicatePairs).find(
              (key) => predicatePairs[key] === opponentWinPredicate
            );

          if (normalizedProp.predicate === myWinPredicate) score += 8000;
          if (
            opponentDefeatPredicate &&
            normalizedProp.predicate === opponentDefeatPredicate
          )
            score += 7000;
          if (normalizedProp.predicate === opponentWinPredicate) score -= 9000;
        }

        return score;
      }

      /**
       * íŠ¹ì • ê³„íš(ê²½ë¡œ)ì„ ìˆ˜í–‰í–ˆì„ ë•Œì˜ ìœ„í—˜ì„±ì„ í‰ê°€í•˜ëŠ” í•¨ìˆ˜
       * @param {Array<object>} path - findAllProofPathsê°€ ë°˜í™˜í•œ ê³„íš ê²½ë¡œ
       * @param {string} perspectivePlayer - 'A' ë˜ëŠ” 'B', ëˆ„êµ¬ì˜ ê´€ì ì—ì„œ í‰ê°€í• ì§€
       * @returns {boolean} ìœ„í—˜í•˜ë©´ true, ì•„ë‹ˆë©´ false
       */
      function isPlanTooRisky(path, perspectivePlayer) {
        if (!path || path.length === 0) return false;

        const opponentPlayer = perspectivePlayer === "A" ? "B" : "A";
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        if (!opponentVictoryData) return false;

        // ê³„íšì˜ ìµœì¢… ëª©í‘œë¥¼ ë‹¬ì„±í–ˆì„ ë•Œì˜ ê°€ìƒ ì§„ë¦¬ ì§‘í•©ì„ ë§Œë“­ë‹ˆë‹¤.
        const finalStep = path[path.length - 1];
        const { success, expandedSet } = verifyAndExpandTruths(
          finalStep,
          internalTruthSet
        );

        if (!success) return true; // ê³„íš ìì²´ê°€ ëª¨ìˆœì„ ì¼ìœ¼í‚¤ë©´ ìœ„í—˜

        // ê·¸ ê²°ê³¼ ìƒëŒ€ì˜ ìŠ¹ë¦¬ê°€ ì¦ëª…ëœë‹¤ë©´ ì´ ê³„íšì€ ìœ„í—˜í•©ë‹ˆë‹¤.
        if (aiFindProof(opponentVictoryData.ultimate_target, expandedSet)) {
          return true;
        }

        return false;
      }

      // --- ê° ì¶”ë¡  ê·œì¹™ë³„ ê°¬ë¹— í‰ê°€ì ì •ì˜ ---
      const GAMBIT_EVALUATORS = [
        {
          name: "Disjunctive Syllogism Gambit",
          trigger: () => {
            return truePropositions.filter(
              (p) => p.proposition && p.proposition.type === "disjunction"
            );
          },
          evaluate: (triggerPropositionData, perspectivePlayer) => {
            const prop = triggerPropositionData.proposition; // P âˆ¨ Q
            const candidates = [];
            const path1 = {
              subGoal: { type: "negation", proposition: prop.left }, // ~P
              result: prop.right, // Q
            };
            const path2 = {
              subGoal: { type: "negation", proposition: prop.right }, // ~Q
              result: prop.left, // P
            };
            [path1, path2].forEach((path) => {
              const benefitScore = calculateStrategicValue(
                path.result,
                perspectivePlayer
              );
              if (benefitScore > 0) {
                candidates.push({
                  gambitName: "Disjunctive Syllogism Gambit",
                  subGoal: path.subGoal,
                  benefitScore: benefitScore,
                });
              }
            });
            return candidates;
          },
        },
        {
          name: "Modus Tollens Gambit",
          trigger: () => {
            return truePropositions.filter(
              (p) => p.proposition && p.proposition.type === "conditional"
            );
          },
          evaluate: (triggerPropositionData, perspectivePlayer) => {
            const prop = triggerPropositionData.proposition; // P â†’ Q
            const candidates = [];
            const subGoal = { type: "negation", proposition: prop.right }; // ~Q
            const result = { type: "negation", proposition: prop.left }; // ~P
            const benefitScore = calculateStrategicValue(
              result,
              perspectivePlayer
            );
            if (benefitScore > 0) {
              candidates.push({
                gambitName: "Modus Tollens Gambit",
                subGoal: subGoal,
                benefitScore: benefitScore,
              });
            }
            return candidates;
          },
        },
        // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
        // â˜…â˜…â˜… ì•„ë˜ 'ì „ê±´ ê¸ì • ê°¬ë¹—' ê°ì²´ê°€ ìƒˆë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤ â˜…â˜…â˜…
        // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
        {
          name: "Modus Ponens Gambit",
          /**
           * ì°¸ ëª…ì œ ëª©ë¡ì—ì„œ 'ë¼ë©´'ìœ¼ë¡œ ì—°ê²°ëœ ì¡°ê±´ë¬¸ì„ ì°¾ì•„ ë°˜í™˜í•©ë‹ˆë‹¤.
           */
          trigger: () => {
            return truePropositions.filter(
              (p) => p.proposition && p.proposition.type === "conditional"
            );
          },
          /**
           * ì°¾ì•„ë‚¸ ì¡°ê±´ë¬¸ì— ëŒ€í•´ ê°¬ë¹—ì˜ ìœ íš¨ì„±ì„ í‰ê°€í•©ë‹ˆë‹¤.
           * @param {object} triggerPropositionData - 'ë¼ë©´' ëª…ì œë¥¼ í¬í•¨í•œ ë°ì´í„° ê°ì²´
           * @param {string} perspectivePlayer - AI í”Œë ˆì´ì–´ ('A' or 'B')
           * @returns {Array<object>} í‰ê°€ëœ ê°¬ë¹— ê³„íš í›„ë³´ ëª©ë¡
           */
          evaluate: (triggerPropositionData, perspectivePlayer) => {
            const prop = triggerPropositionData.proposition; // P â†’ Q
            const candidates = [];

            // ì‹œë‚˜ë¦¬ì˜¤: Pë¥¼ ì¦ëª…í•˜ì—¬ Që¥¼ ì–»ëŠ”ë‹¤.
            const subGoal = prop.left; // ì¦ëª…í•´ì•¼ í•  ëª©í‘œ: P
            const result = prop.right; // ì–»ê²Œ ë  ê²°ê³¼: Q

            // ì´ ê°¬ë¹—ìœ¼ë¡œ ì–»ëŠ” ê²°ê³¼(Q)ì˜ ì „ëµì  ê°€ì¹˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            const benefitScore = calculateStrategicValue(
              result,
              perspectivePlayer
            );

            // ê°€ì¹˜ê°€ 0ë³´ë‹¤ í´ ê²½ìš°ì—ë§Œ ìœ íš¨í•œ ê°¬ë¹— í›„ë³´ë¡œ ì¶”ê°€í•©ë‹ˆë‹¤.
            if (benefitScore > 0) {
              candidates.push({
                gambitName: "Modus Ponens Gambit",
                subGoal: subGoal,
                benefitScore: benefitScore,
              });
            }

            return candidates;
          },
        },
      ];

      /**
       * ëª¨ë“  ê°¬ë¹— í‰ê°€ìë¥¼ ì‹¤í–‰í•˜ì—¬ í˜„ì¬ ìƒí™©ì—ì„œ ê°€ì¥ ì¢‹ì€ ì¥ê¸° ê³„íšì„ ì°¾ëŠ” í•¨ìˆ˜
       * @param {string} perspectivePlayer - AI í”Œë ˆì´ì–´ ('A' or 'B')
       * @returns {object | null} ê°€ì¥ ì¢‹ì€ ê°¬ë¹— ê³„íš ë˜ëŠ” null
       */
      function findBestGambitPlan(perspectivePlayer) {
        let allCandidateGambits = [];

        // 1. ëª¨ë“  ê°¬ë¹— í‰ê°€ìë¥¼ ìˆœíšŒí•©ë‹ˆë‹¤.
        for (const evaluator of GAMBIT_EVALUATORS) {
          const triggers = evaluator.trigger();
          for (const trigger of triggers) {
            // 2. ê° íŠ¸ë¦¬ê±°ì— ëŒ€í•´ ìœ íš¨í•œ ê°¬ë¹—ë“¤ì„ í‰ê°€í•˜ì—¬ ëª©ë¡ì— ì¶”ê°€í•©ë‹ˆë‹¤.
            const gambits = evaluator.evaluate(trigger, perspectivePlayer);
            allCandidateGambits.push(...gambits);
          }
        }

        if (allCandidateGambits.length === 0) return null;

        let viablePlans = [];
        // 3. ì°¾ì•„ë‚¸ ëª¨ë“  ê°¬ë¹— í›„ë³´ì— ëŒ€í•´, ëª©í‘œ ë‹¬ì„± ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.
        for (const gambit of allCandidateGambits) {
          let proofPaths = [];
          // `findAllProofPaths`ë¥¼ ì´ìš©í•´ subgoalì„ ì¦ëª…í•  ë°©ë²•ì„ ì°¾ìŠµë‹ˆë‹¤.
          findAllProofPaths(gambit.subGoal, [], proofPaths, 0);

          if (proofPaths.length > 0) {
            // ê°€ì¥ ì§§ì€ ê²½ë¡œë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
            proofPaths.sort((a, b) => a.steps.length - b.steps.length);
            const bestPath = proofPaths[0].steps;

            // 4. í•´ë‹¹ ê²½ë¡œê°€ ë„ˆë¬´ ìœ„í—˜í•˜ì§€ëŠ” ì•Šì€ì§€ ìµœì¢… í™•ì¸í•©ë‹ˆë‹¤.
            if (!isPlanTooRisky(bestPath, perspectivePlayer)) {
              viablePlans.push({
                ...gambit,
                path: bestPath,
                // ìµœì¢… ì ìˆ˜ = ì´ë“ ì ìˆ˜ - ê²½ë¡œ ê¸¸ì´ (ì§§ì„ìˆ˜ë¡ ì¢‹ìŒ)
                finalScore: gambit.benefitScore - bestPath.length * 100,
              });
            }
          }
        }

        if (viablePlans.length === 0) return null;

        // 5. ì‹¤í–‰ ê°€ëŠ¥í•œ ëª¨ë“  ê³„íš ì¤‘ ê°€ì¥ ì ìˆ˜ê°€ ë†’ì€ ê²ƒì„ ì„ íƒí•©ë‹ˆë‹¤.
        viablePlans.sort((a, b) => b.finalScore - a.finalScore);
        return viablePlans[0];
      }

      function activatePlatoAbility(player) {
        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "existential"
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ë³´í¸í™”í•  ìˆ˜ ìˆëŠ” ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤."
              : "There are no propositions to universalize."
          );
          return;
        }

        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.ui.platoAbilityTitle;
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.ui.platoConfirmButton;

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // ëª©ë¡ ì´ˆê¸°í™”
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection"; // ê³µí†µ ì´ë¦„ ì‚¬ìš©
          radio.value = index;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // ë²”ìš© ëª¨ë‹¬ì˜ ë‹«ê¸°/í™•ì¸ ë²„íŠ¼ì— *í”Œë¼í†¤*ì˜ ë¡œì§ì„ ì—°ê²°
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmPlatoAbility;

        modal.classList.add("visible");
      }

      /**
       * í”Œë¼í†¤ ëŠ¥ë ¥ ëª¨ë‹¬ì—ì„œ 'í™•ì¸' ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
       */
      function confirmPlatoAbility() {
        // 1. ì„ íƒëœ ë¼ë””ì˜¤ ë²„íŠ¼ê³¼ ëª…ì œë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) {
          return;
        }

        const selectedIndex = parseInt(selectedRadio.value, 10);
        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "existential"
        );
        const selectedPropData = availablePropositions[selectedIndex];

        if (!selectedPropData) {
          console.error(
            "Plato Ability Error: Could not find the selected proposition."
          );
          return;
        }

        // 2. ì„ íƒëœ 'ì–´ë–¤' ëª…ì œë¥¼ 'ëª¨ë“ ' ëª…ì œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
        const originalProp = selectedPropData.proposition;
        const universalProp = {
          type: "universal",
          entity: originalProp.entity,
          predicate: originalProp.predicate,
        };

        // 3. ìƒˆë¡œìš´ 'ëª¨ë“ ' ëª…ì œê°€ ê¸°ì¡´ ì§„ë¦¬ ì²´ê³„ì™€ ëª¨ìˆœë˜ì§€ ì•ŠëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤.
        const verificationResult = verifyAndExpandTruths(universalProp);

        if (verificationResult.success) {
          // 4. ê²€ì¦ ì„±ê³µ ì‹œ, ëŠ¥ë ¥ ì‚¬ìš© ìƒíƒœë¥¼ ê¸°ë¡í•˜ê³  ìƒˆ ëª…ì œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
          const philosopherId =
            thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
          abilityUsedState[thinkingTimeTurn].used = true;

          truePropositions.push({
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem", // íƒ€ì…ì€ 'theorem'ìœ¼ë¡œ ìœ ì§€
            source: "plato_ability", // 'ì´ë°ì•„ íšŒìƒ' ì¶œì²˜ ëª…ì‹œ
            proposition: universalProp,
          });
          internalTruthSet = verificationResult.expandedSet;

          // 5. ëª¨ë‹¬ì„ ë‹«ê³  ê²Œì„ ìƒíƒœë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.
          document.getElementById("ability-modal").classList.remove("visible");
          showAlert(
            currentLang.langCode === "ko"
              ? "ìƒˆë¡œìš´ ë³´í¸ ëª…ì œê°€ ì°¸ ëª©ë¡ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!"
              : "A new universal proposition has been added to the true list!"
          );
          render();
        } else {
          // 6. ëª¨ìˆœ ë°œìƒ ì‹œ, ì‚¬ìš©ìì—ê²Œ ì•Œë¦½ë‹ˆë‹¤.
          showAlert(currentLang.alerts.contradictionFound);
        }
      }

      function activateSocratesAbility(player) {
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        const state = abilityUsedState[player];

        if (state && state.usedCount >= state.maxUses) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ì´ë¯¸ ëŠ¥ë ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
              : "Ability has already been used up."
          );
          return;
        }
        const availablePropositions = truePropositions.filter((p) => {
          // 1. íƒ€ì…ì´ 'user-made' ë˜ëŠ” 'theorem'ì´ì–´ì•¼ í•¨ (ê¸°ì¡´ ì¡°ê±´)
          const isTargetType = p.type === "user-made" || p.type === "theorem";
          if (!isTargetType) return false;

          // 2. í•´ë‹¹ ëª…ì œê°€ ì´ë¯¸ ë¹„í™œì„±í™” ëª©ë¡ì— ìˆëŠ”ì§€ í™•ì¸ (ìƒˆë¡œìš´ ì¡°ê±´)
          const isDisabled = socratesDisabledProps.some(
            (disabledProp) => disabledProp.propId === p.propId
          );

          // 3. ë¹„í™œì„±í™”ë˜ì§€ ì•Šì€ ëª…ì œë§Œ ìµœì¢… ëª©ë¡ì— í¬í•¨
          return !isDisabled;
        });

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ë¹„í™œì„±í™”í•  ìˆ˜ ìˆëŠ” ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤."
              : "There are no propositions to disable."
          );
          return;
        }

        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.ui.socratesAbilityTitle;
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.ui.socratesConfirmButton;

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // ëª©ë¡ ì´ˆê¸°í™”
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection"; // ê³µí†µ ì´ë¦„ ì‚¬ìš©
          radio.value = propData.propId;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // ë²”ìš© ëª¨ë‹¬ì˜ ë‹«ê¸°/í™•ì¸ ë²„íŠ¼ì— *ì†Œí¬ë¼í…ŒìŠ¤*ì˜ ë¡œì§ì„ ì—°ê²°
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmSocratesAbility;

        modal.classList.add("visible");
      }
      function confirmSocratesAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;

        // socratesDisabledProps ë°°ì—´ì—ëŠ” ì´ì œ propIdë§Œ ì €ì¥í•©ë‹ˆë‹¤.
        // ë” ì´ìƒ proposition ê°ì²´ë¥¼ ì €ì¥í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
        socratesDisabledProps.push({
          propId: selectedPropId,
          reEnableRound: currentRound + 2,
        });

        // ëŠ¥ë ¥ ì‚¬ìš© ì²˜ë¦¬
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].usedCount++;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "ì„ íƒí•œ ëª…ì œê°€ ë‹¤ìŒ ë¼ìš´ë“œ ë™ì•ˆ ë…¼ì¦ì—ì„œ ì œì™¸ë©ë‹ˆë‹¤."
            : "The selected proposition will be excluded from arguments for the next round."
        );
        render(); // UI ì¦‰ì‹œ ê°±ì‹ 
      }
      function activateDescartesAbility(player) {
        // ì‚­ì œ ê°€ëŠ¥í•œ ëª…ì œ (ê³µë¦¬, ìŠ¹ë¦¬ì¡°ê±´ ì œì™¸) ëª©ë¡ì„ ì¤€ë¹„í•©ë‹ˆë‹¤.
        const availablePropositions = truePropositions.filter(
          (p) => p.type === "user-made" || p.type === "theorem"
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ì‚­ì œí•  ìˆ˜ ìˆëŠ” ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤."
              : "There are no propositions to delete."
          );
          return;
        }

        // ë²”ìš© ëŠ¥ë ¥ ëª¨ë‹¬ì°½ì„ ê°€ì ¸ì™€ ë‚´ìš©ì„ ë°ì¹´ë¥´íŠ¸ì— ë§ê²Œ ìˆ˜ì •í•©ë‹ˆë‹¤.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko" ? "ë°©ë²•ì  íšŒì˜" : "Methodic Doubt";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "ì´ ëª…ì œë¥¼ ì‚­ì œí•˜ê¸°"
            : "Delete this Proposition";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // ëª©ë¡ ì´ˆê¸°í™”

        // ì‚­ì œ ê°€ëŠ¥í•œ ëª…ì œë“¤ë¡œ ì„ íƒ ëª©ë¡ì„ ì±„ì›ë‹ˆë‹¤.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          // propIdë¥¼ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ì–´ë–¤ ëª…ì œë¥¼ ì‚­ì œí• ì§€ ì‹ë³„í•©ë‹ˆë‹¤.
          radio.value = propData.propId;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // ëª¨ë‹¬ì˜ ë‹«ê¸°/í™•ì¸ ë²„íŠ¼ì— ë°ì¹´ë¥´íŠ¸ ì „ìš© í•¨ìˆ˜ë¥¼ ì—°ê²°í•©ë‹ˆë‹¤.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmDescartesAbility;

        modal.classList.add("visible");
      }

      function confirmDescartesAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;

        // 1. truePropositions ë°°ì—´ì—ì„œ ì‚­ì œí•  ëª…ì œì˜ ì¸ë±ìŠ¤ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        const propIndex = truePropositions.findIndex(
          (p) => p.propId === selectedPropId
        );

        if (propIndex === -1) {
          console.error("Descartes Ability Error: Proposition ID not found.");
          return;
        }

        // 2. í•´ë‹¹ ëª…ì œë¥¼ ë°°ì—´ì—ì„œ ì œê±°í•©ë‹ˆë‹¤.
        truePropositions.splice(propIndex, 1);

        // 3. â˜…â˜…â˜… í•µì‹¬ ë‹¨ê³„ â˜…â˜…â˜…
        //    ëª…ì œ í•˜ë‚˜ê°€ ì‚¬ë¼ì¡Œìœ¼ë¯€ë¡œ, ì „ì²´ ë…¼ë¦¬ ì²´ê³„ì— ëª¨ìˆœì´ ìƒê²¼ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        //    ë”°ë¼ì„œ ê³µë¦¬ë¶€í„° ì‹œì‘í•˜ì—¬ ë‚¨ì•„ìˆëŠ” ëª…ì œë“¤ë¡œ ì§„ë¦¬ ì§‘í•©(internalTruthSet)ì„ ì™„ì „íˆ ì¬êµ¬ì„±í•©ë‹ˆë‹¤.
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after Descartes' ability: Inconsistency found while rebuilding truth set."
            );
            // ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ì´ ì˜¤ë¥˜ë¥¼ ë” ê²¬ê³ í•˜ê²Œ ì²˜ë¦¬í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          }
        }
        internalTruthSet = newTruthSet;

        // 4. ëŠ¥ë ¥ ì‚¬ìš© ìƒíƒœë¥¼ ê¸°ë¡í•˜ê³  UIë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "ì„ íƒí•œ ëª…ì œê°€ ì°¸ ëª©ë¡ì—ì„œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."
            : "The selected proposition has been deleted from the true list."
        );
        render();
      }
      function activateWittgensteinAbility(player) {
        // ìœ ë ˆì¹´ ëª¨ë‹¬ê³¼ ë™ì¼í•˜ê²Œ ë‚´ë¶€ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        derivedPropositionsInModal = [];
        currentAssumption = null;

        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        // ìœ ë ˆì¹´ ëª¨ë‹¬ê³¼ ë˜‘ê°™ì´ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ì „ì œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions
            .map((p) => ({ ...p, proposition: p.proposition }))
            .filter((p) => p.proposition),
        ].filter(
          (propData) =>
            !propData.propId ||
            !socratesDisabledProps.some((dp) => dp.propId === propData.propId)
        );

        // ê³µë¦¬ë“¤ì„ ê·¸ë£¹ë³„ë¡œ ë¶„ë¥˜í•˜ê³  ìˆœì„œëŒ€ë¡œ ì¶”ê°€ (openEurekaModalê³¼ ë™ì¼)
        const axioms = allSelectablePropositions.filter(p => p.type === "axiom");
        const nonAxioms = allSelectablePropositions.filter(p => p.type !== "axiom");
        
        // ê³µë¦¬ë¥¼ ê·¸ë£¹í™”í•˜ì—¬ ì¶”ê°€ - ì‘ì€ ì„œë¸Œê·¸ë£¹ë³„ë¡œ êµ¬ë¶„ì„  ì¶”ê°€
        if (currentAxioms.groups && axioms.length > 0) {
          const groups = currentAxioms.groups;
          const templates = currentLang.axiom_templates;
          let axiomIndex = 0;
          
          // ì •ì²´ì„± ê³µë¦¬ ê·¸ë£¹
          if (groups.identity && groups.identity.length > 0) {
            for (let i = 0; i < groups.identity.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì •ì²´ì„± ê·¸ë£¹ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ - ì„œë¸Œê·¸ë£¹ë³„ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.subjectOpposition && groups.subjectOpposition.length > 0) {
            // ì²« ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ì²« ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë‘ ë²ˆì§¸ ì² í•™ì ì„ ì•… ê³µë¦¬
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë‘ ë²ˆì§¸ ì² í•™ì ì§€í˜œ ê³µë¦¬
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ê°œì²´ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ - ì„œë¸Œê·¸ë£¹ë³„ë¡œ ë‚˜ëˆ„ê¸°
          if (groups.quantifierOpposition && groups.quantifierOpposition.length > 0) {
            // ìƒˆ ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.bird_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ìƒˆ ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.bird_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.fish_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ë¬¼ê³ ê¸° ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.fish_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ê°œ ì§‘ë‹¨ ìˆœë°©í–¥
            for (let i = 0; i < templates.dog_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // ê°œ ì§‘ë‹¨ ì—­ë°©í–¥
            for (let i = 0; i < templates.dog_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // ë§ˆë¥´í¬ìŠ¤ ê³µë¦¬ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            const remainingAxioms = axioms.slice(axiomIndex);
            const marxAxioms = remainingAxioms.filter(a => {
              const text = propositionToNaturalText(a.proposition);
              return text.includes("ë¸Œë£¨ì£¼ì•„") || text.includes("Bourgeois");
            });
            
            if (marxAxioms.length > 0) {
              // ì„œë¸Œê·¸ë£¹ êµ¬ë¶„ì„ 
              addPremiseToWorkbench({
                type: "separator",
                label: "",
                proposition: null,
                isSeparator: true
              });
              
              marxAxioms.forEach((axiomData) => {
                addPremiseToWorkbench({
                  ...axiomData,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              });
            }
            
            // ì§‘ë‹¨ë³„ ì†ì„± ëŒ€ë¦½ ê·¸ë£¹ ë§ˆì§€ë§‰ êµ¬ë¶„ì„  ì¶”ê°€
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        } else {
          // ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ê³µë¦¬ ì¶”ê°€ (í•˜ìœ„ í˜¸í™˜ì„±)
          axioms.forEach((propData) => {
            addPremiseToWorkbench({
              ...propData,
              label: currentLang.labels.axiom
            });
          });
          
          // ê³µë¦¬ ë§ˆì§€ë§‰ êµ¬ë¶„ì„  ì¶”ê°€
          if (axioms.length > 0) {
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        }
        
        // ê³µë¦¬ê°€ ì•„ë‹Œ ëª…ì œë“¤ ì¶”ê°€
        nonAxioms.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            propId: propData.propId, // propIdë„ í•¨ê»˜ ì „ë‹¬
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });

        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");

        // ëª¨ë‹¬ì˜ ì œëª©ê³¼ ë²„íŠ¼ì„ ë¹„íŠ¸ê²ìŠˆíƒ€ì¸ ì „ìš©ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
        modalTitle.textContent = currentLang.ui.wittgensteinAbilityTitle;
        confirmBtn.textContent = currentLang.ui.wittgensteinConfirmButton;

        // í™•ì¸ ë²„íŠ¼ í´ë¦­ ì‹œ, ë¹„íŠ¸ê²ìŠˆíƒ€ì¸ ì „ìš© í™•ì¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë„ë¡ ì—°ê²°í•©ë‹ˆë‹¤.
        confirmBtn.onclick = confirmWittgensteinAbility;

        renderModal();
        document.getElementById("inference-rule-select").onchange =
          updateConclusionPreview;
        updateConclusionPreview();

        modal.classList.add("visible");
      }
      function confirmWittgensteinAbility() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );

        // 1. ìœ íš¨ì„± ê²€ì‚¬: ë°˜ë“œì‹œ í•˜ë‚˜ì˜ 'ì •ë¦¬'ë§Œ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.
        if (selectedLis.length !== 1) {
          showAlert(currentLang.alerts.selectOneTheoremOnly);
          return;
        }
        const finalTheoremData = JSON.parse(
          selectedLis[0].parentElement.dataset.propObject
        );
        if (
          finalTheoremData.type !== "theorem" ||
          finalTheoremData.dependsOnAssumption
        ) {
          showAlert(currentLang.alerts.selectOneTheoremOnly);
          return;
        }

        // 2. ì¬ê·€ì ìœ¼ë¡œ ëª¨ë“  ìƒìœ„ ì „ì œë¥¼ ì¶”ì í•©ë‹ˆë‹¤.
        const premisesToKick = new Map(); // ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ Map ì‚¬ìš© (key: propId ë˜ëŠ” proposition í…ìŠ¤íŠ¸)

        function findAndAddSources(theoremData) {
          if (
            !theoremData.sourcePremises ||
            theoremData.sourcePremises.length === 0
          ) {
            return; // ë” ì´ìƒ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°ˆ ì „ì œê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
          }

          for (const source of theoremData.sourcePremises) {
            // source.propIdê°€ ìˆëŠ” ê²½ìš° (ì›ë³¸ ì°¸ ëª…ì œ) ê·¸ê²ƒì„ keyë¡œ ì‚¬ìš©
            const key = source.propId
              ? source.propId
              : propositionToText(source.proposition);
            if (!premisesToKick.has(key)) {
              premisesToKick.set(key, source);
              // ê³„ì†í•´ì„œ ìƒìœ„ ì „ì œë¥¼ ì¶”ì 
              findAndAddSources(source);
            }
          }
        }

        findAndAddSources(finalTheoremData);

        // 3. ì¶”ì ëœ ì „ì œë“¤ì„ 'ì°¸ ëª…ì œ ëª©ë¡'ì—ì„œ ì‚­ì œí•©ë‹ˆë‹¤.
        const idsToDelete = new Set();
        premisesToKick.forEach((source) => {
          // ì›ë³¸ ì°¸ ëª…ì œ ëª©ë¡ì—ì„œ ì˜¨ ì „ì œë“¤ë§Œ IDê°€ ìˆìŠµë‹ˆë‹¤.
          if (source.propId) {
            if (
              source.propId &&
              source.type !== "victory" &&
              source.type !== "axiom"
            ) {
              idsToDelete.add(source.propId);
            }
          }
        });

        truePropositions = truePropositions.filter(
          (p) => !idsToDelete.has(p.propId)
        );

        // 4. ìµœì¢…ì ìœ¼ë¡œ ë„ì¶œëœ ìƒˆë¡œìš´ ì •ë¦¬ë¥¼ ì°¸ ëª©ë¡ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        truePropositions.push({
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem",
          round: currentRound,
          proposition: finalTheoremData.proposition,
          source: "wittgenstein_ability",
        });

        // 5. ì „ì²´ ì§„ë¦¬ ì§‘í•©ì„ ì¬êµ¬ì„±í•˜ì—¬ ë…¼ë¦¬ì  ì¼ê´€ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Wittgenstein ability critical error: Inconsistency found."
            );
          }
        }
        internalTruthSet = newTruthSet;

        // 6. ëŠ¥ë ¥ ì‚¬ìš© ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ë§ˆë¬´ë¦¬í•©ë‹ˆë‹¤.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        document.getElementById("eureka-modal").classList.remove("visible");
        showAlert(currentLang.alerts.wittgensteinSuccess);
        render();
      }
      function activateDerridaAbility(player) {
        // 1. ë¶„í•´ ê°€ëŠ¥í•œ ëª…ì œ(ì—°ê²°ì‚¬ë¡œ ì´ì–´ì§„ ëª…ì œ)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
        const availablePropositions = truePropositions.filter(
          (p) =>
            p.type !== "victory" &&
            p.proposition &&
            (p.proposition.type === "conditional" ||
              p.proposition.type === "conjunction" ||
              p.proposition.type === "disjunction")
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ë¶„í•´í•  ìˆ˜ ìˆëŠ” ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤."
              : "There are no compound propositions to deconstruct."
          );
          return;
        }

        // 2. ë²”ìš© ëŠ¥ë ¥ ëª¨ë‹¬ UIë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko" ? "í•´ì²´" : "Deconstruction";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "ì´ ëª…ì œë¥¼ í•´ì²´í•˜ê¸°"
            : "Deconstruct this Proposition";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // ëª©ë¡ ì´ˆê¸°í™”

        // 3. í•„í„°ë§ëœ ëª…ì œë¡œ ì„ íƒ ëª©ë¡ì„ ë§Œë“­ë‹ˆë‹¤.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          // propIdë¥¼ ê°’ìœ¼ë¡œ ì €ì¥í•˜ì—¬ ì–´ë–¤ ëª…ì œë¥¼ ì„ íƒí–ˆëŠ”ì§€ ì‹ë³„í•©ë‹ˆë‹¤.
          radio.value = propData.propId;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 4. í™•ì¸/ì·¨ì†Œ ë²„íŠ¼ì— ë°ë¦¬ë‹¤ ì „ìš© í•¨ìˆ˜ë¥¼ ì—°ê²°í•˜ê³  ëª¨ë‹¬ì„ ì—½ë‹ˆë‹¤.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmDerridaAbility;

        modal.classList.add("visible");
      }

      /**
       * ë°ë¦¬ë‹¤ ëŠ¥ë ¥ ì‹¤í–‰ ë° ê²€ì¦ í•¨ìˆ˜
       */
      function confirmDerridaAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;
        const selectedPropData = truePropositions.find(
          (p) => p.propId === selectedPropId
        );

        if (!selectedPropData) {
          console.error(
            "Derrida Ability Error: Selected proposition not found."
          );
          return;
        }

        const { left, right } = selectedPropData.proposition;

        // --- í•µì‹¬ ë¡œì§: ì‚­ì œì™€ ì¶”ê°€ê°€ ëª¨ë‘ ê°€ëŠ¥í•œì§€ 'ë¯¸ë¦¬' ê²€ì¦í•˜ëŠ” ë‹¨ê³„ ---

        // 1. ì„ íƒëœ ì›ë³¸ ëª…ì œë¥¼ 'ì œì™¸í•œ' ë‚˜ë¨¸ì§€ ëª…ì œ ëª©ë¡ì„ ë§Œë“­ë‹ˆë‹¤.
        const propositionsWithoutOriginal = truePropositions.filter(
          (p) => p.propId !== selectedPropId
        );

        // 2. ì´ ì„ì‹œ ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ ì§„ë¦¬ ì§‘í•©ì„ 'ì¬êµ¬ì„±'í•˜ì—¬, ì›ë³¸ ëª…ì œê°€ ì—†ì—ˆì„ ë•Œì˜ ìƒíƒœë¥¼ ë§Œë“­ë‹ˆë‹¤.
        let baseTruthSetForTest = parsedAxioms.map((a) => a.proposition);
        const propsToReverify = propositionsWithoutOriginal
          .filter((p) => p.proposition)
          .map((p) => p.proposition);
        for (const prop of propsToReverify) {
          const verification = verifyAndExpandTruths(prop, baseTruthSetForTest);
          if (verification.success) {
            baseTruthSetForTest = verification.expandedSet;
          } else {
            console.error(
              "Derrida Pre-check Error: Inconsistency found when creating base set."
            );
            showAlert(currentLang.alerts.criticalErrorUndo); // ë‚´ë¶€ ì˜¤ë¥˜ ì•Œë¦¼
            return;
          }
        }

        // 3. 'ì›ë³¸ì´ ì‚­ì œëœ' ìƒíƒœì—ì„œ, ë¶„í•´ëœ ì²« ë²ˆì§¸(left) ëª…ì œë¥¼ ì¶”ê°€í–ˆì„ ë•Œ ëª¨ìˆœì´ ì—†ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        const verification1 = verifyAndExpandTruths(left, baseTruthSetForTest);
        if (!verification1.success) {
          showAlert(currentLang.alerts.contradictionFound);
          return;
        }

        // 4. ì´ì–´ì„œ ë‘ ë²ˆì§¸(right) ëª…ì œë¥¼ ì¶”ê°€í–ˆì„ ë•Œ ëª¨ìˆœì´ ì—†ëŠ”ì§€ ìµœì¢… í™•ì¸í•©ë‹ˆë‹¤.
        const verification2 = verifyAndExpandTruths(
          right,
          verification1.expandedSet
        );
        if (!verification2.success) {
          showAlert(currentLang.alerts.contradictionFound);
          return;
        }

        // 5. ëª¨ë“  ê²€ì¦ì„ í†µê³¼í–ˆìœ¼ë¯€ë¡œ ëŠ¥ë ¥ ì‚¬ìš©ì„ í™•ì •í•©ë‹ˆë‹¤.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        // 6. ê²€ì¦ì´ ëª¨ë‘ ëë‚¬ìœ¼ë¯€ë¡œ, ì‹¤ì œ ê²Œì„ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
        //    - ì›ë³¸ ë³µí•© ëª…ì œë¥¼ ì‚­ì œí•©ë‹ˆë‹¤. (ì´ë¯¸ ë§Œë“¤ì–´ ë‘” ë¦¬ìŠ¤íŠ¸ ì¬í™œìš©)
        truePropositions = propositionsWithoutOriginal;
        //    - ë¶„í•´ëœ ë‘ ëª…ì œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
        const newProps = [
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: left,
          },
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: right,
          },
        ];
        truePropositions.push(...newProps);

        // 7. ìµœì¢…ì ìœ¼ë¡œ ê²€ì¦ëœ ì§„ë¦¬ ì§‘í•©ìœ¼ë¡œ ë‚´ë¶€ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        internalTruthSet = verification2.expandedSet;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "ëª…ì œê°€ ì„±ê³µì ìœ¼ë¡œ í•´ì²´ë˜ì—ˆìŠµë‹ˆë‹¤."
            : "The proposition has been successfully deconstructed."
        );
        render();
      }
      function activateHumeAbility(player) {
        // 1. êµì²´ ê°€ëŠ¥í•œ ëª…ì œ('ëª¨ë“ 'ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ì „ì¹­ ì–‘í™”ë¬¸)ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "universal"
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "êµì²´í•  ìˆ˜ ìˆëŠ” ì „ì¹­ ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤."
              : "There are no universal propositions to replace."
          );
          return;
        }

        // 2. ë²”ìš© ëŠ¥ë ¥ ëª¨ë‹¬ UIë¥¼ í„ì— ë§ê²Œ ì„¤ì •í•©ë‹ˆë‹¤.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko"
            ? "ê·€ë‚©ì˜ ë¬¸ì œ"
            : "Problem of Induction";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "ì´ ëª…ì œë¥¼ êµì²´í•˜ê¸°"
            : "Replace this Proposition";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // ëª©ë¡ ì´ˆê¸°í™”

        // 3. í•„í„°ë§ëœ ëª…ì œë¡œ ì„ íƒ ëª©ë¡ì„ ì±„ì›ë‹ˆë‹¤.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          radio.value = propData.propId; // propIdë¥¼ ê°’ìœ¼ë¡œ ì €ì¥
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 4. ëª¨ë‹¬ì˜ ë²„íŠ¼ì— í„ ì „ìš© í™•ì¸ í•¨ìˆ˜ë¥¼ ì—°ê²°í•˜ê³  ëª¨ë‹¬ì„ ì—½ë‹ˆë‹¤.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmHumeAbility;

        modal.classList.add("visible");
      }

      /**
       * í„ ëŠ¥ë ¥ ì‹¤í–‰: ì„ íƒí•œ ëª…ì œë¥¼ êµì²´í•˜ê³  ê²Œì„ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
       */
      function confirmHumeAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;
        const propIndex = truePropositions.findIndex(
          (p) => p.propId === selectedPropId
        );

        if (propIndex === -1) {
          console.error("Hume Ability Error: Proposition ID not found.");
          return;
        }

        const originalProp = truePropositions[propIndex].proposition;

        // 1. ì„ íƒëœ ì „ì¹­ ëª…ì œë¥¼ ì¡´ì¬ ëª…ì œë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
        const newExistentialProp = {
          type: "existential",
          entity: originalProp.entity,
          predicate: originalProp.predicate,
        };

        // 2. ê¸°ì¡´ 'ëª¨ë“ ' ëª…ì œë¥¼ ìƒˆë¡œ ë§Œë“  'ì–´ë–¤' ëª…ì œë¡œ êµì²´í•©ë‹ˆë‹¤.
        truePropositions[propIndex].proposition = newExistentialProp;

        // ğŸ’¡ [ë²„ê·¸ ìˆ˜ì •] ë Œë”ë§ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ê¸°ì¡´ ì¹´ë“œ ì •ë³´ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
        // ì´ë ‡ê²Œ í•˜ë©´ render() í•¨ìˆ˜ê°€ ìƒˆë¡œìš´ proposition ê°ì²´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ ê·¸ë¦¬ê²Œ ë©ë‹ˆë‹¤.
        truePropositions[propIndex].original_cards = null;
        truePropositions[propIndex].type = "theorem";
        truePropositions[propIndex].source = "hume_ability";

        // 3. ë°ì¹´ë¥´íŠ¸ ëŠ¥ë ¥ì²˜ëŸ¼, ê°•ë ¥í•œ ì „ì œê°€ ì•½í™”ë˜ì—ˆìœ¼ë¯€ë¡œ ì „ì²´ ì§„ë¦¬ ì§‘í•©ì„ ì¬êµ¬ì„±í•˜ì—¬ ë…¼ë¦¬ì  ì¼ê´€ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after Hume's ability: Inconsistency found."
            );
          }
        }
        internalTruthSet = newTruthSet;

        // 4. ëŠ¥ë ¥ ì‚¬ìš© íšŸìˆ˜ë¥¼ 1 ì¦ê°€ì‹œí‚µë‹ˆë‹¤.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].usedCount++;

        // 5. ëª¨ë‹¬ì„ ë‹«ê³ , ê²°ê³¼ë¥¼ ì•Œë¦¬ê³ , í™”ë©´ì„ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.
        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "ì„ íƒí•œ ëª…ì œê°€ ì¡´ì¬ ì–‘í™”ë¬¸ìœ¼ë¡œ êµì²´ë˜ì—ˆìŠµë‹ˆë‹¤."
            : "The selected proposition has been replaced with an existential one."
        );
        render();
      }

      function activateKuhnAbility(player) {
        // 1. 'ëª¨ë“ 'ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë³´í¸ ëª…ì œì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        // 2. getOppositePredicate í•¨ìˆ˜ë¥¼ ì´ìš©í•´ í•´ë‹¹ ëª…ì œì˜ ìˆ ì–´ì— ë°˜ëŒ€ ê°œë…ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        const availablePropositions = truePropositions.filter(
          (p) =>
            p.proposition &&
            p.proposition.type === "universal" &&
            getOppositePredicate(p.proposition.predicate) !== null
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "íŒ¨ëŸ¬ë‹¤ì„ì„ ì „í™˜í•  ë³´í¸ ëª…ì œê°€ ì—†ìŠµë‹ˆë‹¤."
              : "There are no universal propositions for a paradigm shift."
          );
          return;
        }

        // 2. ë²”ìš© ëŠ¥ë ¥ ëª¨ë‹¬ UIë¥¼ ì¿¤ì— ë§ê²Œ ì„¤ì •í•©ë‹ˆë‹¤.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko" ? "íŒ¨ëŸ¬ë‹¤ì„ ì „í™˜" : "Paradigm Shift";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "íŒ¨ëŸ¬ë‹¤ì„ ì „í™˜í•˜ê¸°"
            : "Shift Paradigm";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // ëª©ë¡ ì´ˆê¸°í™”

        // 3. í•„í„°ë§ëœ ëª…ì œë¡œ ì„ íƒ ëª©ë¡ì„ ì±„ì›ë‹ˆë‹¤.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          radio.value = propData.propId; // propIdë¥¼ ê°’ìœ¼ë¡œ ì €ì¥
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 4. ëª¨ë‹¬ì˜ ë²„íŠ¼ì— ì¿¤ ì „ìš© í™•ì¸ í•¨ìˆ˜ë¥¼ ì—°ê²°í•˜ê³  ëª¨ë‹¬ì„ ì—½ë‹ˆë‹¤.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmKuhnAbility;

        modal.classList.add("visible");
      }

      function confirmKuhnAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;
        const originalPropData = truePropositions.find(
          (p) => p.propId === selectedPropId
        );

        if (!originalPropData) {
          console.error("Kuhn Ability Error: Selected proposition not found.");
          return;
        }

        // --- (1) ìƒˆë¡œìš´ íŒ¨ëŸ¬ë‹¤ì„ ëª…ì œ ìƒì„± ---
        const originalPredicate = originalPropData.proposition.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;

        let newPredicate = null;
        for (const key in predicatePairs) {
          if (key === originalPredicate) {
            newPredicate = predicatePairs[key];
            break;
          }
          if (predicatePairs[key] === originalPredicate) {
            newPredicate = key;
            break;
          }
        }

        if (!newPredicate) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ì´ ëª…ì œì˜ ë°˜ëŒ€ ìˆ ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
              : "Cannot find an opposite predicate for this proposition."
          );
          return;
        }

        const newParadigmProposition = {
          type: "universal",
          entity: originalPropData.proposition.entity,
          predicate: newPredicate,
        };

        const newParadigmPropForList = {
          propId: `prop_${Date.now()}_paradigm`,
          type: "theorem", // ìƒˆë¡œìš´ íŒ¨ëŸ¬ë‹¤ì„ì€ 'ì •ë¦¬'ë¡œ ì·¨ê¸‰
          source: "kuhn_ability",
          proposition: newParadigmProposition,
        };

        // --- (2) ê¸°ë°˜ ì§„ë¦¬ ëª©ë¡ ìƒì„± ë° ì‚¬ì „ ê²€ì¦ ---
        const axioms = parsedAxioms.map((a) => a.proposition);
        const victoryConditions = truePropositions
          .filter((p) => p.type === "victory")
          .map((p) => p.proposition);

        const foundationOfTruths = [
          ...axioms,
          ...victoryConditions,
          newParadigmProposition,
        ];

        const preCheckResult = verifyAndExpandTruths(null, foundationOfTruths);

        if (!preCheckResult.success) {
          showAlert(
            currentLang.langCode === "ko"
              ? "ìƒˆë¡œìš´ íŒ¨ëŸ¬ë‹¤ì„ì´ ê¸°ì¡´ ê³µë¦¬ë‚˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ëª¨ìˆœë˜ì–´ ëŠ¥ë ¥ì„ ë°œë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
              : "The new paradigm contradicts basic axioms or win conditions and cannot be activated."
          );
          return;
        }

        let currentValidatedTruths = preCheckResult.expandedSet;
        let survivingPropositions = [
          ...truePropositions.filter((p) => p.type === "victory"),
          newParadigmPropForList,
        ];

        // --- (3) ê¸°ì¡´ ëª…ì œ ì¬ê²€ì¦ ---
        const candidatesForRevalidation = truePropositions.filter(
          (p) =>
            (p.type === "user-made" || p.type === "theorem") &&
            p.propId !== selectedPropId
        );

        for (const candidate of candidatesForRevalidation) {
          const validationResult = verifyAndExpandTruths(
            candidate.proposition,
            currentValidatedTruths
          );

          if (validationResult.success) {
            // ëª¨ìˆœ ì—†ìŒ (ìƒì¡´)
            currentValidatedTruths = validationResult.expandedSet;
            survivingPropositions.push(candidate);
          }
          // ëª¨ìˆœ ë°œìƒ ì‹œ (íê¸°), ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ.
        }

        // --- (4) ìµœì¢… ëª©ë¡ í™•ì • ë° UI ê°±ì‹  ---
        truePropositions = survivingPropositions;
        internalTruthSet = currentValidatedTruths;

        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "íŒ¨ëŸ¬ë‹¤ì„ì´ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤!"
            : "Paradigm has shifted!"
        );
        render();
      }
      function renderKantModal(player) {
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        const handDisplay = document.getElementById("kant-hand-display");
        const propDisplay = document.getElementById("kant-proposition-display");

        const colorClass = player === "A" ? "card-white" : "card-black";

        handDisplay.innerHTML = "";
        propDisplay.innerHTML = "";

        // 1. ì†íŒ¨ ì˜ì—­ ë Œë”ë§
        hand.forEach((card) => {
          const cardEl = document.createElement("div");

          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = card.text;
          cardEl.onclick = () => {
            const tempPropositionForValidation = kantProposition.map((c) => ({
              card: c,
              player: player,
            }));

            if (isValidPlay(card, tempPropositionForValidation)) {
              const cardIndex = hand.findIndex(
                (c) => c.text === card.text && c.type === card.type
              );
              if (cardIndex > -1) {
                const [movedCard] = hand.splice(cardIndex, 1);
                kantProposition.push(movedCard);
                renderKantModal(player);
              }
            } else {
              showAlert(currentLang.alerts.invalidCard);
            }
          };
          handDisplay.appendChild(cardEl);
        });

        // 2. ëª…ì œ êµ¬ì„± ì˜ì—­ ë Œë”ë§
        kantProposition.forEach((card) => {
          const cardEl = document.createElement("div");

          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = card.text;
          propDisplay.appendChild(cardEl);
        });

        // 3. ë˜ëŒë¦¬ê¸° ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
        document.getElementById("kant-undo-btn").disabled =
          kantProposition.length === 0;
      }

      function confirmKantAbility(player) {
        // 1. ëª…ì œê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
        if (kantProposition.length === 0) {
          return;
        }

        // 2. ë¬¸ë²•ì  ì™„ê²°ì„± ê²€ì‚¬
        // parsePropositionFromCardsëŠ” {card: cardObject} í˜•íƒœì˜ ë°°ì—´ì„ ê¸°ëŒ€í•˜ë¯€ë¡œ ë³€í™˜
        const parsedProp = parsePropositionFromCards(
          kantProposition.map((c) => ({ card: c }))
        );
        if (!parsedProp) {
          showAlert(currentLang.alerts.incompleteProposition);
          return;
        }

        // 4. ë…¼ë¦¬ì  ëª¨ìˆœ ê²€ì‚¬
        const verificationResult = verifyAndExpandTruths(parsedProp);
        if (!verificationResult.success) {
          showAlert(currentLang.alerts.contradictionFound);
          return;
        }

        // 5. ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼: ëŠ¥ë ¥ ì‚¬ìš© ì²˜ë¦¬
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[player].used = true;

        // 6. ìƒˆë¡œìš´ ëª…ì œë¥¼ ì°¸ ëª©ë¡ì— ì¶”ê°€
        truePropositions.push({
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem", // ëŠ¥ë ¥ìœ¼ë¡œ ë§Œë“  ëª…ì œëŠ” 'ì •ë¦¬'ë¡œ ì·¨ê¸‰
          source: "kant_ability", // ì¹¸íŠ¸ ëŠ¥ë ¥ ì¶œì²˜ ëª…ì‹œ
          proposition: parsedProp,
        });

        // 7. ë‚´ë¶€ ì§„ë¦¬ ì§‘í•© ì—…ë°ì´íŠ¸
        internalTruthSet = verificationResult.expandedSet;

        // 8. ë§ˆë¬´ë¦¬
        const modal = document.getElementById("kant-ability-modal");
        modal.classList.remove("visible");
        kantProposition = []; // ì„ì‹œ ëª…ì œ ë°°ì—´ ë¹„ìš°ê¸°

        showAlert(currentLang.alerts.kantSuccess);
        render(); // ê²Œì„ í™”ë©´ ì „ì²´ ê°±ì‹ 
      }

      /**
       * ì¹¸íŠ¸ ëŠ¥ë ¥ í™œì„±í™”: ëª¨ë‹¬ì°½ì„ ì„¤ì •í•˜ê³  ë„ì›ë‹ˆë‹¤.
       */
      function activateKantAbility(player) {
        kantProposition = []; // ëª…ì œ ë°°ì—´ ì´ˆê¸°í™”
        const modal = document.getElementById("kant-ability-modal");

        // UI í…ìŠ¤íŠ¸ ì„¤ì •
        document.getElementById("kant-ability-title").textContent =
          currentLang.langCode === "ko"
            ? "ì„ í—˜ì  ì¢…í•©íŒë‹¨"
            : "Synthetic A Priori Judgment";
        document.getElementById("kant-current-proposition-title").textContent =
          currentLang.langCode === "ko"
            ? "êµ¬ì„±ì¤‘ì¸ ëª…ì œ"
            : "Proposition under Construction";
        document.getElementById("kant-hand-title").textContent =
          currentLang.langCode === "ko"
            ? "ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë“œ"
            : "Available Cards";
        document.getElementById("kant-undo-btn").textContent =
          currentLang.ui.undoButton;
        document.getElementById("kant-confirm-btn").textContent =
          currentLang.ui.completeButton;

        // ë˜ëŒë¦¬ê¸° ë²„íŠ¼ ê¸°ëŠ¥ ì—°ê²°
        document.getElementById("kant-undo-btn").onclick = () => {
          audioManager.playSfx("hover");
          if (kantProposition.length > 0) {
            const cardToReturn = kantProposition.pop();
            const hand = player === "A" ? playerA_Hand : playerB_Hand;
            hand.push(cardToReturn);
            // ì†íŒ¨ ì •ë ¬ì„ ë‹¤ì‹œ í•´ì£¼ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
            hand.sort(
              (a, b) =>
                cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
            );
            renderKantModal(player);
          }
        };

        // ë‹«ê¸° ë²„íŠ¼ ê¸°ëŠ¥ ì—°ê²° (ì¤‘ìš”: ì·¨ì†Œ ì‹œ ì¹´ë“œë¥¼ ëª¨ë‘ ì†íŒ¨ë¡œ ë˜ëŒë¦¼)
        document.getElementById("close-kant-modal-btn").onclick = () => {
          audioManager.playSfx("hover");
          if (kantProposition.length > 0) {
            const hand = player === "A" ? playerA_Hand : playerB_Hand;
            hand.push(...kantProposition);
            kantProposition = [];
            hand.sort(
              (a, b) =>
                cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
            );
          }
          modal.classList.remove("visible");
          render(); // ë©”ì¸ ê²Œì„ í™”ë©´ë„ ê°±ì‹ 
        };

        document.getElementById("kant-confirm-btn").onclick = () => {
          audioManager.playSfx("hover");
          confirmKantAbility(player);
        };

        // ì´ˆê¸° ëª¨ë‹¬ ë Œë”ë§ ë° í‘œì‹œ
        renderKantModal(player);
        modal.classList.add("visible");
      }
      function executePlatoAbilityCheck(player) {
        // 1. ì‚¬ìš© ê°€ëŠ¥í•œ 'ì–´ë–¤' ëª…ì œ ì°¾ê¸°
        const availableExistentials = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "existential"
        );
        if (availableExistentials.length === 0) {
          return null;
        }

        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData) {
          return null;
        }
        const myGoalPredicate = myVictoryData.core_goal.predicate;
        const opponentGoalPredicate = opponentVictoryData
          ? opponentVictoryData.core_goal.predicate
          : null;

        const opponentDefeatPredicate = opponentGoalPredicate
          ? currentLang.contradictoryPredicates[opponentGoalPredicate] ||
            Object.keys(currentLang.contradictoryPredicates).find(
              (key) =>
                currentLang.contradictoryPredicates[key] ===
                opponentGoalPredicate
            )
          : null;

        const candidates = availableExistentials.map((propData) => {
          const originalProp = propData.proposition;
          const universalProp = {
            type: "universal",
            entity: originalProp.entity,
            predicate: originalProp.predicate,
          };
          const isAlreadyKnown = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, universalProp)
          );

          if (isAlreadyKnown) {
            return { newProp: universalProp, score: -1 };
          }
          let score = 100;
          if (universalProp.predicate === myGoalPredicate) {
            score += 10000;
          }
          if (
            opponentDefeatPredicate &&
            universalProp.predicate === opponentDefeatPredicate
          ) {
            score += 8000;
          }
          if (
            opponentGoalPredicate &&
            universalProp.predicate === opponentGoalPredicate
          ) {
            score -= 5000;
          }

          const verificationResult = verifyAndExpandTruths(
            universalProp,
            internalTruthSet
          );

          if (!verificationResult.success) {
            // 1. ì§ì ‘ì ì¸ ëª¨ìˆœì´ ë°œìƒí•˜ë©´ ì¦‰ì‹œ ì œì™¸
            score = -1;
          } else {
            // 2. ëª¨ìˆœì´ ì—†ë‹¤ë©´, ëŠ¥ë ¥ ì‚¬ìš©ìœ¼ë¡œ í™•ì¥ëœ ì§„ë¦¬ ì§‘í•©ì—ì„œ
            //    ìƒëŒ€ë°©ì˜ ìŠ¹ë¦¬ê°€ ì¦ëª…ë˜ëŠ”ì§€ 'ë…¼ë¦¬ ì—°ì‡„'ë¥¼ ì‹œë®¬ë ˆì´ì…˜
            if (
              opponentVictoryData &&
              aiFindProof(
                opponentVictoryData.ultimate_target,
                verificationResult.expandedSet // í™•ì¥ëœ ë¯¸ë˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê²€ì¦
              )
            ) {
              // 3. ìƒëŒ€ë°©ì˜ ìŠ¹ë¦¬ê°€ ì¦ëª…ëœë‹¤ë©´, ì´ ìˆ˜ëŠ” ìì‚´ í–‰ìœ„ì´ë¯€ë¡œ ë§‰ëŒ€í•œ í˜ë„í‹° ë¶€ì—¬
              console.warn(
                `[Plato AI] SUICIDE PREVENTION: Using ability on '${propositionToNaturalText(
                  originalProp
                )}' would prove opponent's victory. Massive penalty applied.`
              );
              score -= 999999;
            }
            const myOppositePredicate = myGoalPredicate
              ? currentLang.contradictoryPredicates[myGoalPredicate] ||
                Object.keys(currentLang.contradictoryPredicates).find(
                  (key) =>
                    currentLang.contradictoryPredicates[key] === myGoalPredicate
                )
              : null;

            if (myOppositePredicate) {
              const myDefeatCondition = {
                type: "atomic",
                subject: myVictoryData.core_goal.subject,
                predicate: myOppositePredicate,
              };

              if (
                aiFindProof(myDefeatCondition, verificationResult.expandedSet)
              ) {
                console.warn(
                  `[Plato AI] SUICIDE PREVENTION (Self Defeat): Using ability on '${propositionToNaturalText(
                    originalProp
                  )}' would prove its own defeat condition '${propositionToNaturalText(
                    myDefeatCondition
                  )}'. Massive penalty applied.`
                );
                score -= 900000;
              }
            }
          }

          return { newProp: universalProp, score: score };
        });

        const validCandidates = candidates.filter((c) => c.score > 0);
        if (validCandidates.length === 0) {
          return null;
        }

        validCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = validCandidates[0];

        const MINIMUM_SCORE_THRESHOLD = 150;
        if (bestCandidate.score < MINIMUM_SCORE_THRESHOLD) {
          return null;
        }

        // ëŠ¥ë ¥ ì‚¬ìš© ì‹¤í–‰
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[player].used = true;

        const newTheorem = {
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem",
          source: "plato_ability",
          proposition: bestCandidate.newProp,
        };
        truePropositions.push(newTheorem);

        const finalVerification = verifyAndExpandTruths(
          bestCandidate.newProp,
          internalTruthSet
        );
        if (finalVerification.success) {
          internalTruthSet = finalVerification.expandedSet;
        } else {
          console.error(
            "AI Plato Ability CRITICAL: Contradiction after final check."
          );
          return null;
        }

        return {
          type: "ability",
          description: currentLang.ui.platoAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.newProp)
          ),
        };
      }
      function executeSocratesAbilityCheck(player) {
        // 1. ëŠ¥ë ¥ ì‚¬ìš© ê¸°ë³¸ ì¡°ê±´ í™•ì¸
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (
          abilityUsedState[player].usedCount >= abilityUsedState[player].maxUses
        ) {
          return null;
        }
        const availablePropositions = truePropositions.filter((p) => {
          const isTargetType = p.type === "user-made" || p.type === "theorem";
          if (!isTargetType || !p.propId) return false;

          const isDisabled = socratesDisabledProps.some(
            (disabledProp) => disabledProp.propId === p.propId
          );
          return !isDisabled; // ë¹„í™œì„±í™”ë˜ì§€ ì•Šì€ ê²ƒë§Œ true
        });
        if (availablePropositions.length === 0) {
          return null;
        }

        // 2. AIì™€ ìƒëŒ€ë°©ì˜ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData || !opponentVictoryData) return null;

        const internalTruthSet = getTemporaryUsableTruths();

        // 3. ì œê±°í•  í›„ë³´ ëª…ì œë“¤ì˜ ìœ„í˜‘ ì ìˆ˜ ê³„ì‚°

        // 3-1. ê²½ê³„í•´ì•¼ í•  'ìœ„í—˜í•œ ì „ì¹­ ì–‘í™”ë¬¸' ëª©ë¡ ìƒì„±
        const entities = currentLang.cards
          .filter(
            (c) =>
              c.type === (currentLang.langCode === "ko" ? "ê°œì²´" : "Entity")
          )
          .map((c) => c.text);
        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        const dangerousUniversals = [];
        entities.forEach((entity) => {
          // ìƒëŒ€ ìŠ¹ë¦¬ì— ë„ì›€ì´ ë˜ëŠ” ì „ì¹­ ì–‘í™”ë¬¸
          dangerousUniversals.push({
            type: "universal",
            entity: entity,
            predicate: opponentWinPredicate,
          });
          // ë‚´ ìŠ¹ë¦¬ì— ë°©í•´ê°€ ë˜ëŠ” ì „ì¹­ ì–‘í™”ë¬¸
          if (myOppositePredicate) {
            dangerousUniversals.push({
              type: "universal",
              entity: entity,
              predicate: myOppositePredicate,
            });
          }
        });

        // 3-2. ê° í›„ë³´ ëª…ì œë³„ ì ìˆ˜ ê³„ì‚°
        const scoredCandidates = availablePropositions.map((propData) => {
          let score = 0;
          const candidateProp = propData.proposition;

          // --- PRIORITY 1: íŒ¨ë°° ì„ë°• ìƒí™© ë°©ì–´ ---
          const opponentWinsWithCurrentTruths = aiFindProof(
            opponentVictoryData.ultimate_target,
            internalTruthSet
          );
          if (opponentWinsWithCurrentTruths) {
            const tempTruthSetWithoutCandidate = internalTruthSet.filter(
              (p) => !arePropositionsEqual(p, candidateProp)
            );
            const opponentStillWins = aiFindProof(
              opponentVictoryData.ultimate_target,
              tempTruthSetWithoutCandidate
            );
            if (!opponentStillWins) {
              score += 10000;
            }
          }

          // --- PRIORITY 2: ìƒëŒ€ í•µì‹¬ ëª©í‘œ ì§ì ‘ ì œê±° ---
          const opponentCoreGoal = opponentVictoryData.core_goal;
          if (arePropositionsEqual(candidateProp, opponentCoreGoal)) {
            score += 6000;
          }

          // --- PRIORITY 3: ìê¸° ë³´ì¡´ ---
          const myCoreGoalContradiction = {
            type: "negation",
            proposition: myVictoryData.core_goal,
          };
          if (arePropositionsEqual(candidateProp, myCoreGoalContradiction)) {
            score += 2000;
          }

          // --- PRIORITY 4: ìœ„í˜‘ì ì¸ ì „ì¹­ ì–‘í™”ë¬¸ ì§ì ‘ ì œê±° ---
          if (candidateProp.type === "universal") {
            if (candidateProp.predicate === opponentWinPredicate) {
              score += 3000;
            }
            if (
              myOppositePredicate &&
              candidateProp.predicate === myOppositePredicate
            ) {
              score += 2500;
            }
          }

          const otherTruthsOnBoard = internalTruthSet.filter(
            (p) => !arePropositionsEqual(p, candidateProp)
          );

          for (const otherProp of otherTruthsOnBoard) {
            // 1. ì„ ì–¸ì  ì‚¼ë‹¨ë…¼ë²• (ì‚¬ìš©ì ìš”ì²­ ì‹œë‚˜ë¦¬ì˜¤)
            const dsResult = disjunctiveSyllogism(candidateProp, otherProp);
            if (dsResult) {
              const isDangerous = dangerousUniversals.some((dangerousUniv) =>
                arePropositionsEqual(dsResult, dangerousUniv)
              );
              if (isDangerous) {
                console.log(
                  `%c[Socrates AI] DS threat detected! Keeping '${propositionToNaturalText(
                    candidateProp
                  )}' would allow proving a dangerous universal with another proposition. Threat score +7500.`,
                  "color: #ff4500"
                );
                score += 7500;
              }
            }

            // 2. ì „ê±´ ê¸ì •
            const mpResult = modusPonens(candidateProp, otherProp);
            if (mpResult) {
              const isDangerous = dangerousUniversals.some((dangerousUniv) =>
                arePropositionsEqual(mpResult, dangerousUniv)
              );
              if (isDangerous) {
                console.log(
                  `%c[Socrates AI] MP threat detected! Keeping '${propositionToNaturalText(
                    candidateProp
                  )}' would allow proving a dangerous universal with another proposition. Threat score +7500.`,
                  "color: #ff4500"
                );
                score += 7500;
              }
            }
            // (ë‹¤ë¥¸ ë‹¤ì¤‘ ì „ì œ ì¶”ë¡  ê·œì¹™ë„ ì—¬ê¸°ì— ì¶”ê°€ ê°€ëŠ¥)
          }

          return {
            propData,
            score,
          };
        });

        // 4. ê°€ì¥ ìœ„í˜‘ì ì¸ ëª…ì œ ì„ íƒ ë° ëŠ¥ë ¥ ì‹¤í–‰
        scoredCandidates.sort((a, b) => b.score - a.score);

        if (scoredCandidates.length > 0 && scoredCandidates[0].score > 0) {
          console.log(
            "Socrates AI Top Candidates for Removal:",
            scoredCandidates.slice(0, 3).map((c) => ({
              prop: propositionToNaturalText(c.propData.proposition),
              score: c.score,
            }))
          );
        }

        const bestCandidate = scoredCandidates[0];

        const MINIMUM_THREAT_SCORE = 1500;
        if (!bestCandidate || bestCandidate.score < MINIMUM_THREAT_SCORE) {
          return null;
        }

        abilityUsedState[player].usedCount++;
        socratesDisabledProps.push({
          propId: bestCandidate.propData.propId,
          reEnableRound: currentRound + 2,
        });

        console.log(
          `%cAI Socrates used Awareness of Ignorance on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Threat Score: ${bestCandidate.score})`,
          "color: #8e44ad; font-weight: bold;"
        );

        return {
          type: "ability",
          description: currentLang.ui.socratesAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.propData.proposition)
          ),
        };
      }
      function executeDescartesAbilityCheck(player) {
        // --- 1. ê¸°ë³¸ ì¡°ê±´ í™•ì¸ ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) {
          return null;
        }
        const availablePropositions = truePropositions.filter(
          (p) => (p.type === "user-made" || p.type === "theorem") && p.propId
        );
        if (availablePropositions.length === 0) {
          return null;
        }

        // --- 2. ìœ„í˜‘ ì ìˆ˜ ì‚°ì¶œ ---
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData || !opponentVictoryData) return null;

        const truthSetForScoring = getTemporaryUsableTruths();

        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        const scoredCandidates = availablePropositions.map((propData) => {
          let score = 0;
          const candidateProp = propData.proposition;

          // ì ìˆ˜ ê³„ì‚° ì‹œ, ìƒˆë¡œ ëª…ëª…í•œ 'truthSetForScoring' ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
          const opponentWinsWithCurrentTruths = aiFindProof(
            opponentVictoryData.ultimate_target,
            truthSetForScoring
          );
          if (opponentWinsWithCurrentTruths) {
            const tempTruthSetWithoutCandidate = truthSetForScoring.filter(
              (p) => !arePropositionsEqual(p, candidateProp)
            );
            const opponentStillWins = aiFindProof(
              opponentVictoryData.ultimate_target,
              tempTruthSetWithoutCandidate
            );
            if (!opponentStillWins) {
              score += 10000;
            }
          }
          if (
            arePropositionsEqual(candidateProp, opponentVictoryData.core_goal)
          ) {
            score += 6000;
          }
          if (
            myOppositePredicate &&
            candidateProp.predicate === myOppositePredicate
          ) {
            score += 2500;
          }
          if (
            candidateProp.type === "universal" &&
            candidateProp.predicate === opponentWinPredicate
          ) {
            score += 3000;
          }
          return { propData, score };
        });

        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate =
          scoredCandidates.length > 0 ? scoredCandidates[0] : null;

        // --- 3. ì‹¤í–‰ ê²°ì • ë° ëŠ¥ë ¥ ë°œë™ ---
        const MINIMUM_THREAT_SCORE = 1500;
        if (!bestCandidate || bestCandidate.score < MINIMUM_THREAT_SCORE) {
          return null;
        }

        console.log(
          `%cAI Descartes used Methodic Doubt on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Threat Score: ${bestCandidate.score})`,
          "color: #3498db; font-weight: bold;"
        );

        abilityUsedState[player].used = true;

        const propIndex = truePropositions.findIndex(
          (p) => p.propId === bestCandidate.propData.propId
        );
        if (propIndex > -1) {
          truePropositions.splice(propIndex, 1);
        }

        // ì§„ë¦¬ ì§‘í•© ì¬êµ¬ì„± (ì´ ë¶€ë¶„ì€ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤)
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after AI Descartes' ability: Inconsistency found."
            );
          }
        }

        // â˜…â˜…â˜… ì „ì—­ ë³€ìˆ˜ì¸ 'internalTruthSet'ì— ìµœì¢… ê²°ê³¼ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.
        internalTruthSet = newTruthSet;

        return {
          type: "ability",
          description: currentLang.ui.descartesAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.propData.proposition)
          ),
        };
      }
      function executeHumeAbilityCheck(player) {
        // --- 1. ê¸°ë³¸ ì¡°ê±´ í™•ì¸ ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (
          !abilityUsedState[player] ||
          abilityUsedState[player].usedCount >= abilityUsedState[player].maxUses
        ) {
          return null; // ì‚¬ìš© íšŸìˆ˜ ì´ˆê³¼
        }

        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "universal" && p.propId
        );

        if (availablePropositions.length === 0) {
          return null; // êµì²´í•  ëª…ì œ ì—†ìŒ
        }

        // --- 2. ìœ„í˜‘ ì ìˆ˜ ì‚°ì¶œì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„ ---
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        // --- 3. ê° í›„ë³´ì˜ 'ìœ„í˜‘ ì ìˆ˜' ê³„ì‚° ---
        const scoredCandidates = availablePropositions.map((propData) => {
          let score = 0;
          const candidateProp = propData.proposition;

          // ìƒëŒ€ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ì§ì ‘ì ìœ¼ë¡œ ê´€ë ¨ë ìˆ˜ë¡ ìœ„í˜‘ì 
          if (candidateProp.predicate === opponentWinPredicate) {
            score += 5000;
          }

          // ë‚´ ìŠ¹ë¦¬ ì¡°ê±´ì— ë°˜ëŒ€ë ìˆ˜ë¡ ìœ„í˜‘ì 
          if (
            myOppositePredicate &&
            candidateProp.predicate === myOppositePredicate
          ) {
            score += 4000;
          }

          return { propData, score };
        });

        scoredCandidates.sort((a, b) => b.score - a.score);

        const bestCandidate =
          scoredCandidates.length > 0 ? scoredCandidates[0] : null;

        // --- 4. ì‹¤í–‰ ê²°ì • ë° ëŠ¥ë ¥ ë°œë™ ---
        const MINIMUM_THREAT_SCORE = 2000; // ê¸°ì¤€ ì ìˆ˜ ì„¤ì •
        if (!bestCandidate || bestCandidate.score < MINIMUM_THREAT_SCORE) {
          return null; // ì‚¬ìš©í•  ê°€ì¹˜ê°€ ìˆëŠ” ëª…ì œê°€ ì—†ìŒ
        }

        console.log(
          `%cAI Hume used Problem of Induction on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Threat Score: ${bestCandidate.score})`,
          "color: #e67e22; font-weight: bold;"
        );

        const propIndex = truePropositions.findIndex(
          (p) => p.propId === bestCandidate.propData.propId
        );
        if (propIndex === -1) return null;

        const originalProp = truePropositions[propIndex].proposition;
        const newExistentialProp = {
          type: "existential",
          entity: originalProp.entity,
          predicate: originalProp.predicate,
        };

        // ì‹¤ì œ ê²Œì„ ìƒíƒœ ë³€ê²½
        truePropositions[propIndex].proposition = newExistentialProp;
        truePropositions[propIndex].original_cards = null; // ë Œë”ë§ì„ ìœ„í•´ ì¹´ë“œ ì •ë³´ ì´ˆê¸°í™”
        truePropositions[propIndex].type = "theorem";
        truePropositions[propIndex].source = "hume_ability";

        abilityUsedState[player].usedCount++;

        // ì§„ë¦¬ ì§‘í•© ì¬êµ¬ì„±
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after AI Hume's ability: Inconsistency found."
            );
          }
        }
        internalTruthSet = newTruthSet;

        // ìš”ì•½ ì •ë³´ ë°˜í™˜
        return {
          type: "ability",
          description: currentLang.ui.humeAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(originalProp)
          ),
        };
      }
      /**
       * íŠ¹ì • ëª…ì œê°€ AIì—ê²Œ ì–¼ë§ˆë‚˜ ìœ„í˜‘ì ì¸ì§€ ì ìˆ˜ë¡œ í‰ê°€í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
       * @param {object} prop - í‰ê°€í•  ëª…ì œ ê°ì²´
       * @param {string} perspectivePlayer - AI í”Œë ˆì´ì–´ ('A' ë˜ëŠ” 'B')
       * @param {object} myVictoryData - AIì˜ ìŠ¹ë¦¬ ì¡°ê±´ ë°ì´í„°
       * @param {object} opponentVictoryData - ìƒëŒ€ì˜ ìŠ¹ë¦¬ ì¡°ê±´ ë°ì´í„°
       * @returns {number} ìœ„í˜‘ ì ìˆ˜
       */
      function scoreThreat(
        prop,
        perspectivePlayer,
        myVictoryData,
        opponentVictoryData
      ) {
        if (!prop || !myVictoryData || !opponentVictoryData) return 0;

        let score = 0;
        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        // 1. ìƒëŒ€ì˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ì§ì ‘ì ìœ¼ë¡œ ì—°ê´€ë˜ë©´ ë†’ì€ ì ìˆ˜
        if (prop.predicate === opponentWinPredicate) {
          score += prop.type === "universal" ? 5000 : 1000;
        }
        // 2. ë‚˜ì˜ ìŠ¹ë¦¬ ì¡°ê±´ê³¼ ë°˜ëŒ€ë˜ë©´ ë†’ì€ ì ìˆ˜
        if (myOppositePredicate && prop.predicate === myOppositePredicate) {
          score += prop.type === "universal" ? 4000 : 800;
        }
        // 3. ìƒëŒ€ì˜ ì¦‰ì‹œ ìŠ¹ë¦¬ë¥¼ ìœ ë°œí•˜ëŠ” ëª…ì œë¼ë©´ ë§¤ìš° ë†’ì€ ì ìˆ˜
        if (arePropositionsEqual(prop, opponentVictoryData.ultimate_target)) {
          score += 20000;
        }
        // 4. ë‚˜ì˜ ì¦‰ì‹œ íŒ¨ë°°ë¥¼ ìœ ë°œí•˜ëŠ” ëª…ì œë¼ë©´ ë§¤ìš° ë†’ì€ ì ìˆ˜
        const myDefeatCondition = {
          type: "negation",
          proposition: myVictoryData.ultimate_target,
        };
        if (arePropositionsEqual(prop, myDefeatCondition)) {
          score += 18000;
        }

        return score;
      }

      /**
       * AIê°€ ë¹„íŠ¸ê²ìŠˆíƒ€ì¸ì˜ 'ì‚¬ë‹¤ë¦¬ ê±·ì–´ì°¨ê¸°' ëŠ¥ë ¥ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•˜ê³  ì‹¤í–‰í•˜ëŠ” í•¨ìˆ˜
       * @param {string} player - ëŠ¥ë ¥ì„ ì‚¬ìš©í•˜ë ¤ëŠ” AI í”Œë ˆì´ì–´ ('A' ë˜ëŠ” 'B')
       * @returns {object|null} AI í–‰ë™ ìš”ì•½ ê°ì²´ ë˜ëŠ” null
       */
      function executeWittgensteinAbilityCheck(player) {
        // --- 0. ê¸°ë³¸ ì¡°ê±´ ê²€ì‚¬ ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) {
          return null; // ì´ë¯¸ ëŠ¥ë ¥ì„ ì‚¬ìš©í–ˆìœ¼ë©´ ì¢…ë£Œ
        }

        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        // --- 1ë‹¨ê³„: ì œê±°í•  'í•µì‹¬ ìœ„í˜‘' ëª©ë¡ ìƒì„± ë° ì •ë ¬ ---
        const allTruthsOnBoard = getTemporaryUsableTruths();
        const candidatePropositions = truePropositions.filter(
          (p) => (p.type === "user-made" || p.type === "theorem") && p.propId
        );

        if (candidatePropositions.length === 0) {
          return null; // ì œê±°í•  í›„ë³´ ëª…ì œê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
        }

        const scoredCandidates = candidatePropositions.map((propData) => {
          const threatScore = scoreThreat(
            propData.proposition,
            player,
            myVictoryData,
            opponentVictoryData
          );
          return { propData, score: threatScore };
        });

        // ìœ„í˜‘ ì ìˆ˜ê°€ ë†’ì€ ìˆœìœ¼ë¡œ í›„ë³´ë“¤ì„ ì •ë ¬
        scoredCandidates.sort((a, b) => b.score - a.score);

        // --- 2ë‹¨ê³„ & 3ë‹¨ê³„: ìµœìš°ì„  ìœ„í˜‘ë¶€í„° ìˆœì„œëŒ€ë¡œ ì œê±° ë°©ë²• íƒìƒ‰ ë° í‰ê°€ ---

        // ëª¨ë“  ì¶”ë¡  ê·œì¹™ ëª©ë¡
        const allRules = [
          { rule: modusPonens, arity: 2 },
          { rule: modusTollens, arity: 2 },
          { rule: hypotheticalSyllogism, arity: 2 },
          { rule: disjunctiveSyllogism, arity: 2 },
          { rule: universalApplication, arity: 2 },
          { rule: proofByCases, arity: 3 },
        ];

        // ê°€ì¥ ìœ„í˜‘ì ì¸ í›„ë³´ë¶€í„° ìˆœíšŒ
        for (const candidate of scoredCandidates) {
          const MINIMUM_THREAT_SCORE = 1; // ìµœì†Œ ìœ„í˜‘ ì ìˆ˜ ê¸°ì¤€ ì„¤ì •
          if (candidate.score < MINIMUM_THREAT_SCORE) {
            continue; // ì ìˆ˜ê°€ ê¸°ì¤€ë³´ë‹¤ ë‚®ìœ¼ë©´ ì´ í›„ë³´ëŠ” ê±´ë„ˆëœ€
          }
          const targetPropData = candidate.propData;
          const targetProp = targetPropData.proposition;

          // ì´ ëª©í‘œë¬¼ì„ ì œê±°í•  íŒŒíŠ¸ë„ˆë¥¼ ì°¾ê¸° ìœ„í•´ ë‹¤ë¥¸ ëª¨ë“  ëª…ì œë¥¼ ìˆœíšŒ
          for (const partnerData of truePropositions) {
            if (
              !partnerData.proposition ||
              targetPropData.propId === partnerData.propId
            )
              continue;
            const partnerProp = partnerData.proposition;

            // ëª¨ë“  ì¶”ë¡  ê·œì¹™ì„ ì‹œë„
            for (const { rule, arity } of allRules) {
              let premises = [];
              let newTheorem = null;

              if (arity === 2) {
                // ê·œì¹™ì— ë”°ë¼ ì „ì œ ìˆœì„œê°€ ì¤‘ìš”í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‘ ê°€ì§€ ê²½ìš° ëª¨ë‘ ì‹œë„
                premises = [targetProp, partnerProp];
                newTheorem = rule(premises[0], premises[1]);

                if (!newTheorem) {
                  premises = [partnerProp, targetProp];
                  newTheorem = rule(premises[0], premises[1]);
                }
              }
              // (í•„ìš” ì‹œ arity 3 ì´ìƒ ê·œì¹™ì— ëŒ€í•œ ë¡œì§ ì¶”ê°€)

              if (!newTheorem) continue; // ì´ ì¡°í•©ìœ¼ë¡œëŠ” ìƒˆë¡œìš´ ì •ë¦¬ê°€ ì•ˆ ë‚˜ì˜¤ë©´ ë‹¤ìŒ ê·œì¹™ìœ¼ë¡œ

              // --- 3-1. ê³„íš í‰ê°€: ì•ˆì „ì„± ë° íš¨ìœ¨ì„± ê²€ì‚¬ ---
              const premisesToKickData = [targetPropData, partnerData];
              const idsToKick = new Set(
                premisesToKickData.map((p) => p.propId).filter(Boolean)
              );

              // ê°€ìƒ ì‹œë‚˜ë¦¬ì˜¤: ì „ì œë“¤ì„ ì œê±°í•˜ê³  ìƒˆ ì •ë¦¬ë¥¼ ì¶”ê°€
              const remainingPropositions = truePropositions.filter(
                (p) => !idsToKick.has(p.propId)
              );
              const hypotheticalTruths = remainingPropositions
                .map((p) => p.proposition)
                .filter(Boolean);

              const verificationResult = verifyAndExpandTruths(
                newTheorem,
                hypotheticalTruths
              );
              if (!verificationResult.success) continue; // ëª¨ìˆœ ë°œìƒ ì‹œ ê¸°ê°

              const finalTruthSet = verificationResult.expandedSet;

              // ì•ˆì „ì„± ê²€ì‚¬: ëŠ¥ë ¥ ì‚¬ìš© í›„ ë‚´ê°€ ì§€ê±°ë‚˜ ìƒëŒ€ê°€ ì´ê¸°ëŠ”ì§€ í™•ì¸
              if (
                aiFindProof(
                  opponentVictoryData.ultimate_target,
                  finalTruthSet
                ) ||
                aiFindProof(
                  {
                    type: "negation",
                    proposition: myVictoryData.ultimate_target,
                  },
                  finalTruthSet
                )
              ) {
                continue; // ì¹˜ëª…ì  ê²°ê³¼ê°€ ë°œìƒí•˜ë©´ ê¸°ê°
              }

              // íš¨ìœ¨ì„± ê²€ì‚¬: ì œê±°í•˜ë ¤ë˜ ìœ„í˜‘(targetProp)ì´ ë‹¤ì‹œ ì¦ëª…ë˜ëŠ”ì§€ í™•ì¸
              if (aiFindProof(targetProp, finalTruthSet)) {
                continue; // ì‚¬ë‹¤ë¦¬ê°€ ì œê±°ë˜ì§€ ì•Šìœ¼ë©´ ê¸°ê°
              }

              // --- 4ë‹¨ê³„: ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í•œ ì²« ë²ˆì§¸ ê³„íšì„ ì¦‰ì‹œ ì‹¤í–‰ ---
              console.log(
                `%c[AI Wittgenstein] Target Acquired: ${propositionToNaturalText(
                  targetProp
                )} (Threat: ${candidate.score})`,
                "color: #2ecc71; font-weight: bold;"
              );
              console.log(
                `%c[AI Wittgenstein] Justification Found: Using partner '${propositionToNaturalText(
                  partnerProp
                )}' to derive '${propositionToNaturalText(newTheorem)}'`,
                "color: #2ecc71;"
              );

              abilityUsedState[player].used = true;
              truePropositions = remainingPropositions; // ì „ì œë“¤ì´ ì œê±°ëœ ëª©ë¡ìœ¼ë¡œ êµì²´

              truePropositions.push({
                propId: `prop_${Date.now()}_${Math.random()}`,
                type: "theorem",
                round: currentRound,
                proposition: newTheorem,
                source: "wittgenstein_ability",
              });

              internalTruthSet = finalTruthSet; // ì¬êµ¬ì„±ëœ ì§„ë¦¬ ì§‘í•©ìœ¼ë¡œ ì—…ë°ì´íŠ¸

              return {
                type: "ability",
                description:
                  currentLang.ui.wittgensteinAbilityDescription.replace(
                    "{newTheorem}",
                    propositionToNaturalText(newTheorem)
                  ),
              };
            }
          }
        }

        // ëª¨ë“  ìœ„í˜‘ì ì¸ ëª…ì œì— ëŒ€í•´ ìœ íš¨í•œ ì œê±° ê³„íšì„ ì°¾ì§€ ëª»í•¨
        return null;
      }
      function getOppositePredicate(predicate) {
        const predicatePairs = currentLang.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === predicate) return predicatePairs[key];
          if (predicatePairs[key] === predicate) return key;
        }
        return null;
      }

      function simulateKuhnsAbility(propIdToChange) {
        const originalPropData = truePropositions.find(
          (p) => p.propId === propIdToChange
        );
        if (!originalPropData) return null;

        const newPredicate = getOppositePredicate(
          originalPropData.proposition.predicate
        );
        if (!newPredicate) return null;

        const newParadigmProposition = {
          type: "universal",
          entity: originalPropData.proposition.entity,
          predicate: newPredicate,
        };

        const newParadigmPropForList = {
          propId: `sim_${Date.now()}`,
          type: "theorem",
          source: "kuhn_ability",
          proposition: newParadigmProposition,
        };

        const axioms = parsedAxioms.map((a) => a.proposition);
        const victoryConditions = truePropositions
          .filter((p) => p.type === "victory")
          .map((p) => p.proposition);
        const foundationOfTruths = [
          ...axioms,
          ...victoryConditions,
          newParadigmProposition,
        ];

        const preCheckResult = verifyAndExpandTruths(null, foundationOfTruths);
        if (!preCheckResult.success) return null;

        let currentValidatedTruths = preCheckResult.expandedSet;
        let survivingPropositions = [
          ...truePropositions.filter((p) => p.type === "victory"),
          newParadigmPropForList,
        ];

        const candidatesForRevalidation = truePropositions.filter(
          (p) =>
            (p.type === "user-made" || p.type === "theorem") &&
            p.propId !== propIdToChange
        );

        for (const candidate of candidatesForRevalidation) {
          const validationResult = verifyAndExpandTruths(
            candidate.proposition,
            currentValidatedTruths
          );
          if (validationResult.success) {
            currentValidatedTruths = validationResult.expandedSet;
            survivingPropositions.push(candidate);
          }
        }

        return {
          success: true,
          finalTruthSet: currentValidatedTruths,
          finalPropList: survivingPropositions,
        };
      }

      function executeKuhnsAbility(propIdToChange, player) {
        const simResult = simulateKuhnsAbility(propIdToChange);
        if (!simResult || !simResult.success) {
          console.error(
            "AI Kuhn CRITICAL: Simulation passed but execution failed."
          );
          return null;
        }

        truePropositions = simResult.finalPropList;
        internalTruthSet = simResult.finalTruthSet;

        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[player].used = true;

        const newParadigmProp = simResult.finalPropList.find(
          (p) => p.source === "kuhn_ability"
        ).proposition;
        return {
          type: "ability",
          description: currentLang.ui.kuhnAbilityDescription.replace(
            "{newParadigm}",
            propositionToNaturalText(newParadigmProp)
          ),
        };
      }

      function executeKuhnAbilityCheck(player) {
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) return null;

        const userMadePropsCount = truePropositions.filter(
          (p) => p.type === "user-made"
        ).length;
        if (userMadePropsCount < 15) return null;

        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "universal" && p.propId
        );
        if (availablePropositions.length === 0) return null;

        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData || !opponentVictoryData) return null;

        const myUltimateGoal = myVictoryData.ultimate_target;

        for (const propData of availablePropositions) {
          const simResult = simulateKuhnsAbility(propData.propId);
          if (simResult && simResult.success) {
            if (aiFindProof(myUltimateGoal, simResult.finalTruthSet)) {
              console.log(
                `%c[AI Kuhn] PRIORITY 1 WIN DETECTED! Shifting paradigm on: ${propositionToNaturalText(
                  propData.proposition
                )}`,
                "color: #f1c40f; font-weight: bold;"
              );
              return executeKuhnsAbility(propData.propId, player);
            }
          }
        }

        const scoredCandidates = availablePropositions
          .map((propData) => {
            let score = 0;
            const originalPredicate = propData.proposition.predicate;
            const newPredicate = getOppositePredicate(originalPredicate);
            if (!newPredicate) return { propData, score: -1 };

            const simResult = simulateKuhnsAbility(propData.propId);
            if (!simResult || !simResult.success)
              return { propData, score: -1 };
            if (
              aiFindProof(
                opponentVictoryData.ultimate_target,
                simResult.finalTruthSet
              )
            ) {
              return { propData, score: -1 };
            }

            if (newPredicate === myVictoryData.core_goal.predicate) {
              score = 5000;
            } else {
              const opponentOppositePredicate = getOppositePredicate(
                opponentVictoryData.core_goal.predicate
              );
              if (
                opponentOppositePredicate &&
                newPredicate === opponentOppositePredicate
              ) {
                score = 3000;
              }
            }
            return { propData, score };
          })
          .filter((c) => c.score > 0);

        if (scoredCandidates.length === 0) return null;

        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = scoredCandidates[0];

        console.log(
          `%c[AI Kuhn] Strategic move selected. Shifting paradigm on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Score: ${bestCandidate.score})`,
          "color: #f1c40f;"
        );
        return executeKuhnsAbility(bestCandidate.propData.propId, player);
      }
      /**
       * AIê°€ ë°ë¦¬ë‹¤ì˜ 'í•´ì²´' ëŠ¥ë ¥ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•˜ê³  ì‹¤í–‰í•˜ëŠ” í•¨ìˆ˜
       * @param {string} player - ëŠ¥ë ¥ì„ ì‚¬ìš©í•˜ë ¤ëŠ” AI í”Œë ˆì´ì–´ ('A' ë˜ëŠ” 'B')
       * @returns {object|null} AI í–‰ë™ ìš”ì•½ ê°ì²´ ë˜ëŠ” null
       */
      function executeDerridaAbilityCheck(player) {
        // --- ê¸°ë³¸ ì¡°ê±´ ê²€ì‚¬ ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) {
          return null; // ì´ë¯¸ ëŠ¥ë ¥ì„ ì‚¬ìš©í–ˆìœ¼ë©´ ì¢…ë£Œ
        }

        // --- 0. 'ê·¸ë¦¬ê³ 'ë¥¼ ì œì™¸í•œ ì—°ê²°ì‚¬ë¡œ ì—°ê²°ëœ ëª…ì œ ì°¾ê¸° ---
        const availablePropositions = truePropositions.filter(
          (p) =>
            p.propId && // IDê°€ ìˆì–´ ì¶”ì  ë° ì‚­ì œê°€ ê°€ëŠ¥í•œ ëª…ì œë§Œ
            p.proposition &&
            (p.proposition.type === "conditional" ||
              p.proposition.type === "disjunction")
        );

        if (availablePropositions.length === 0) {
          return null; // í•´ì²´í•  í›„ë³´ ëª…ì œê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
        }

        // AIì™€ ìƒëŒ€ë°©ì˜ ìŠ¹ë¦¬ ì¡°ê±´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        let scoredCandidates = [];

        // ëª¨ë“  í›„ë³´ ëª…ì œë¥¼ ìˆœíšŒí•˜ë©° í‰ê°€
        for (const propData of availablePropositions) {
          const originalProp = propData.proposition;
          const { left, right } = originalProp;

          // --- 1. ì•Œì•„ì„œ ë¶„í•´ë˜ëŠ” ëª…ì œ ê±°ë¥´ê¸° (ì „ê±´ ê¸ì •) ---
          if (originalProp.type === "conditional") {
            // (ì°¸ì¸ ëª…ì œ) -> A í˜•íƒœì¸ì§€ ê²€ì‚¬
            if (aiFindProof(originalProp.left, internalTruthSet)) {
              continue; // ì´ë¯¸ ì°¸ì¸ ì¡°ê±´ì´ë¯€ë¡œ, ì¼ë°˜ ì¶”ë¡ ìœ¼ë¡œë„ ë¶„í•´ ê°€ëŠ¥. ëŠ¥ë ¥ ë‚­ë¹„ ë°©ì§€.
            }
          }

          // --- 2. ì•ˆì „ì„± ê²€ì‚¬: í•´ì²´ ì‹œ ìƒëŒ€ ì´ë“/ëª¨ìˆœ ë°œìƒ ì—¬ë¶€ í™•ì¸ ---
          // ì›ë³¸ ëª…ì œë¥¼ ì œì™¸í•œ ì§„ë¦¬ ì§‘í•©ì„ ì‹œë®¬ë ˆì´ì…˜ìš©ìœ¼ë¡œ ìƒì„±
          const propositionsWithoutOriginal = truePropositions.filter(
            (p) => p.propId !== propData.propId
          );
          let tempTruthSet = parsedAxioms.map((a) => a.proposition);
          propositionsWithoutOriginal.forEach((p) => {
            if (p.proposition) tempTruthSet.push(p.proposition);
          });

          const baseVerification = verifyAndExpandTruths(null, tempTruthSet);
          if (!baseVerification.success) continue; // ê¸°ë°˜ ì§‘í•©ë¶€í„° ëª¨ìˆœì´ë©´ ìŠ¤í‚µ
          let truthSetAfterDeconstruction = baseVerification.expandedSet;

          // í•´ì²´ëœ ì²« ë²ˆì§¸ ë¶€ë¶„(left)ì„ ì¶”ê°€í–ˆì„ ë•Œ ëª¨ìˆœ ê²€ì‚¬
          const verification1 = verifyAndExpandTruths(
            left,
            truthSetAfterDeconstruction
          );
          if (!verification1.success) continue;

          // ì´ì–´ì„œ ë‘ ë²ˆì§¸ ë¶€ë¶„(right)ì„ ì¶”ê°€í–ˆì„ ë•Œ ëª¨ìˆœ ê²€ì‚¬
          const verification2 = verifyAndExpandTruths(
            right,
            verification1.expandedSet
          );
          if (!verification2.success) continue;

          // ìµœì¢…ì ìœ¼ë¡œ í™•ì¥ëœ ì§„ë¦¬ ì§‘í•©
          const finalTruthSet = verification2.expandedSet;

          // ìƒëŒ€ê°€ ìŠ¹ë¦¬í•˜ê²Œ ë˜ëŠ”ì§€ ê²€ì‚¬ (ì¹˜ëª…ì  íŒ¨ë„í‹°)
          if (aiFindProof(opponentVictoryData.ultimate_target, finalTruthSet)) {
            continue; // ìƒëŒ€ ìŠ¹ë¦¬ë¥¼ ìœ ë°œí•˜ëŠ” í•´ì²´ëŠ” ì ˆëŒ€ ê¸ˆì§€
          }

          // --- 3. ê¸°íšŒ ê²€ì‚¬: ìì‹ ì—ê²Œ ìœ ë¦¬í•œ ëª…ì œê°€ ë‚˜ì˜¤ëŠ”ì§€ ì ìˆ˜í™” ---
          let currentScore = 0;
          const myUltimateGoal = myVictoryData.ultimate_target;
          const myWinPredicate = myVictoryData.core_goal.predicate;

          // 3-1. í•„ìŠ¹ ê²€ì‚¬
          if (aiFindProof(myUltimateGoal, finalTruthSet)) {
            currentScore += 100000; // í•´ì²´ ì¦‰ì‹œ ìŠ¹ë¦¬í•˜ë©´ ì••ë„ì ì¸ ì ìˆ˜
          } else {
            // 3-2. ìœ ë¦¬í•œ ëª…ì œ(ì „ì¹­/ì¡´ì¬)ê°€ ë‚˜ì˜¤ëŠ”ì§€ ê²€ì‚¬
            const scoreComponent = (component) => {
              let score = 0;
              // ìœ ë¦¬í•œ ì „ì¹­ ì–‘í™”ë¬¸
              if (
                component.type === "universal" &&
                component.predicate === myWinPredicate
              ) {
                score += 5000;
              }
              // ìœ ë¦¬í•œ ì¡´ì¬ ì–‘í™”ë¬¸
              else if (
                component.type === "existential" &&
                component.predicate === myWinPredicate
              ) {
                score += 2000;
              }
              return score;
            };
            currentScore += scoreComponent(left);
            currentScore += scoreComponent(right);
          }

          if (currentScore > 0) {
            scoredCandidates.push({
              propData,
              score: currentScore,
              finalTruthSet,
            });
          }
        }

        if (scoredCandidates.length === 0) return null;

        // --- 4. ìµœì¢… ì„ íƒ: ì ìˆ˜ê°€ ê°€ì¥ ë†’ê³ , ìµœì†Œ ê¸°ì¤€ì„ ë„˜ëŠ” ëª…ì œ í•´ì²´ ---
        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = scoredCandidates[0];

        // ìµœì†Œ ì ìˆ˜ ê¸°ì¤€: ìœ ë¦¬í•œ ì¡´ì¬ ì–‘í™”ë¬¸ ë³´ë„ˆìŠ¤(2000)ë³´ë‹¤ ë†’ì•„ì•¼ í•¨
        const MINIMUM_SCORE_THRESHOLD = 2001;
        if (bestCandidate.score < MINIMUM_SCORE_THRESHOLD) {
          return null; // ìµœì†Œ ê¸°ì¤€ ë¯¸ë‹¬ ì‹œ ëŠ¥ë ¥ ì‚¬ìš© ì•ˆ í•¨
        }

        // --- ëŠ¥ë ¥ ì‹¤í–‰ ---
        console.log(
          `%c[AI Derrida] Target Acquired: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Score: ${bestCandidate.score})`,
          "color: #9b59b6; font-weight: bold;"
        );

        abilityUsedState[player].used = true;

        // ì›ë³¸ ëª…ì œ ì‚­ì œ
        truePropositions = truePropositions.filter(
          (p) => p.propId !== bestCandidate.propData.propId
        );

        // í•´ì²´ëœ ë‘ ëª…ì œ ì¶”ê°€
        const { left, right } = bestCandidate.propData.proposition;
        const newProps = [
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: left,
          },
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: right,
          },
        ];
        truePropositions.push(...newProps);

        // ìµœì¢… ì§„ë¦¬ ì§‘í•©ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        internalTruthSet = bestCandidate.finalTruthSet;

        // ìš”ì•½ ì •ë³´ ë°˜í™˜
        return {
          type: "ability",
          description: currentLang.ui.derridaAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.propData.proposition)
          ),
        };
      }
      /**
       * AIê°€ ì¹¸íŠ¸ì˜ 'ì„ í—˜ì  ì¢…í•©íŒë‹¨' ëŠ¥ë ¥ì„ ìš”ì²­ëœ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ê²°ì •í•˜ê³  ì‹¤í–‰í•˜ëŠ” í•¨ìˆ˜
       * @param {string} player - ëŠ¥ë ¥ì„ ì‚¬ìš©í•˜ë ¤ëŠ” AI í”Œë ˆì´ì–´ ('A' ë˜ëŠ” 'B')
       * @returns {object|null} AI í–‰ë™ ìš”ì•½ ê°ì²´ ë˜ëŠ” null (ëŠ¥ë ¥ì„ ì‚¬ìš©í•˜ì§€ ì•Šì„ ê²½ìš°)
       */
      function executeKantAbilityCheck(player) {
        // --- 1ë‹¨ê³„: ê¸°ë³¸ ì¡°ê±´ ê²€ì‚¬ ë° í›„ë³´ ìƒì„± ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        if (hand.length === 0) return null;

        const candidatePropositions = [];
        function generatePropositionsFromHand(
          currentProposition,
          remainingHand
        ) {
          const parsed = parsePropositionFromCards(
            currentProposition.map((c) => ({ card: c }))
          );
          if (parsed) {
            if (
              !candidatePropositions.some((p) =>
                arePropositionsEqual(p, parsed)
              )
            ) {
              candidatePropositions.push(parsed);
            }
          }
          if (remainingHand.length === 0) return;
          for (let i = 0; i < remainingHand.length; i++) {
            const nextCard = remainingHand[i];
            const connectiveKeywords = [
              currentLang.keywords.if,
              currentLang.keywords.and,
              currentLang.keywords.or,
            ];
            if (connectiveKeywords.includes(nextCard.text)) {
              continue;
            }
            const tempPropositionForValidation = currentProposition.map(
              (c) => ({ card: c })
            );
            if (isValidPlay(nextCard, tempPropositionForValidation)) {
              const nextProposition = [...currentProposition, nextCard];
              const nextRemainingHand = remainingHand.filter(
                (_, index) => index !== i
              );
              generatePropositionsFromHand(nextProposition, nextRemainingHand);
            }
          }
        }
        generatePropositionsFromHand([], hand);

        if (candidatePropositions.length === 0) return null;

        // --- 2ë‹¨ê³„: ìš°ì„ ìˆœìœ„ì— ë”°ë¥¸ í›„ë³´ í‰ê°€ ---
        const evaluatedCandidates = [];
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        const myWinPredicate = myVictoryData.core_goal.predicate;
        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const opponentAntiWinPredicate =
          getOppositePredicate(opponentWinPredicate);

        for (const candidate of candidatePropositions) {
          const verificationResult = verifyAndExpandTruths(
            candidate,
            internalTruthSet
          );
          if (!verificationResult.success) continue;

          const finalTruthSet = verificationResult.expandedSet;
          const myLossCondition = {
            type: "negation",
            proposition: myVictoryData.ultimate_target,
          };

          if (
            aiFindProof(opponentVictoryData.ultimate_target, finalTruthSet) ||
            aiFindProof(myLossCondition, finalTruthSet)
          ) {
            continue;
          }

          if (aiFindProof(myVictoryData.ultimate_target, finalTruthSet)) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 1,
              finalTruthSet,
            });
            continue;
          }
          if (
            candidate.type === "universal" &&
            candidate.predicate === myWinPredicate
          ) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 2,
              finalTruthSet,
            });
            continue;
          }
          if (
            opponentAntiWinPredicate &&
            candidate.type === "universal" &&
            candidate.predicate === opponentAntiWinPredicate
          ) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 3,
              finalTruthSet,
            });
            continue;
          }
          if (
            opponentAntiWinPredicate &&
            candidate.type === "existential" &&
            candidate.predicate === opponentAntiWinPredicate
          ) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 4,
              finalTruthSet,
            });
            continue;
          }
        }

        // --- 3ë‹¨ê³„: ìµœì  í›„ë³´ ì„ ì • ë° ëŠ¥ë ¥ ì‹¤í–‰ ---
        if (evaluatedCandidates.length === 0) return null;

        const bestPriority = Math.min(
          ...evaluatedCandidates.map((c) => c.priority)
        );
        const bestOptions = evaluatedCandidates.filter(
          (c) => c.priority === bestPriority
        );
        const bestCandidate =
          bestOptions[Math.floor(Math.random() * bestOptions.length)];

        console.log(
          `%c[AI Kant] Priority ${
            bestCandidate.priority
          } Action Selected: ${propositionToNaturalText(
            bestCandidate.proposition
          )}`,
          "color: #1abc9c; font-weight: bold;"
        );

        abilityUsedState[player].used = true;

        const cardsToCreate = propositionToNaturalText(
          bestCandidate.proposition
        ).split(" ");
        let tempHand = [...hand];
        cardsToCreate.forEach((cardText) => {
          const cardIndex = tempHand.findIndex((c) => c.text === cardText);
          if (cardIndex > -1) tempHand.splice(cardIndex, 1);
        });
        if (player === "A") playerA_Hand = tempHand;
        else playerB_Hand = tempHand;

        truePropositions.push({
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem",
          source: "kant_ability",
          proposition: bestCandidate.proposition,
        });

        internalTruthSet = bestCandidate.finalTruthSet;

        return {
          type: "ability",
          description: currentLang.ui.kantAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.proposition)
          ),
        };
      }

      // í—¬í¼ í•¨ìˆ˜ (ë‹¤ë¥¸ AI ë¡œì§ì—ì„œë„ í•„ìš”í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì „ì—­ì— ì •ì˜)
      function getOppositePredicate(predicate) {
        const predicatePairs = currentLang.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === predicate) return predicatePairs[key];
          if (predicatePairs[key] === predicate) return key;
        }
        return null;
      }
      function saveSettings() {
        const settings = {
          bgmVolume: bgmVolume,
          sfxVolume: sfxVolume,
        };
        localStorage.setItem("logos_settings", JSON.stringify(settings));
      }

      function loadSettings() {
        const savedSettings = localStorage.getItem("logos_settings");
        if (savedSettings) {
          const settings = JSON.parse(savedSettings);
          bgmVolume =
            settings.bgmVolume !== undefined ? settings.bgmVolume : 0.4;
          sfxVolume =
            settings.sfxVolume !== undefined ? settings.sfxVolume : 0.6;
        }

        // ë¡œë“œëœ ê°’ìœ¼ë¡œ ì˜¤ë””ì˜¤ ë° UI ì—…ë°ì´íŠ¸
        audioManager.setVolume(bgmVolume);
        audioManager.setSfxVolume(sfxVolume);

        const bgmSlider = document.getElementById("bgm-volume-slider");
        const bgmValueSpan = document.getElementById("bgm-volume-value");
        const sfxSlider = document.getElementById("sfx-volume-slider");
        const sfxValueSpan = document.getElementById("sfx-volume-value");

        if (bgmSlider) {
          bgmSlider.value = bgmVolume;
          bgmValueSpan.textContent = `${Math.round(bgmVolume * 100)}%`;
        }
        if (sfxSlider) {
          sfxSlider.value = sfxVolume;
          sfxValueSpan.textContent = `${Math.round(sfxVolume * 100)}%`;
        }
      }
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const closeSettingsBtn = document.getElementById(
        "close-settings-modal-btn"
      );

      if (settingsBtn) {
        settingsBtn.addEventListener("click", () => {
          if (settingsModal) settingsModal.classList.add("visible");
        });
      }
      if (closeSettingsBtn) {
        closeSettingsBtn.addEventListener("click", () => {
          if (settingsModal) settingsModal.classList.remove("visible");
        });
      }

      const creditsBtn = document.getElementById("credits-btn");
      const creditsModal = document.getElementById("credits-modal");
      const closeCreditsBtn = document.getElementById(
        "close-credits-modal-btn"
      );

      if (creditsBtn) {
        creditsBtn.addEventListener("click", () => {
          if (creditsModal) creditsModal.classList.add("visible");
        });
      }
      if (closeCreditsBtn) {
        closeCreditsBtn.addEventListener("click", () => {
          if (creditsModal) creditsModal.classList.remove("visible");
        });
      }

      // --- ë³¼ë¥¨ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
      const bgmSlider = document.getElementById("bgm-volume-slider");
      const bgmValueSpan = document.getElementById("bgm-volume-value");
      const sfxSlider = document.getElementById("sfx-volume-slider");
      const sfxValueSpan = document.getElementById("sfx-volume-value");

      if (bgmSlider) {
        bgmSlider.addEventListener("input", (e) => {
          bgmVolume = parseFloat(e.target.value);
          audioManager.setVolume(bgmVolume);
          bgmValueSpan.textContent = `${Math.round(bgmVolume * 100)}%`;
          saveSettings();
        });
      }

      if (sfxSlider) {
        sfxSlider.addEventListener("input", (e) => {
          sfxVolume = parseFloat(e.target.value);
          audioManager.setSfxVolume(sfxVolume); // ìƒˆë¡œìš´ í•¨ìˆ˜ í˜¸ì¶œ
          sfxValueSpan.textContent = `${Math.round(sfxVolume * 100)}%`;
        });

        sfxSlider.addEventListener("change", () => {
          audioManager.playSfx("hover"); // ìƒˆë¡œìš´ í•¨ìˆ˜ í˜¸ì¶œ
          saveSettings();
        });
      }
      // íŠœí† ë¦¬ì–¼ 'ë‹¤ìŒ' ë²„íŠ¼ Enter í‚¤ ì§€ì›
      window.addEventListener("keydown", (event) => {
        // íŠœí† ë¦¬ì–¼ ëª¨ë“œê°€ ì•„ë‹ˆê±°ë‚˜, ê²Œì„ì˜¤ë²„ ìƒíƒœì´ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
        if (!inTutorialMode || gameIsOver) return;

        const nextBtn = document.getElementById("tutorial-next-btn");

        // Enter í‚¤ë¥¼ ëˆŒë €ê³ , 'ë‹¤ìŒ' ë²„íŠ¼ì´ í™”ë©´ì— ë³´ì¼ ë•Œ (hidden í´ë˜ìŠ¤ê°€ ì—†ì„ ë•Œ) ë™ì‘
        if (event.key === "Enter" && !nextBtn.classList.contains("hidden")) {
          // Enter í‚¤ì˜ ê¸°ë³¸ ë™ì‘(ì˜ˆ: í¼ ì œì¶œ)ì„ ë§‰ì•„ ë‹¤ë¥¸ ê¸°ëŠ¥ê³¼ì˜ ì¶©ëŒì„ ë°©ì§€
          event.preventDefault();

          // 'ë‹¤ìŒ' ë²„íŠ¼ì— í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚´
          nextBtn.click();
        }
      });
    </script>
  </body>
</html>
