<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LOGOS ORGANON</title>

    <style>
      @font-face {
        font-family: "font"; /* CSS에서 사용할 폰트 이름을 지정 */
        src: url("assets/font.ttf") format("truetype"); /* 폰트 파일의 경로와 형식 */
      }
      body {
        font-family: "font", "Malgun Gothic", "Segoe UI", sans-serif;
        background-color: #f4f7f9;
        color: #333;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        font-size: 15px;
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/images/sky.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 2fr 1fr;
        grid-template-rows: auto auto 1fr auto;
        row-gap: 0;
        column-gap: 0px;
        width: 100%;
        max-width: 1400px;
        height: 90vh;
        visibility: hidden; /* Initially hidden until language is selected */
        position: relative;
        z-index: 1;
      }
      .container.ready {
        visibility: visible;
      }
      #player-a-area,
      .game-board {
        margin-right: -1px;
      }
      header {
        grid-column: 1 / -1;
        text-align: center;
        padding: 25px 15px;
        color: black;
        margin: 0 -40px;
        background-image: url("assets/images/roof.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      header h1 {
        color: transparent;
        margin: 0;
        font-size: 42px;
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
      }

      #info-box {
        padding: 15px 55px;
        grid-column: 1 / -1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        margin: 0 -40px;
        background-image: url("assets/images/roo.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .header-buttons-left,
      .header-buttons-right {
        display: flex;
        gap: 10px;
      }
      .header-buttons-left button,
      .header-buttons-right button {
        padding: 4px 8px;
        border: none;

        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 1em;
      }
      #new-game-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/new.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #new-game-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/new_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #fullscreen-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/full.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #fullscreen-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/full_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      #main-menu-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #main-menu-btn:hover {
        border-image-source: url("assets/images/full_hover.png");
      }
      #tutorial-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #tutorial-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #puzzle-mode-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #puzzle-mode-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .mode-selector button {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      .mode-selector button:not(.active):hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      #exit-game-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #exit-game-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      .round-display {
        /* position, left, transform 속성 제거 */
        font-size: 1.7em;
        font-weight: bold;
        color: #9a4b37;
      }
      .player-area {
        background-color: #b15139;
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        transition: opacity 0.3s, box-shadow 0.3s;
        border: 4px solid transparent;
      }
      .player-area.disabled {
        background-color: #b15139;
      }

      .player-area h3 {
        font-weight: normal;
        margin: 0;
      }
      .hand {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        height: 400px; /* 원하는 고정 높이값 (조정 가능) */
        overflow-y: auto; /* 내용이 넘칠 경우 스크롤 생성 */

        padding: 10px 4px;
        box-sizing: border-box; /* padding이 높이 계산에 포함되도록 설정 */
        background-color: rgba(238, 218, 165, 0.65); /* 반투명 흰색 배경 */
      }
      .card {
        padding: 10px 12px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .card.ai-hand {
        cursor: default;
      }
      .card-white {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        background-color: #edebe6;
        border-radius: 14px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/card_white.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
      }
      .card-white:hover:not(.ai-hand) {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/card_white_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
      }
      .card-black {
        color: white;
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        background-color: #453f32;
        border-radius: 14px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/card_black.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        image-rendering: pixelated;
      }
      .card-black:hover:not(.ai-hand) {
        color: white;
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/card_black_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
      }
      .game-board {
        display: flex;
        flex-direction: column;
        gap: 0px;
        min-height: 0;
        position: relative;
      }
      #current-proposition {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 7px;

        /* border-image를 위한 설정 */
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/papiru.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
      }
      #current-proposition {
        min-height: 120px;
        display: flex;
        flex-direction: column;
      }

      #background-box {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 300px; /* 👈 높이를 고정값으로 직접 지정 */
        z-index: -1;
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/images/cloud.png"); /* 👈 여기에 파일 경로를 입력하세요 */
        background-size: 340px 340px; /* 👈 64px에서 128px로 2배 확대 */
        image-rendering: pixelated; /* 👈 이미지를 선명하게 유지하는 핵심 속성 */

        background-repeat: repeat; /* 배경 이미지를 바둑판식으로 반복 */
      }
      #proposition-display {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 50px;
        flex-grow: 1;
        align-items: center;
      }
      #proposition-controls {
        margin-top: 10px;
        display: flex;
        gap: 10px;
      }
      #complete-btn {
        color: white;
        padding: 0;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/complete.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #complete-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/complete_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #undo-btn {
        color: white;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/undo.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #undo-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/undo_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #end-turn-btn {
        color: white;
        margin-left: auto;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/end.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #end-turn-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/end_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }
      #true-propositions {
        /* 카드 내용물을 위한 안쪽 여백 */
        padding: 15px;

        /* border-image를 위한 설정 */
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/papiru_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        image-rendering: pixelated;

        /* --- 수정된 부분 --- */
        flex-grow: 1; /* 남는 공간을 차지하려는 성질 */
        flex-shrink: 1; /* 공간이 부족할 때 줄어들려는 성질 */
        flex-basis: 0; /* 핵심: 내용물 크기를 무시하고 0에서부터 공간을 계산하도록 설정 */
        /* ------------------ */

        overflow-y: auto;
        min-height: 0;
      }

      #true-propositions h3 {
        margin-top: 0;
      }
      #true-propositions ul {
        padding-left: 0;
        list-style-type: none;
        margin: 0;
      }
      #true-propositions li {
        margin-bottom: 8px;
        padding: 8px;
        background-color: #fff;

        border-left: 4px solid #3498db;
      }
      #true-propositions li.victory-condition {
        border-left-color: #f1c40f;
        font-weight: normal;
        background-color: #fef9e7;
      }
      #true-propositions li.axiom-wrapper {
        padding: 0;
        border-left: none;
      }
      #true-propositions li.theorem {
        border-left-color: #8e44ad;
        font-style: italic;
        background-color: #f5eef8;
      }
      #true-propositions li.plato-theorem {
        border-left: 4px solid #8e44ad;
        font-style: italic;
        background-color: #fff;
      }
      #true-propositions li.nietzsche-theorem {
        border-left: 4px solid #8e44ad; /* 플라톤과 동일한 색상 */
        font-style: italic; /* 이탤릭체 */
        background-color: #fff;
      }
      #true-propositions li.socrates-disabled {
        background-color: #e0e0e0; /* 회색 배경 */
        color: #888;
        border-left-color: #95a5a6;
        font-style: italic;
      }
      #true-propositions li.wittgenstein-theorem {
        border-left: 4px solid #8e44ad; /* 플라톤과 동일한 색상 */
        font-style: italic; /* 이탤릭체 */
        background-color: #fff;
      }
      #true-propositions li.derrida-theorem {
        border-left: 4px solid #8e44ad; /* 플라톤과 동일한 색상 */
        font-style: italic; /* 이탤릭체 */
        background-color: #fff;
      }
      #true-propositions li.hume-theorem {
        border-left: 4px solid #8e44ad; /* 플라톤과 동일한 색상 */
        font-style: italic; /* 이탤릭체 */
        background-color: #fff;
      }
      #true-propositions li.kuhn-theorem {
        border-left: 4px solid #8e44ad; /* 플라톤과 동일한 색상 */
        font-style: italic; /* 이탤릭체 */
        background-color: #fff;
      }
      #true-propositions li.kant-theorem {
        border-left: 4px solid #8e44ad;
        font-style: italic;
        background-color: #fff;
      }
      #true-propositions li.victory-condition.marx-victory-condition {
        background-color: #fdf2f2; /* 옅은 붉은색 배경 */
        border-left-color: #c0392b; /* 더 진한 붉은색 테두리 */
      }
      .word-a {
        color: #7f8c8d;
      }
      .word-b {
        color: #2c3e50;
      }
      details {
        background-color: #fff;

        margin-bottom: 8px;
      }
      summary {
        padding: 5px;
        cursor: pointer;
        font-weight: normal;
      }
      .axiom-list {
        padding: 5px 15px 15px 35px;
        background-color: #fafafa;
        border-top: 1px solid #eee;
      }
      .axiom-list p {
        margin: 4px 0;
        font-size: 14px;
      }
      .status-bar {
        height: 46px; /* 고정 높이 부여 (값은 적절히 조절) */
        display: flex; /* 내부 요소를 flexbox로 정렬 */
        align-items: center; /* 세로 중앙 정렬 */
        justify-content: center; /* 가로 중앙 정렬 */
        grid-column: 1 / -1;
        text-align: center;
        padding: 15px;
        font-weight: normal;
        font-size: 1.2em;
        background-color: transparent;
        margin: 0 -40px;
        min-height: 40px; /* Give it some default height */
        background-image: url("assets/images/bottom.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      /* 이 코드를 style 태그 안에 추가하세요 */
      .player-title-box {
        padding: 10px; /* 내부 여백 */
        text-align: center; /* 텍스트 가운데 정렬 */
        background-image: url("assets/images/player.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: contain; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .player-title-box.active-turn {
        background-image: url("assets/images/player_active.png"); /* 턴이 활성화됐을 때의 이미지 */
      }
      .eureka-btn {
        margin-top: auto;
        padding: 10px 15px;
        border: none;
        font-size: 1.7em;
        cursor: pointer;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/eureka.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .eureka-btn:hover:not(:disabled) {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/eureka_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .eureka-btn:disabled {
        cursor: not-allowed;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/eureka_disabled.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .ability-btn {
        margin-top: 10px; /* 유레카 버튼과의 간격 */
        padding: 10px 15px;
        border: none;
        font-size: 1.1em;
        cursor: pointer;
        transition: background-color 0.2s;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        /* 고유 능력 버튼용 이미지를 준비하세요 (예: ability.png) */
        border-image-source: url("assets/images/eureka.png"); /* 임시로 유레카 이미지 사용 */
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }

      .ability-btn:hover:not(:disabled) {
        border-image-source: url("assets/images/eureka_1.png"); /* 임시로 유레카 호버 이미지 사용 */
      }

      .ability-btn:disabled {
        cursor: not-allowed;
        border-image-source: url("assets/images/eureka_disabled.png"); /* 임시로 유레카 비활성 이미지 사용 */
      }
      #proposition-controls button:disabled {
        color: #464646;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/disabled.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        cursor: not-allowed;
      }
      .modal {
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .modal.visible {
        display: flex;
      }
      .modal-content {
        padding: 25px;
        box-sizing: border-box;
        border-width: 30px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/por.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        position: relative;

        width: 80%;
        max-width: 800px;
        position: relative;
      }
      .modal-content-small {
        box-sizing: border-box;
        border-width: 15px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/por_small.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        position: relative;

        padding: 30px;
        text-align: center;
        max-width: 500px;
        width: 90%;
      }
      .close-button {
        position: absolute;
        padding: 15px;
        top: 17px;
        right: 50px;
        cursor: pointer;
        background-image: url("assets/images/close.png"); /* 👈 아이콘은 background-image로 설정해야 합니다. */
        background-repeat: no-repeat; /* 👈 아이콘이 반복되지 않도록 설정 */
        background-size: contain; /* 👈 버튼 크기에 맞춰 아이콘 크기 조절 */
        background-position: center; /* 👈 아이콘을 중앙에 배치 */
        image-rendering: pixelated;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        border: none; /* 테두리 제거 */
        z-index: 10;
      }
      .close-button:hover {
        background-image: url("assets/images/close_hover.png"); /* 👈 아이콘은 background-image로 설정해야 합니다. */
        background-repeat: no-repeat; /* 👈 아이콘이 반복되지 않도록 설정 */
        background-size: contain; /* 👈 버튼 크기에 맞춰 아이콘 크기 조절 */
        background-position: center; /* 👈 아이콘을 중앙에 배치 */
        image-rendering: pixelated;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        border: none; /* 테두리 제거 */
        color: black;
      }
      .proof-container {
        background-color: #f5db97;
        display: flex;
        gap: 20px;
        padding-top: 44px;
      }
      .premise-selection {
        flex: 1;
        background-color: #f5db97;
        padding: 0px 15px;

        height: 52vh;
        overflow-y: auto;
      }
      .premise-selection ul {
        list-style-type: none;
        padding: 0;
      }
      .premise-selection li {
        margin-bottom: 5.5px;
        padding: 8px;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/pre_li.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        width: 80%;
        max-width: 800px;
        position: relative;

        cursor: pointer;
      }

      .premise-selection li.assumption-dependent {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/pre_li_assu.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        font-style: italic;
      }
      .premise-selection li.assumption-itself {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/pre_li_assu.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        font-style: italic;
      }
      .premise-selection li:hover {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/pre_li_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .premise-selection li.assumption-dependent:hover {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/pre_li_assu_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        font-style: italic;
      }
      .premise-selection li.assumption-itself:hover {
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/pre_li_assu_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        font-style: italic;
      }
      .premise-selection li span[class^="tag-"] {
        font-weight: bold;
        margin-right: 4px;
      }

      .premise-selection li.selected {
        border-image-source: url("assets/images/pre_li_selected.png");
      }

      /* 가정 의존 항목이 선택됐을 때의 스타일 */
      .premise-selection li.assumption-dependent.selected,
      .premise-selection li.assumption-itself.selected {
        border-image-source: url("assets/images/pre_li_assu_selected.png");
      }

      .tag-victory {
        color: #c9a518;
      }
      .tag-theorem,
      .tag-assumption {
        color: #8e44ad;
      }
      .tag-assumption {
        color: #8f2c21; /* 진한 빨간색으로 변경 */
      }
      .tag-proposition {
        color: #3498db;
      }
      .tag-axiom {
        color: #7f8c8d;
      }
      #modal-confirm-btn {
        color: white;
        margin-top: 20px;
        padding: 12px 25px;
        font-size: 1.2em;
        border-width: 7px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/modal_confirm.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #modal-confirm-btn:hover {
        border-width: 7px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/modal_confirm_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #workbench-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }
      #apply-rule-btn {
        color: black;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/full.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #apply-rule-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/full_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #add-assumption-btn {
        color: black;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      #add-assumption-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #add-assumption-btn:disabled {
        display: none;
        cursor: not-allowed;
      }
      #cancel-assumption-btn {
        color: black;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/undo.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #cancel-assumption-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/undo_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #thinking-time-controls {
        /* 레이아웃 및 위치 설정 */
        position: absolute; /* 겹치도록 설정 */
        inset: 0; /* 👈 부모 요소를 꽉 채우는 가장 간단한 방법 (top:0; left:0; right:0; bottom:0;) */
        /* width, height, margin 속성은 제거해도 됩니다. */
        z-index: 2; /* 다른 요소들 위에 표시 */

        /* 내용을 중앙에 배치하기 위한 Flexbox 설정 (이 부분은 그대로 둡니다.) */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;

        /* 기존 배경 이미지 스타일 유지 */
        padding: 15px;
        border-width: 20px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/papiru_1.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        text-align: center;
      }
      /* JavaScript에서 사용할 .hidden 클래스 규칙 추가 */
      #thinking-time-controls.hidden {
        display: none;
      }

      #prompt-input {
        width: 100%;
        padding: 8px;
        margin-top: 15px;
        margin-bottom: 15px;
      }
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }
      .modal-buttons button {
        padding: 8px 16px;

        border: none;
        cursor: pointer;
        font-weight: normal;
      }

      #alert-ok-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #alert-ok-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-confirm-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-confirm-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-cancel-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #prompt-cancel-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      #close-eureka-modal-btn {
        right: 20px;
      }
      #tutorial-modal .modal-content {
        max-width: 800px;
        height: 70vh;
        overflow-y: auto;
      }
      #tutorial-modal h3 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
        margin-top: 20px;
      }
      #tutorial-modal ul {
        list-style-position: inside;
        padding-left: 10px;
      }
      #tutorial-modal li {
        margin-bottom: 10px;
        line-height: 1.6;
      }
      #tutorial-modal code {
        background-color: #e9ecef;
        padding: 2px 6px;
      }
      /* Modal Styles */
      #language-modal .modal-content-small,
      #character-select-modal .modal-content-small {
        border-width: 20px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/por_small.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .selection-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 25px;
      }
      .selection-buttons button {
        padding: 15px 30px;
        font-size: 1.2em;
        font-weight: normal;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */

        cursor: pointer;
      }
      .selection-buttons button:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      /* Tutorial Styles */
      .tutorial-highlight {
        box-shadow: 0 0 0 4px #639bff, 0 0 20px #6da2ff; /* 👈 파란색으로 변경 */

        transition: box-shadow 0.3s ease-in-out;
        position: relative;
        z-index: 101; /* Ensure it's above other elements */
      }
      #tutorial-guide,
      #puzzle-goal-box {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(44, 62, 80, 0.9);
        color: white;
        padding: 20px;
        width: 80%;
        max-width: 800px;
        text-align: left; /* 텍스트는 좌측 정렬 유지 */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        z-index: 200;
        display: flex;
        flex-direction: column;
        align-items: flex-start; /* 기본 정렬은 좌측으로 유지 */
        gap: 15px;
        transition: top 0.3s ease-in-out, bottom 0.3s ease-in-out;
      }

      #tutorial-guide button {
        align-self: center; /* 버튼 자기 자신만 중앙으로 정렬 */
      }
      #tutorial-guide.top,
      #puzzle-goal-box {
        top: 20px;
        bottom: auto;
      }
      #tutorial-guide p,
      #puzzle-goal-box p {
        margin: 0;
        font-size: 1.1em;
        line-height: 1.6;
      }
      #puzzle-goal-box p {
        z-index: 9999;
      }
      #tutorial-guide button {
        padding: 10px 25px;
        font-size: 1em;
        font-weight: normal;
        border: none;

        cursor: pointer;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        transform: translateY(-3px);
        color: #2c3e50;

        display: flex;
        align-items: center;
      }
      #tutorial-guide button:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      .hidden {
        display: none !important;
      }

      #tutorial-guide button::after {
        content: "";
        display: inline-block;
        width: 32px; /* 아이콘 너비 */
        height: 20px; /* 아이콘 높이 */
        margin-left: 3px; /* 텍스트와의 간격 */
        background-image: url("assets/images/next_icon.png"); /* 👈 사용할 아이콘 이미지 경로 */
        background-size: contain;
        background-repeat: no-repeat;
      }

      .turn-indicator {
        display: inline-block;
        padding: 8px 20px; /* 내부 여백 *
              transition: all 0.3s ease; /* 부드러운 전환 효과 */
        text-align: center; /* 텍스트 가운데 정렬 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/indi.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }

      button,
      select {
        font-family: inherit;
      }
      #info-box > div {
        position: relative; /* 위치를 상대적으로 조정하도록 설정 */
        top: 6px; /* 👈 원래 위치에서 5px 아래로 이동 */
      }
      .header-buttons-left,
      .header-buttons-right {
        flex: 1; /* 양쪽 컨테이너가 동일한 너비를 갖도록 설정 */
      }

      /* 오른쪽 버튼들을 오른쪽 끝으로 정렬 */
      .header-buttons-right {
        justify-content: flex-end;
      }
      /* 승리 조건 텍스트의 strong 태그 볼드체 제거 */
      #true-propositions li.victory-condition strong {
        font-weight: normal;
      }
      /* 기존 코드 */
      #proposition-controls button {
        padding: 8px 15px;
        cursor: pointer;
        font-size: 14px;
        font-weight: normal;
        transition: background-color 0.2s;
        /* 👇 아래 속성 추가 */
        min-width: 100px; /* 원하는 최소 너비로 조절 (예: 100px) */
        box-sizing: border-box; /* padding을 너비에 포함시켜 계산 */
      }
      /* 튜토리얼 대화창을 강제로 최상단에 표시하기 위한 규칙 */
      #tutorial-guide {
        z-index: 9999 !important;
      }
      /* 새로 추가: 턴이 아닐 때 카드에 직접 흐림 및 반투명 효과 적용 */
      /* 턴이 아닐 때 카드의 밝기와 대비를 조절 */
      .player-area.disabled .card {
        filter: brightness(0.8) contrast(0.8);
      }
      .card.unplayable {
        filter: brightness(0.8) contrast(0.8);
        cursor: not-allowed;
      }
      #workbench-controls select,
      #workbench-controls button {
        font-size: 14px; /* 글자 크기를 14px에서 16px로 키웁니다 */
        padding: 10px 20px; /* 버튼의 상하, 좌우 여백을 늘립니다 */
      }

      /* 덧씌울 이미지들을 담는 컨테이너 */
      #overlay-container {
        position: absolute; /* 부모 위에 겹치도록 설정 */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* 덧씌울 개별 이미지 */
      .overlay-image {
        position: absolute; /* 컨테이너 위에 겹치도록 설정 */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      /* 이미지를 숨기는 핵심 클래스 */
      .hidden {
        display: none !important; /* ★★★★★ 가장 중요! */
      }
      #socrates-wise-overlay,
      #socrates-foolish-overlay,
      #socrates-good-overlay,
      #socrates-evil-overlay,
      #plato-wise-overlay,
      #plato-foolish-overlay,
      #plato-good-overlay,
      #plato-evil-overlay,
      #socrates-bird-overlay,
      #socrates-fish-overlay,
      #plato-bird-overlay,
      #plato-fish-overlay,
      #socrates-win-overlay,
      #plato-win-overlay {
        z-index: 1;
      }
      #socrates-dog-overlay,
      #plato-dog-overlay {
        z-index: 2;
      }

      #player-a-area {
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/images/paper_1.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }

      #player-b-area {
        /* 1. 이미지 파일 불러오기 */
        background-image: url("assets/images/paper.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      /* style 태그 안, 가장 아래쪽에 추가 */
      body::after {
        position: absolute;
        width: 0;
        height: 0;
        overflow: hidden;
        z-index: -1; /* 화면에 보이지 않게 처리 */
        content:
      /* 기본 UI 및 배경 이미지 */ url("assets/images/sky.png")
          url("assets/images/title.png") url("assets/images/roof.png")
          url("assets/images/roo.png") url("assets/images/roo_2.png")
          url("assets/images/bottom.png") url("assets/images/paper.png")
          url("assets/images/paper_1.png") url("assets/images/player.png")
          url("assets/images/player_active.png") url("assets/images/papiru.png")
          url("assets/images/rendom_hover.png")
          url("assets/images/papiru_1.png") url("assets/images/sel.png")
          url("assets/images/por.png") url("assets/images/por_small.png")
          url("assets/images/pre_li.png") url("assets/images/pre_li_assu.png")
          url("assets/images/pre_li_assu_selected.png")
          url("assets/images/pre_li_selected.png") url("assets/images/indi.png")
          url("assets/images/close.png") /* 버튼 기본 이미지 */
          url("assets/images/new.png") url("assets/images/full.png")
          url("assets/images/tuto.png") url("assets/images/complete.png")
          url("assets/images/undo.png") url("assets/images/end.png")
          url("assets/images/eureka.png") url("assets/images/disabled.png")
          url("assets/images/eureka_disabled.png") /* 버튼 호버(Hover) 이미지 */
          url("assets/images/new_hover.png") url("assets/images/full_hover.png")
          url("assets/images/tuto_hover.png")
          url("assets/images/level_hover.png") url("assets/images/level.png")
          url("assets/images/level_cleared_hover.png")
          url("assets/images/level_cleared.png")
          url("assets/images/complete_hover.png")
          url("assets/images/undo_hover.png") url("assets/images/end_hover.png")
          url("assets/images/eureka_1.png") url("assets/images/close_hover.png")
          url("assets/images/pre_li_hover.png")
          url("assets/images/pre_li_assu_hover.png") /* 카드 이미지 */
          url("assets/images/card_white.png")
          url("assets/images/card_black.png")
          url("assets/images/card_white_hover.png")
          url("assets/images/card_black_hover.png")
          /* 철학자 초상화 및 아이콘 (JavaScript에 정의된 경로 포함) */
          url("assets/images/ari_p1.png") url("assets/images/ari_p2.png")
          url("assets/images/ari_icon.png") url("assets/images/socrat_p1.png")
          url("assets/images/socrat_p2.png") url("assets/images/socra_icon.png")
          url("assets/images/pl_p1.png") url("assets/images/pl_p2.png")
          url("assets/images/pl_icon.png") url("assets/images/de_p1.png")
          url("assets/images/de_p2.png") url("assets/images/de_icon.png")
          url("assets/images/hu_p1.png") url("assets/images/hu_p2.png")
          url("assets/images/hu_icon.png") url("assets/images/ka_p1.png")
          url("assets/images/ka_p2.png") url("assets/images/ka_icon.png")
          url("assets/images/ni_p1.png") url("assets/images/ni_p2.png")
          url("assets/images/ni_icon.png") url("assets/images/ma_p1.png")
          url("assets/images/ma_p2.png") url("assets/images/ma_icon.png")
          url("assets/images/wi_p1.png") url("assets/images/wi_p2.png")
          url("assets/images/wi_icon.png") url("assets/images/ku_p1.png")
          url("assets/images/ku_p2.png") url("assets/images/ku_icon.png")
          url("assets/images/der_p1.png") url("assets/images/der_p2.png")
          url("assets/images/der_icon.png");
      }

      /* ...existing code... */
      .main-center-bg {
        position: absolute;
        inset: 0; /* top:0; right:0; bottom:0; left:0; */
        width: 95%;
        height: 95%;
        background: transparent;
        z-index: 1; /* 배경 역할 */
        pointer-events: auto;
        border-width: 17px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/papiru_1.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column; /* 세로로 배치 */
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .main-center-buttons {
        display: flex;
        flex-direction: column;
        gap: 24px;
        align-items: center;
        z-index: 2;
        position: relative;
      }

      .mode-selector {
        display: flex;
        flex-direction: column; /* 버튼을 세로로 배치 */
        gap: 30px; /* 버튼 사이 넉넉하게 */
        width: 100%;
      }

      .mode-selector button,
      #exit-game-btn,
      #tutorial-btn,
      #puzzle-mode-btn {
        min-width: 0;
        width: 100%;
        max-width: 1000px;
        padding: 8px 50px; /* 위아래 좁게, 좌우 넓게 */
        font-size: 1.5em;
        box-sizing: border-box;
      }

      .main-center-bg.hidden {
        display: none !important;
      }

      /* Add these CSS rules inside the <style> tag */

      #character-selection-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 40px;
        box-sizing: border-box;
      }

      #character-selection-screen.hidden {
        display: none !important;
      }

      .player-display-area {
        width: 28%;
        height: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 22px;
        box-sizing: border-box;
        border-width: 25px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/por.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        position: relative;
      }

      .portrait-area {
        width: 100%;
        height: 50%;
        background-color: #b19c6f;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        image-rendering: pixelated;
        border: 6px solid #9a4b37;
      }

      .philosopher-name {
        font-size: 2.5em;
        color: #9a4b37;
        margin-top: 20px;
        font-weight: bold;
      }

      .skill-area {
        width: 100%;
        margin-top: 20px;
        text-align: left;
      }

      .skill-title {
        font-size: 1.5em;
        color: #333;
        border-bottom: 2px solid #b95941;
        padding-bottom: 5px;
        margin-bottom: 10px;
      }

      #p1-skill-desc,
      #p2-skill-desc {
        font-size: 1.1em;
        line-height: 1.6;
      }

      .ready-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: transparent;
        color: transparent;
        font-size: 8em;
        display: none; /* Initially hidden */
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }

      .ready-overlay.visible {
        display: flex;
      }

      .shared-selection-area {
        width: 40%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        padding: 22px;
        box-sizing: border-box;
        border-width: 27px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/sel.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }

      .char-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr); /* 4열 그리드, 필요시 조정 */
        gap: 15px;
        width: 100%;
        padding: 20px;
        background-color: transparent;
      }

      .char-icon {
        aspect-ratio: 1 / 1;
        background-size: cover;
        background-position: center;
        border: 4px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
        image-rendering: pixelated;
      }

      .char-icon:hover {
        border-color: #f1cf0f;
        transform: scale(1.05);
      }

      .char-icon.selected {
        border-color: #e74c3c;
        box-shadow: 0 0 15px #e74c3c;
      }

      #confirm-selection-btn {
        padding: 15px 50px;
        font-size: 1.8em;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/complete.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
        cursor: pointer;
        background-color: transparent;
        color: white;
      }

      #confirm-selection-btn:hover:not(:disabled) {
        background-color: transparent;
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/complete_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
      }

      #confirm-selection-btn:disabled {
        color: #7f8c8d; /* 비활성화된 버튼의 글자색 */
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        border-color: transparent;

        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/disabled.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
        image-rendering: pixelated;
        background-color: transparent;
        cursor: not-allowed;
      }

      #turn-order-modal .modal-content-small h2 {
        font-size: 1.8em;
        margin-bottom: 25px;
      }
      #character-select-indicator {
        font-size: 20px;
        position: fixed; /* 화면에 고정 */
        bottom: 30px; /* 하단에서의 거리 (기존 status-bar와 비슷하게) */
        left: 50%; /* 좌우 중앙 정렬을 위한 설정 */
        transform: translateX(-50%); /* 좌우 중앙 정렬을 위한 설정 */
        z-index: 501; /* 캐릭터 선택 화면(z-index: 500)보다 위에 표시 */
      }
      .philosopher-portrait {
        width: 180px;
        height: 180px;
        margin: 8px auto;
        border: 4px solid #e2965c;
        background-color: #eedaa5;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        image-rendering: pixelated;
      }

      #back-to-main-from-char-select-btn {
        top: 25px;
        right: 25px;
        width: 32px;
        height: 32px;
        padding: 0;
        z-index: 502; /* 다른 요소들보다 위에 표시되도록 z-index 설정 */
      }
      #bottom-overlay-box {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 150px;
        background-image: url("assets/images/roo_2.png");
        background-repeat: no-repeat;
        background-size: cover;
        background-position: center;
        image-rendering: pixelated;
        background-color: transparent;
        z-index: 5;
      }

      .true-propositions-wrapper {
        position: relative; /* ★ 오버레이의 새로운 기준점 */
        flex-grow: 1;
        flex-shrink: 1;
        flex-basis: 0;
        min-height: 0;
        display: flex; /* 내부 요소들을 채우기 위함 */
      }
      #game-container,
      .card,
      button,
      .modal-content,
      .player-display-area,
      .shared-selection-area,
      #current-proposition,
      #true-propositions,
      .main-center-bg {
        -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
        backface-visibility: hidden;
        transform: translateZ(0); /* GPU 렌더링 레이어 생성 유도 */
      }
      .button-wrapper {
        display: flex; /* 핵심: 내부 아이템을 가로로 나란히 배치 */
        width: 100%;
        gap: 8px; /* 버튼 사이의 간격 */
        margin-top: auto; /* 플레이어 영역의 맨 아래에 버튼들을 위치시킴 */
      }

      /* 2. 기존 버튼 스타일에 flex 속성 추가 */
      .eureka-btn,
      .ability-btn {
        flex: 1; /* 핵심: 컨테이너 안에서 가능한 공간을 균등하게 차지 */

        /* 글자가 잘리지 않도록 패딩이나 폰트 크기 미세 조정 */
        padding: 8px;
        font-size: 1em;
        min-width: 0; /* 버튼이 작아질 수 있도록 최소 너비 제한 해제 */
      }
      #ability-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      #ability-list li {
        margin-bottom: 5px;
        padding: 8px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/pre_li.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      #ability-list li:hover {
        border-image-source: url("assets/images/pre_li_hover.png");
      }

      #ability-list input[type="radio"] {
        margin-right: 10px;
      }

      /* 범용 능력 모달 확인 버튼 스타일 (누락되었던 부분) */
      #ability-confirm-btn {
        color: white;
        margin-top: 20px;
        padding: 10px 15px;
        font-size: 1.2em;
        border-width: 7px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/modal_confirm.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
        cursor: pointer;
      }

      #ability-confirm-btn:hover {
        border-image-source: url("assets/images/modal_confirm_hover.png");
      }

      /* 모달 제목의 색상이 지정되지 않았을 경우를 대비한 코드 */
      #plato-ability-title {
        color: #333; /* 기본 텍스트 색상 */
        margin-bottom: 20px;
      }

      #kant-ability-modal .modal-content {
        display: flex;
        flex-direction: column;
        height: 80vh;
      }

      /* 1. 테두리와 배경 제거, flex-grow를 통해 상하 공간 분할 */
      #kant-proposition-area,
      #kant-hand-area {
        padding: 10px;
        margin-bottom: 15px;
        display: flex; /* 내부 요소(제목, 카드 컨테이너)를 정렬하기 위해 flex로 설정 */
        flex-direction: column;
        flex: 1; /* 핵심: 두 섹션이 1:1 비율로 공간을 차지 */
        min-height: 0; /* flex 자식 요소가 부모를 넘치지 않도록 설정 */
      }

      #kant-proposition-area h3,
      #kant-hand-area h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #9a4b37;
        border-bottom: 1px solid #d3b88b;
        padding-bottom: 5px;
        flex-shrink: 0; /* 제목의 크기가 줄어들지 않도록 고정 */
      }

      #kant-proposition-display {
        min-height: 80px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }

      #kant-hand-display {
        flex-grow: 1; /* 남은 공간을 모두 차지 */
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
        overflow-y: auto;
      }

      /* 2. 호버 효과 삭제됨 (해당 선택자 제거) */

      #kant-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
        flex-shrink: 0; /* 컨트롤 버튼 영역 크기 고정 */
      }

      #kant-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
      }

      /* 기존 버튼 스타일 재활용 */
      #kant-undo-btn,
      #kant-confirm-btn {
        padding: 8px 25px;
        font-size: 1.1em;
        min-width: 120px;
      }
      #kant-undo-btn {
        color: white;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/undo.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #kant-undo-btn:hover {
        border-image-source: url("assets/images/undo_hover.png");
      }
      #kant-confirm-btn {
        color: white;
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/complete.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #kant-confirm-btn:hover {
        border-image-source: url("assets/images/complete_hover.png");
      }

      #ai-summary-ok-btn {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #ai-summary-ok-btn:hover {
        border-width: 5px; /* 테두리로 사용할 이미지 영역의 두께 */
        border-style: solid;
        /* 9조각으로 나눌 이미지 (배경 패턴 포함) */
        border-image-source: url("assets/images/tuto_hover.png");

        /* 이미지를 10px 기준으로 자르고, 가운데 부분으로 배경을 채움 */
        border-image-slice: 6 fill; /* 👈 fill 키워드 추가가 핵심! */

        /* 너비나 높이가 변해도 깨지지 않도록 설정 */
        border-image-repeat: stretch;
        background-color: transparent; /* 버튼의 배경색을 투명하게 설정 */
      }
      #settings-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        /* 임시로 전체화면 버튼 이미지를 재사용합니다.
             나중에 settings.png, settings_hover.png 같은 전용 이미지로 교체할 수 있습니다. */
        border-image-source: url("assets/images/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #settings-btn:hover {
        border-image-source: url("assets/images/full_hover.png");
      }

      /* 설정 모달 내부 스타일 */
      .settings-group {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        width: 100%;
        max-width: 350px;
        margin-left: auto;
        margin-right: auto;
      }
      .settings-group label {
        font-size: 1.2em;
        margin-right: 15px;
      }
      .settings-group input[type="range"] {
        flex-grow: 1; /* 남는 공간을 모두 차지 */
      }
      .settings-group span {
        font-size: 1.2em;
        margin-left: 15px;
        width: 50px; /* 너비를 고정하여 정렬을 맞춤 */
        text-align: right;
      }
      button:focus,
      select:focus {
        outline: none;
      }
      #credits-btn {
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        /* 임시로 전체화면 버튼 이미지를 재사용합니다.
             나중에 settings.png, settings_hover.png 같은 전용 이미지로 교체할 수 있습니다. */
        border-image-source: url("assets/images/full.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }
      #credits-btn:hover {
        border-image-source: url("assets/images/full_hover.png");
      }
      #vs-ai-test-btn,
      #vs-ai-battle-btn,
      #tutorial-puzzle-btn,
      #exit-game-btn {
        display: none;
      }

      #random-char-btn {
        background-image: url("assets/images/random_hover.png"); /* 이미지 경로 지정 */
        background-size: contain; /* 이미지가 잘리지 않고 비율에 맞게 채워짐 */
        background-repeat: no-repeat; /* 이미지가 반복되지 않도록 설정 */
        background-position: center; /* 이미지를 중앙에 배치 */
        transition: background-image 0.4s; /* 부드러운 전환 효과 (선택 사항) */

        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
      }
      #random-char-btn:hover {
        background-image: url("assets/images/random_hover.png");
        transform: none !important; /* 확대 효과를 제거합니다 */
        transition: none !important;
        border-color: transparent; /* 호버 시 테두리가 나타나지 않도록 설정합니다 */
      }
      .hand,
      #true-propositions,
      .premise-selection,
      #kant-hand-display,
      #credits-content {
        /* 핸들 색상, 트랙 색상 */
        scrollbar-color: #b15139 transparent;
        scrollbar-width: thin;
      }

      /* 2. Chrome, Safari, Edge 등 Webkit 브라우저를 위한 상세 스타일 */
      ::-webkit-scrollbar {
        width: 14px; /* 스크롤바 너비 */
        height: 14px; /* 가로 스크롤바 높이 (필요시) */
      }

      ::-webkit-scrollbar-track {
        background-color: transparent; /* hand 영역 배경과 유사한 반투명 색상 */
      }

      ::-webkit-scrollbar-thumb {
        background-color: #b15139; /* 플레이어 영역 배경색 */
        border: 2px solid #9a4b37; /* 테두리를 주어 입체감 부여 */
      }

      ::-webkit-scrollbar-thumb:hover {
        background-color: #9a4b37; /* 마우스 올리면 더 진한 색으로 */
      }

      /* 스크롤바의 양 끝 화살표 버튼 (사용하지 않으므로 숨김) */
      ::-webkit-scrollbar-button {
        display: none;
      }
      #emergency-exit-tutorial-btn {
        /* 위치 및 z-index는 그대로 유지합니다 */
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;

        /* 텍스트와 테두리 스타일을 추가합니다 */
        padding: 4px 12px;
        font-size: 15px; /* body 기본 폰트 크기와 맞춤 */
        color: #333; /* 기본 텍스트 색상 */
        cursor: pointer;

        /* 인포박스 버튼 스타일 (border-image)을 적용합니다 */
        border-width: 5px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/tuto.png"); /* 튜토리얼 버튼 이미지 재활용 */
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;
      }

      /* 호버 효과도 수정합니다 */
      #emergency-exit-tutorial-btn:hover {
        border-image-source: url("assets/images/tuto_hover.png");
      }
      .op-not {
        color: #e74c3c; /* 빨간색 */
        font-weight: bold;
      }
      .op-if {
        color: #27ae60; /* 초록색 */
        font-weight: bold;
      }
      .op-or {
        color: #2876aa; /* 파란색 */
        font-weight: bold;
      }
      .op-and {
        color: #f39c12; /* 노란색/주황색 계열 */
        font-weight: bold;
      }
      #info-box button[style*="visibility: hidden"] {
        display: none;
      }
      #mode-description {
        position: absolute; /* 버튼 컨테이너를 기준으로 위치 지정 */
        left: 100%; /* 버튼 컨테이너의 오른쪽 끝에 붙임 */
        top: 0; /* 초기 top 위치 (JS가 버튼에 맞춰 변경) */
        transform: translate(
          25px,
          -50%
        ); /* 오른쪽으로 25px 이동하고, 수직 중앙 정렬 */

        width: 280px; /* 설명 박스 너비 */
        padding: 15px;
        font-size: 17px; /* 작은 글씨 크기 */
        color: #333;
        text-align: left;
        line-height: 1.6;

        /* 9조각 이미지로 배경 설정 (기존 UI와 통일감) */
        border-width: 15px;
        border-style: solid;
        border-color: transparent;
        border-image-source: url("assets/images/por_long.png");
        border-image-slice: 6 fill;
        border-image-repeat: stretch;
        background-color: transparent;

        /* 평소에는 보이지 않도록 설정 */
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* 마우스 이벤트에 반응하지 않도록 설정 */
      }

      #puzzle-level-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr); /* 한 줄에 5개의 레벨 */
        gap: 20px; /* 레벨 간 간격 */
        width: 100%;
        padding: 20px;
        margin-top: 20px;
        box-sizing: border-box;
        max-height: 50vh; /* 모달 높이가 너무 커지지 않도록 제한 */
        overflow-y: auto; /* 레벨이 많아지면 스크롤 */
      }

      /* 캐릭터 아이콘 스타일을 재활용하여 레벨 버튼 스타일 지정 */
      .puzzle-level-btn {
        aspect-ratio: 1 / 1;
        background-image: url("assets/images/level.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
        image-rendering: pixelated;

        /* 레벨 번호를 표시하기 위한 Flexbox 설정 */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2em;
        font-weight: bold;
        background-color: transparent;
      }

      .puzzle-level-btn:hover {
        background-image: url("assets/images/level_hover.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      .puzzle-level-btn.cleared {
        aspect-ratio: 1 / 1;
        background-image: url("assets/images/level_cleared.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
        image-rendering: pixelated;

        /* 레벨 번호를 표시하기 위한 Flexbox 설정 */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2em;
        font-weight: bold;
        background-color: transparent;
      }
      .puzzle-level-btn.cleared:hover {
        background-image: url("assets/images/level_cleared_hover.png"); /* 👈 사용할 단일 이미지 경로 */
        background-repeat: no-repeat; /* 👈 이미지 반복 안 함 */
        background-size: cover; /* 👈 박스를 덮도록 크기 조절 (또는 contain) */
        background-position: center; /* 👈 이미지를 중앙에 배치 */
        image-rendering: pixelated;
      }
      #puzzle-level-select-modal .shared-selection-area {
        width: 60%; /* 모달에 적합하도록 너비를 60%로 조정 */
        max-width: 900px; /* 너무 커지지 않도록 최대 너비 설정 */
      }

      /* 닫기 버튼 위치 미세 조정 */
      #puzzle-level-select-modal .close-button {
        top: 35px;
        right: 45px;
      }
      #conclusion-preview {
        margin-top: 5px; /* 15px에서 수정 */
        padding: 12px 15px; /* 상하 여백을 15px에서 8px로 수정 */
        box-sizing: border-box;
      }
      #conclusion-preview-title {
        margin: 0 0 8px 0;
        font-size: 1.2em;
        font-weight: normal;
      }
      #conclusion-preview-text {
        font-size: 1.2em;
        font-weight: normal;
      }
      #conclusion-preview-text i {
        font-style: italic;
        color: #7f8c8d;
      }
      /* 1. 모달 콘텐츠 영역을 자식 요소의 'position: absolute' 기준점으로 설정합니다. */
      #eureka-modal .modal-content {
        position: relative;
      }

      /* 2. 결론 미리보기 섹션을 일반적인 흐름에서 제외하고, 위치를 직접 지정합니다. */
      #conclusion-preview {
        position: absolute;
        top: 135px; /* 제목과 워크벤치 컨트롤의 높이에 맞춰 조정된 값입니다. */
        left: 25px; /* 부모 요소의 좌측 패딩과 동일한 값입니다. */
        width: calc(
          100% - 50px
        ); /* 부모 요소의 좌우 패딩을 제외한 너비입니다. */
        z-index: 10; /* 다른 요소들 위에 표시되도록 설정합니다. */
        background-color: #f5db97; /* 배경색을 추가하여 아래 텍스트가 비치지 않도록 합니다. */
      }
      #main-menu-title-img {
        width: 80%; /* 이미지 너비 */
        max-width: 500px; /* 최대 너비 */
        height: auto; /* 높이는 비율에 맞게 자동 조절 */
        margin-bottom: 40px; /* 버튼과의 아래쪽 간격 */
        image-rendering: pixelated; /* 픽셀 아트 스타일 유지 */
      }

      /* 체크박스 비활성화 시 색상 유지 */
      input[type="checkbox"]:disabled {
        opacity: 1 !important;
        filter: none !important;
        -webkit-filter: none !important;

        /* --- 추가된 부분 --- */
        /* 배경색을 강제로 밝은 색으로 지정 */
        background-color: #f0f0f0 !important;
        /* 테두리 색을 연한 회색으로 지정 */
        border-color: #cccccc !important;
      }
    </style>
  </head>
  <body>
    <button id="emergency-exit-tutorial-btn" class="hidden"></button>
    <audio id="main-menu-music" src="assets/sounds/main_theme.flac"></audio>
    <audio
      id="character-select-music"
      src="assets/sounds/char_select_theme.flac"
    ></audio>
    <audio id="game-play-music" src="assets/sounds/game_music.wav"></audio>
    <audio
      id="thinking-time-music"
      src="assets/sounds/thinking_music.wav"
    ></audio>
    <!-- Language Selection Modal -->
    <div id="background-box"></div>
    <div id="background-box_1"></div>
    <div id="bottom-overlay-box"></div>
    <div id="character-select-indicator" class="turn-indicator hidden"></div>
    <div id="language-modal" class="modal visible">
      <div class="modal-content-small">
        <h2>Choose Language / 언어 선택</h2>
        <div id="language-buttons" class="selection-buttons">
          <button id="lang-en">English</button>
          <button id="lang-ko">한국어</button>
        </div>
      </div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <button
        id="back-to-main-from-char-select-btn"
        class="close-button"
      ></button>
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="philosopher-name" id="p1-philosopher-name"></div>
        <div class="skill-area" id="p1-skill">
          <h3 class="skill-title" id="p1-skill-title"></h3>
          <p id="p1-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p1-ready-overlay">READY</div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>확 인</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="philosopher-name" id="p2-philosopher-name"></div>
        <div class="skill-area" id="p2-skill">
          <h3 class="skill-title" id="p2-skill-title"></h3>
          <p id="p2-skill-desc"></p>
        </div>
        <div class="ready-overlay" id="p2-ready-overlay">READY</div>
      </div>
    </div>

    <div id="turn-order-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="turn-order-title"></h2>
        <div id="turn-order-buttons" class="selection-buttons">
          <button id="select-first-player"></button>
          <button id="select-second-player"></button>
        </div>
      </div>
    </div>

    <div class="container" id="container">
      <header>
        <h1 id="main-title">LOGOS ORGANON</h1>
      </header>

      <div id="info-box">
        <div class="header-buttons-left">
          <button id="new-game-btn"></button>
          <button id="credits-btn" class="hidden"></button>
        </div>
        <div class="round-display" id="round-display"></div>
        <div class="header-buttons-right">
          <button id="main-menu-btn"></button>
          <button id="fullscreen-btn"></button>
          <button id="settings-btn"></button>
        </div>
      </div>

      <div class="player-area" id="player-a-area">
        <div class="player-title-box">
          <h3 id="player-a-title"></h3>
        </div>

        <div id="player-a-portrait" class="philosopher-portrait"></div>
        <div class="hand" id="player-a-hand"></div>
        <div class="button-wrapper">
          <button class="ability-btn" id="ability-a"></button>
          <button class="eureka-btn" id="eureka-a"></button>
        </div>
      </div>

      <div class="game-board">
        <div class="main-center-bg">
          <img
            id="main-menu-title-img"
            src="assets/images/title.png"
            alt="Logos Title"
          />
          <div class="main-center-buttons">
            <div class="mode-selector">
              <button id="vs-player-btn"></button>
              <button id="vs-ai-btn"></button>
              <button id="vs-ai-test-btn">AI Test Mode</button>
              <button id="vs-ai-battle-btn"></button>
            </div>

            <button id="puzzle-mode-btn"></button>
            <button id="tutorial-btn"></button>
            <button id="tutorial-puzzle-btn"></button>
            <button id="exit-game-btn"></button>
            <div id="mode-description"></div>
          </div>
        </div>

        <div id="current-proposition">
          <h3 id="current-proposition-title"></h3>
          <div id="proposition-display"></div>
          <div id="proposition-controls">
            <button id="complete-btn"></button>
            <button id="undo-btn"></button>
            <button id="end-turn-btn"></button>
          </div>
        </div>
        <div class="true-propositions-wrapper">
          <div id="true-propositions">
            <h3 id="true-propositions-title"></h3>
            <ul id="true-list"></ul>
          </div>

          <div id="thinking-time-controls" class="hidden">
            <h2 id="thinking-time-title"></h2>
            <p id="thinking-time-desc"></p>
          </div>
        </div>
      </div>

      <div class="player-area" id="player-b-area">
        <div class="player-title-box">
          <h3 id="player-b-title"></h3>
        </div>

        <div id="player-b-portrait" class="philosopher-portrait"></div>
        <div class="hand" id="player-b-hand"></div>
        <div class="button-wrapper">
          <button class="ability-btn" id="ability-b"></button
          ><button class="eureka-btn" id="eureka-b"></button>
        </div>
      </div>

      <div class="status-bar" id="status"></div>
    </div>

    <div id="character-selection-screen" class="hidden">
      <div class="player-display-area" id="p1-display">
        <div class="portrait-area" id="p1-portrait"></div>
        <div class="skill-area" id="p1-skill">
          <h3>스킬 설명</h3>
          <p id="p1-skill-desc"></p>
        </div>
      </div>

      <div class="shared-selection-area">
        <div class="char-grid" id="shared-char-grid"></div>
        <button id="confirm-selection-btn" disabled>확인</button>
      </div>

      <div class="player-display-area" id="p2-display">
        <div class="portrait-area" id="p2-portrait"></div>
        <div class="skill-area" id="p2-skill">
          <h3>스킬 설명</h3>
          <p id="p2-skill-desc"></p>
        </div>
      </div>
    </div>

    <!-- Main Eureka Modal -->
    <div id="eureka-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-eureka-modal-btn"></button>
        <h2 id="eureka-title"></h2>

        <div id="workbench-controls">
          <select id="inference-rule-select"></select>
          <button id="apply-rule-btn"></button>
          <button id="add-assumption-btn"></button>
          <button id="cancel-assumption-btn"></button>
        </div>

        <div id="conclusion-preview">
          <h3 id="conclusion-preview-title"></h3>
          <div id="conclusion-preview-text"></div>
        </div>

        <div class="proof-container">
          <div class="premise-selection">
            <h3 id="premise-selection-title"></h3>
            <ul id="premise-list"></ul>
          </div>
        </div>
        <button id="modal-confirm-btn"></button>
      </div>
    </div>

    <div id="ability-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-ability-modal-btn"></button>
        <h2 id="ability-title"></h2>
        <div class="premise-selection" id="ability-premise-selection">
          <ul id="ability-list"></ul>
        </div>
        <div class="modal-buttons">
          <button id="ability-confirm-btn"></button>
        </div>
      </div>
    </div>

    <div id="kant-ability-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-kant-modal-btn"></button>
        <h2 id="kant-ability-title"></h2>

        <div id="kant-proposition-area">
          <h3 id="kant-current-proposition-title">구성중인 명제</h3>
          <div id="kant-proposition-display"></div>
        </div>

        <div id="kant-controls">
          <button id="kant-undo-btn"></button>
          <button id="kant-confirm-btn"></button>
        </div>

        <div id="kant-hand-area">
          <h3 id="kant-hand-title">사용 가능한 카드</h3>
          <div id="kant-hand-display"></div>
        </div>
      </div>
    </div>

    <!-- Tutorial Modal (previously Rules Modal) -->
    <div id="tutorial-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-tutorial-modal-btn"></button>
        <h2 id="tutorial-modal-title"></h2>
        <div id="tutorial-content">
          <!-- Tutorial content will be generated here by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="modal">
      <div class="modal-content-small">
        <p id="alert-message"></p>
        <div class="modal-buttons">
          <button id="alert-ok-btn"></button>
        </div>
      </div>
    </div>

    <!-- Custom Prompt Modal -->
    <div id="prompt-modal" class="modal">
      <div class="modal-content-small">
        <p id="prompt-message"></p>
        <input type="text" id="prompt-input" />
        <div class="modal-buttons">
          <button id="prompt-confirm-btn"></button>
          <button id="prompt-cancel-btn"></button>
        </div>
      </div>
    </div>

    <!-- Tutorial Guide UI -->
    <div id="tutorial-guide" class="hidden">
      <p id="tutorial-text"></p>
      <button id="tutorial-next-btn"></button>
    </div>

    <div id="puzzle-goal-box" class="hidden">
      <p id="puzzle-goal-text"></p>
    </div>

    <div id="ai-turn-summary-modal" class="modal">
      <div class="modal-content-small">
        <h2 id="ai-summary-title"></h2>
        <div id="ai-summary-content"></div>
        <div class="modal-buttons">
          <button id="ai-summary-ok-btn"></button>
        </div>
      </div>
    </div>

    <div id="settings-modal" class="modal">
      <div class="modal-content-small">
        <button class="close-button" id="close-settings-modal-btn"></button>
        <h2 id="settings-title"></h2>
        <div class="settings-group">
          <label for="bgm-volume-slider" id="bgm-label"></label>
          <input
            type="range"
            id="bgm-volume-slider"
            min="0"
            max="1"
            step="0.05"
          />
          <span id="bgm-volume-value">50%</span>
        </div>
        <div class="settings-group">
          <label for="sfx-volume-slider" id="sfx-label"></label>
          <input
            type="range"
            id="sfx-volume-slider"
            min="0"
            max="1"
            step="0.05"
          />
          <span id="sfx-volume-value">100%</span>
        </div>
      </div>
    </div>

    <div id="credits-modal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="close-credits-modal-btn"></button>
        <h2 id="credits-title"></h2>
        <div
          id="credits-content"
          style="
            text-align: left;
            margin-top: 15px;
            line-height: 1.7;
            font-size: 14px;
            max-height: 50vh;
            overflow-y: auto;
            padding-right: 15px;
          "
        >
          <p><strong>Game Design & Development</strong><br />Shin Jeonghyeon</p>

          <p><strong>Graphics</strong><br />Shin Jeonghyeon, Lee Joeun</p>

          <hr
            style="border: 0; border-top: 1px solid #d3b88b; margin: 15px 0"
          />

          <p><strong>SFX</strong></p>
          <p>
            <i>"Menu Selection Click"</i><br />
            Sound by NenadSimic<br />
            Licensed under CC BY 3.0<br />
            <a
              href="https://opengameart.org/content/menu-selection-click"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p><strong>Music</strong></p>
          <p>
            <i>"Contemplation" & "Contemplation 2 (Variation) & Another Me"</i
            ><br />
            Music by Estúdio Cafofo<br />
            Licensed under CC BY 3.0<br />
            <a
              href="http://estudiocafofo.com"
              target="_blank"
              rel="noopener noreferrer"
              >estudiocafofo.com</a
            ><br />
            <a
              href="https://opengameart.org/content/unreleased-game-music-pack"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p>
            <i>"Briefing Theme"</i><br />
            Music by Alexandr Zhelanov<br />
            Licensed under CC BY 3.0<br />
            <a
              href="https://soundcloud.com/alexandr-zhelanov"
              target="_blank"
              rel="noopener noreferrer"
              >soundcloud.com</a
            ><br />
            <a
              href="https://opengameart.org/content/unused-music"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p>
            <i>"Fanfare"</i><br />
            Music by Ted Kerr (2015)<br />
            Licensed under CC BY 3.0<br />
            <a
              href="https://opengameart.org/content/fanfare-0"
              target="_blank"
              rel="noopener noreferrer"
              >opengameart.org</a
            >
          </p>

          <p><strong>Font</strong></p>
          <p>
            Pretendard © 2021 Kil Hyung-jin<br />
            Licensed under SIL Open Font License 1.1<br />
            <a
              href="https://github.com/orioncactus/pretendard"
              target="_blank"
              rel="noopener noreferrer"
              >github.com/orioncactus/pretendard</a
            >
          </p>

          <hr
            style="border: 0; border-top: 1px solid #d3b88b; margin: 15px 0"
          />

          <p>Developed by maemgames, 2025</p>
        </div>
      </div>
    </div>

    <div id="puzzle-level-select-modal" class="modal">
      <div class="shared-selection-area">
        <button class="close-button" id="close-puzzle-modal-btn"></button>
        <h2 id="puzzle-modal-title"></h2>
        <div id="puzzle-level-grid"></div>
      </div>
    </div>

    <script>
      // --- MULTILINGUAL TEXT DATA ---
      const TEXTS = {
        ko: {
          langCode: "ko",
          ui: {
            title: "LOGOS ORGANON",
            tutorialButton: "튜토리얼",
            tutorialPuzzleButton: "튜토리얼 퍼즐",
            exitGameButton: "게임 종료",
            creditsButton: "크레딧",
            endTutorialButton: "튜토리얼 종료",
            newGameButton: "새 게임",
            vsAIButton: "1인 대전",
            vsPlayerButton: "2인 대전",
            puzzleButton: "퍼즐",
            fullscreenButton: "전체화면",
            settingsButton: "환경설정",
            settingsTitle: "환경설정",
            bgmLabel: "배경음악",
            sfxLabel: "효과음",
            playerAName: "소크라테스",
            playerAColor: "⚪️ 백",
            playerBName: "플라톤",
            playerBColor: "⚫️ 흑",
            currentPropositionTitle: "현재 명제",
            completeButton: "명제 완성",
            undoButton: "되돌리기",
            endTurnButton: "턴 종료",
            truePropositionsTitle: "참 명제 목록",
            eurekaButton: "유레카!",
            addTheoremButton: "정리 추가 ➕",
            roundDisplay: "제 {round} 라운드",
            axiomTitle: "기본 공리 (펼쳐보기)",
            statusTurn: "의 턴입니다.",
            statusAITurn: "AI가 생각 중입니다...",
            thinkingTimeStatus: "사유 시간입니다. 새로운 정리를 도출하세요.",
            thinkingTimeTitle: "사유(思惟) 시간",
            thinkingTimeDesc:
              "새로운 정리를 도출하고 '정리 추가' 버튼으로 목록에 반영하세요.",
            endThinkingTimeButton: "사유 시간 종료 & 다음 라운드 시작",
            victoryMessage: "플레이어의 승리!",
            victorySubMessage: "논리적인 증명에 성공했습니다!",
            okButton: "확인",
            cancelButton: "취소",
            nextButton: "다음",
            yesButton: "예",
            noButton: "아니오",
            cancelAssumptionButton: "가정 취소",
            selectP1Philosopher: "1P, 철학자를 선택하세요",
            selectP2Philosopher: "2P, 철학자를 선택하세요",
            selectYourPhilosopher: "당신의 철학자를 선택하세요",
            selectAIPhilosopher: "AI의 철학자를 선택하세요",
            gameStartingSoon: "곧 게임이 시작됩니다...",
            turnOrderTitle: "대전 순서를 선택하세요",
            selectFirstPlayer: "선공",
            selectSecondPlayer: "후공",
            skillTitle: "고유 능력",
            thinkingTimeTurnMessage: "의 사유 시간입니다.",
            useAbilityButton: "능력 사용",
            platoAbilityTitle: "이데아 회상",
            platoConfirmButton: "이 명제를 보편화하기",
            socratesAbilityTitle: "무지의 자각",
            socratesConfirmButton: "이 명제를 다음 라운드까지 제외",
            wittgensteinAbilityTitle: "사다리 걷어차기",
            wittgensteinConfirmButton: "정리 도출 및 전제 삭제",
            vsAIBattleButton: "AI 대전", // AI 대전 버튼
            selectAIP1Philosopher: "AI 1P, 철학자를 선택하세요", // AI 1P 선택 안내
            selectAIP2Philosopher: "AI 2P, 철학자를 선택하세요", // AI 2P 선택 안내
            aiSummaryTitleDefault: "AI의 턴 결과",
            aiSummaryTitleTheorem: "AI가 새로운 정리를 도출했습니다.",
            aiSummaryTitleAbility: "AI가 능력을 사용했습니다.",
            abilityLabel: "[능력]",
            theoremLabel: "[정리]",
            platoAbilityDescription:
              "[이데아 회상] 능력으로 '{proposition}' 명제를 도출했습니다.",
            socratesAbilityDescription:
              "[무지의 자각] 능력으로 '{proposition}' 명제를 다음 라운드까지 논증에서 제외합니다.",
            descartesAbilityDescription:
              "[방법적 회의] 능력으로 '{proposition}' 명제를 참 목록에서 삭제했습니다.",
            humeAbilityDescription:
              "[귀납의 문제] 능력으로 '{proposition}' 명제를 약화시켰습니다.",
            wittgensteinAbilityDescription:
              "[사다리 걷어차기] 능력으로 '{newTheorem}' 정리를 도출하고, 사용된 전제들을 삭제했습니다.",
            kuhnAbilityDescription:
              "[패러다임 전환] 능력으로 새로운 패러다임인 '{newParadigm}'를 수립했습니다.",
            derridaAbilityDescription:
              "[해체] 능력으로 '{proposition}' 명제를 해체했습니다.",
            kantAbilityDescription:
              "[선험적 종합판단] 능력으로 '{proposition}' 명제를 도출했습니다.",
            vsPlayerDesc: "두 플레이어가 한 컴퓨터 앞에 앉아<br>대결합니다.",
            vsAIDesc: "AI를 상대하며 게임을 연습할 수 있습니다.",
            tutorialDesc:
              "게임의 기본 규칙과 논리적 추론 규칙을<br>배울 수 있습니다.",
            puzzleDesc:
              "경쟁 없이, 미리 준비된 논리 추론 퍼즐을<br>풀어볼 수 있습니다.",
          },
          modals: {
            characterSelectTitle: "철학자 선택",
            selectSocrates: "소크라테스 (백) ⚪️",
            selectPlato: "플라톤 (흑) ⚫️",
            eurekaTitleVictory: "유레카! 논증 구성",
            eurekaTitleTheorem: "사유 시간: 정리 구성",
            premiseSelectionTitle: "사용 가능한 전제 목록",
            applyRuleButton: "규칙 적용",
            addAssumptionButton: "가정하기",
            confirmVictoryButton: "이 논증으로 승리 증명!",
            confirmTheoremButton: "선택한 정리들을 참 목록에 추가 ➕",
            tutorialTitle: "LOGOS ORGANON 튜토리얼",
            promptInputPlaceholder: "명제를 입력하세요...",
            puzzleTitle: "레벨 선택",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "LOGOS ORGANON에 오신 것을 환영합니다!",
              "시작하기 전에, 몇 가지 핵심 규칙을 알려드릴게요.",
              "<strong>승리 조건:</strong> 매 게임 시작 시, 각자 무작위로 정해진 <strong>승리 조건</strong>을 받습니다.</br><br>한 라운드에 한 번 가능한 <strong>유레카!</strong>선언으로 <strong>자신의 승리</strong>를 증명하거나 <strong>상대의 패배</strong>를 증명하면 이깁니다.<br><br>예를 들어, 당신의 철학자가 소크라테스, 상대의 철학자가 플라톤이라면<br><strong>소크라테스는 승리한다</strong>나 <strong>플라톤은 승리한다 는 거짓이다</strong>를 증명하면 됩니다.",
              "<strong>첫 턴:</strong> 첫 라운드는 언제나 백 플레이어가 먼저 시작합니다.<br><br><strong>선공 교대:</strong> 라운드가 바뀔 때마다 선공하는 플레이어가 교대됩니다.",
              "그럼, 가장 기본인 <strong>명제</strong>를 만드는 법부터 배워봅시다.",
              "이곳이 당신의 <strong>패</strong>입니다. 여러 단어 카드가 있죠.",
              "카드를 이곳으로 옮겨 <strong>명제</strong>를 만들게 됩니다.",
              "카드를 클릭해서 <strong>현재 명제</strong> 영역으로 옮겨보세요.",
              "아주 좋습니다! <strong>소크라테스는</strong> 같은 <strong>고유 명사</strong>는 바로 명제를 시작할 수 있습니다.",
              "하지만 <strong>개는</strong>, <strong>새는</strong>, <strong>물고기는</strong> 같은 <strong>개체</strong> 카드는 '모든 새는', '어떤 새는'과 같이 <strong>모든</strong>이나 <strong>어떤</strong>과 같은 <strong>양화사</strong> 카드 뒤에만 놓을 수 있습니다.<br><br>또한, 고유명사 카드는 양화사 뒤에 놓을 수 없습니다.<br>'모든 소크라테스'나 '어떤 소크라테스'라는 말은 직관적으로도, 규칙 상으로도 불가능합니다.<br><br>이 점을 꼭 기억해주세요!",
              "각 플레이어는 한 턴에 반드시 한 장의 카드를 내야 하며, 낼 수 있는 카드가 있다면 반드시 내야 합니다.<br><br>카드를 냈으니 이제 턴을 마쳐볼까요?.",
              "<strong>턴 종료</strong> 버튼을 눌러 상대에게 턴을 넘겨주세요.",
              "다음으로, 상대방이 넘겨준 명제에 어떻게 대응하는지 배워보겠습니다.",
            ],
            // Stage 2 (Index 1)
            [
              "상대방의 턴이 끝났습니다. 다시 당신의 턴입니다.",
              "상대방이 만든 명제가 문법적으로 완결되었네요. 이때 여러 행동을 선택할 수 있습니다.",
              "<strong>첫 번째 선택: 명제 완성.</strong> 현재 명제를 <strong>참</strong>으로 인정하는 것입니다. 지금은 아무런 모순이 없으니, <strong>명제 완성</strong> 버튼을 눌러 <strong>참 명제 목록</strong>에 추가해 봅시다.",
              "참 명제 목록에 명제가 추가되었습니다.<br><br>명제가 추가되려면 두 가지 중요한 조건이 있습니다.",
              "첫째, 완전히 같은 명제가 이미 존재한다면 다시 추가할 수 없습니다.",
              "둘째, 기존 참 목록의 명제들과 모순되는 명제는 추가할 수 없습니다.",
              "상대방이 넘겨준 명제를 완성하는 대신, 다른 선택도 가능합니다.",
              "<strong>두 번째 선택: 확장하기.</strong> <strong>그리고</strong>, <strong>또는</strong>, <strong>라면</strong> 같은 <strong>연결사</strong> 카드를 추가하여 명제를 더 복잡하게 만들 수도 있습니다.<br><br>단, 연결사는 하나의 명제에 한 번만 사용할 수 있다는 점을 기억하세요.",
              "<strong>세 번째 선택: 부정하기.</strong> 자신에게 불리한 명제라면, 손패의 <strong>는 거짓이다</strong> 카드를 추가하여 명제를 부정할 수 있습니다.<br>하지만 조심하세요! 만약 상대방도 부정 카드를 낸다면, <strong>이중 부정</strong> 규칙에 따라 당신의 부정이 바로 무효화될 수 있습니다.<br><br>또한, 연결사로 연결된 문장에 <strong>는 거짓이다</strong>가 붙으면, 문장 전체가 아닌 연결사가 결합된 최소 단위 명제만 부정됩니다.<br><br>예를 들어, <strong>어떤 개는 선하다 그리고 소크라테스는 악하다 는 거짓이다</strong>에서 부정되는 부분은 <strong>소크라테스는 악하다</strong> 뿐입니다.",
              "이제 상대의 명제에 대응하는 여러 방법을 배웠습니다. 다음으로, 논증의 기반으로 삼을 수 있는 <strong>기본 공리</strong>에 대해 알아봅시다.",
            ],
            // Stage 3 (Index 2)
            [
              "참 명제 목록에는 우리가 만든 명제뿐만 아니라, 모든 논증의 기반이 되는 <strong>기본 공리</strong>가 들어있습니다.",
              "이 항목을 클릭해서 어떤 공리들이 있는지 확인해 보세요.",
              "공리는 증명할 필요 없이 참으로 받아들여지는 명제들입니다. 예를 들어 '모든 개는 개이다' 와 같은 것들이죠.",
              "공리에 따라, 동일한 개체가 '선하다'와 '악하다'처럼 <strong>두 가지 상반된 속성을 동시에 가질 수 없습니다</strong>.<br><br>또한, <strong>모든 개</strong>와 같은 집단은 <strong>어떤 개</strong>와 같은 일부와 상반된 속성을 가질 수 없습니다.<br><br>예를 들어, <strong>모든 개는 선하다</strong>와 <strong>어떤 개는 악하다</strong>는 동시에 참일 수 없습니다.",
              "논증을 구성할 때, 이 공리들을 중요한 전제로 사용할 수 있습니다.",
              "이제 기본적인 공리들을 확인했으니, 카드를 낼 수 없을 때 어떤 일이 일어나는지 알아봅시다.",
            ],
            // Stage 4 (Index 3)
            [
              "게임이 진행되면, 턴이 돌아온 플레이어가 카드 내기와 명제 완성 모두 불가능한 상황이 오게 됩니다.",
              "이때 라운드가 종료되고 <strong>사유 시간</strong>이 시작됩니다.",
              "사유 시간 턴은 해당 라운드의 후공 플레이어부터 각각 한 턴씩 진행하며, 이미 참인 명제들을 바탕으로 새로운 <strong>정리</strong>를 도출할 수 있습니다.",
              "상대방이 턴을 넘기는 중입니다.",
              "이제 당신의 턴입니다. <strong>정리 추가</strong> 버튼을 눌러봅시다.",
              "논증 구성창이 열렸습니다. <strong>보편 적용</strong> 규칙을 사용해 가볍게 새로운 정리를 만들어 봅시다.<br><br>추론 규칙들의 구체적인 용법은 이후에 배울 것입니다.",
              "전제 목록에서 <strong>소크라테스는 개이다</strong>와 <strong>모든 개는 지혜롭다</strong>를 선택하세요.",
              "추론 규칙에서 <strong>보편 적용</strong>을 선택하고, <strong>규칙 적용</strong> 버튼을 누르세요.",
              "<strong>소크라테스는 지혜롭다</strong>라는 정리가 도출되었습니다.<br><br>이제 이 정리를 선택하고 <strong>선택한 정리들을 참 목록에 추가</strong> 버튼을 눌러 증명을 마칩시다.",
              "새로운 정리가 <strong>참 명제 목록</strong>에 추가되었습니다.<br>사유 시간에는 새로운 정리를 만드는 것 외에, 철학자의 <strong>고유 능력</strong>을 사용할 수도 있습니다. 능력은 게임당 사용 횟수가 제한되어 있지만, 불리한 상황을 뒤집거나 유리한 상황을 굳힐 수 있는 강력한 무기입니다.",
              "이제 <strong>턴 종료</strong> 버튼을 눌러 사유 시간을 마치고 다음 라운드를 시작하세요.<br>라운드가 새로 시작되면 냈던 모든 카드를 돌려받으며, 참 명제 목록은 그대로 유지됩니다.",
            ],
            // Stage 5 (Index 4) - UPDATED & EXPANDED
            [
              "지금까지 게임의 흐름을 배웠습니다. 이제 논증을 구성하는 데 쓰일 <strong>추론 규칙</strong>들을 하나씩 익혀봅시다. <strong>유레카!</strong> 버튼을 눌러 논증 구성창을 여세요.",
              // 1. Modus Ponens
              "먼저 <strong>전건 긍정</strong>입니다. '라면'으로 연결된 명제의 앞쪽이 참이면 뒤쪽도 참이라는 가장 직관적인 규칙이죠.",
              "전제 목록에서 <strong>소크라테스는 선하다</strong>와 <strong>소크라테스는 선하다 라면 소크라테스는 승리한다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>전건 긍정</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 2. Modus Tollens
              "좋습니다. <strong>소크라테스는 승리한다</strong>는 결론이 도출되었습니다.<br><br>이번에는 <strong>후건 부정</strong>을 연습해 봅시다. '라면'으로 연결된 명제의 뒤쪽이 거짓이라면, 앞쪽도 반드시 거짓입니다.<br>예를 들어, '비가 온다면 땅이 젖는다'에서, 땅이 젖지 않았다면 비가 오지 않았다는 것을 직관적으로 알 수 있습니다.",
              "전제 목록에서 <strong>플라톤은 지혜롭다 는 거짓이다</strong>와 <strong>플라톤은 승리한다 라면 플라톤은 지혜롭다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>후건 부정</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 3. Disjunctive Syllogism
              "<strong>플라톤은 승리한다 는 거짓이다</strong>라는 결론이 나왔군요.<br><br>다음은 <strong>선언적 삼단논법</strong>입니다.<br><strong>또는</strong>으로 연결된 명제 중 하나가 거짓이면, 나머지 하나는 반드시 참입니다.",
              "전제 목록에서 <strong>어떤 새는 물고기이다 또는 어떤 새는 새이다</strong>와 <strong>어떤 새는 물고기이다 는 거짓이다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>선언적 삼단논법</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 4. Hypothetical Syllogism
              "<strong>어떤 새는 새이다</strong>가 도출되었습니다.<br><br>이번엔 <strong>가설적 삼단논법</strong>입니다. 꼬리물기처럼 이어지는 두 명제를 하나로 합쳐봅시다.",
              "전제 목록에서 <strong>플라톤은 개이다 라면 플라톤은 선하다</strong>와 <strong>플라톤은 선하다 라면 플라톤은 승리한다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>가설적 삼단논법</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 5. Conjunction Elimination (Simplification)
              "<strong>플라톤은 개이다 라면 플라톤은 승리한다</strong>라는 더 간결한 명제가 만들어졌습니다. 다음은 <strong>단순화</strong> 규칙입니다.",
              "<strong>그리고</strong>로 연결된 명제는 각각이 참입니다. 전제 목록에서 <strong>소크라테스는 지혜롭다 그리고 플라톤은 어리석다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>단순화</strong>를 선택하고 <strong>규칙 적용</strong> 버튼을 눌러보세요. 두 개의 명제가 한 번에 도출될 겁니다.",
              // 6. Double Negation Elimination
              "보시다시피 두 명제가 각각 분리되었습니다.<br><br>이제 <strong>이중 부정 제거</strong> 규칙을 배워봅시다. 부정을 두 번 하면 긍정이 됩니다.",
              "전제 목록에서 <strong>어떤 물고기는 선하다 는 거짓이다 는 거짓이다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>이중 부정 제거</strong>를 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 7. Universal Application
              "원래의 긍정 명제로 돌아왔습니다.<br><br>다음은 <strong>보편 적용</strong> 규칙입니다. 보편적인 규칙은 개별 사례에도 적용됩니다.",
              "전제 목록에서 <strong>모든 새는 선하다</strong>와 <strong>플라톤은 새이다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>보편 적용</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // 8. Existential Instantiation
              "<strong>플라톤은 선하다</strong>가 도출되었습니다.<br><br>다음은 <strong>존재화</strong> 규칙입니다. '어떤 새는 새이다', '어떤 개는 개이다', '어떤 물고기는 물고기이다' 공리에 의해 새, 개, 물고기가 존재한다는 것이 보장되므로, <strong>모든</strong>으로 서술된 속성을 가진 <strong>어떤</strong> 일부가 존재한다는 사실을 도출할 수 있습니다.",
              "전제 목록에서 <strong>모든 개는 선하다</strong>를 선택하세요.",
              "규칙 목록에서 <strong>존재화</strong>를 선택하고 <strong>규칙 적용</strong> 버튼을 누르세요.",
              // End of Stage 5
              "<strong>어떤 개는 선하다</strong>가 도출되었습니다.<br><br>다음으로 여러 개의 명제를 한번에 조합하는 강력한 규칙을 배워봅시다.",
            ],
            // Stage 6 (Index 5)
            [
              "이번에 배울 <strong>경우 논증</strong>은 여러 갈래의 길을 하나의 결론으로 모으는 규칙입니다.",
              "<strong>플라톤은 선하거나 악하다</strong>는 두 가지 경우가 있습니다. 그런데 어느 경우든 <strong>플라톤은 지혜롭다</strong>는 결론에 도달하는군요. 먼저, 필요한 전제 세 가지를 모두 선택해주세요.",
              "이제 추론 규칙 목록에서 <strong>경우 논증</strong>을 선택하고 <strong>규칙 적용</strong> 버튼을 눌러 결론을 도출하세요.",
              "<strong>플라톤은 지혜롭다</strong>는 결론이 도출되었습니다.<br><br>다음은 논리학의 꽃이라 불리는 <strong>가정</strong>을 사용하는 규칙입니다.",
            ],
            // Stage 7 (Index 6) - ★★★ MODIFIED SECTION ★★★
            [
              "때로는 증명을 위해 무언가를 <strong>만약 ~라면</strong> 하고 가정해야 할 때가 있습니다. 이번에는 두 개의 전제를 논리적으로 연결해 봅시다.",
              "<strong>가정하기</strong> 버튼을 눌러 <strong>소크라테스는 지혜롭다</strong>를 입력해 가정해 보세요.",
              "좋습니다. 이제 가정과 첫 번째 전제인 <strong>소크라테스는 지혜롭다 라면 플라톤은 개이다</strong>를 선택하세요.",
              "<strong>전건 긍정</strong> 규칙을 적용해 중간 결론을 도출하세요.",
              "이제 방금 얻은 중간 결론과 두 번째 전제인 <strong>플라톤은 개이다 라면 플라톤은 선하다</strong>를 선택하세요.",
              "다시 <strong>전건 긍정</strong> 규칙을 적용해 최종 결론을 이끌어내세요.",
              "최종 결과물인 <strong>플라톤은 선하다</strong>를 선택하세요.",
              "마지막으로, <strong>조건문 도입</strong> 규칙을 적용하세요. 그러면 <strong>소크라테스는 지혜롭다 라면 플라톤은 선하다</strong>라는 새로운 정리가 완성됩니다.",
              "이제 귀류법에 대해 알아봅시다.",
            ],
            // Stage 8 (Index 7) - NEWLY ADDED
            [
              "<strong>귀류법</strong>은 증명하고 싶은 것의 <strong>반대</strong>를 가정하여 모순을 이끌어내는 방법입니다.",
              "우리의 목표는 <strong>소크라테스는 악하다</strong>를 증명하는 것입니다. <strong>가정하기</strong>로 그 반대인 <strong>소크라테스는 악하다 는 거짓이다</strong>를 가정하세요.",
              "가정이 추가되었습니다. 이제 이 가정을 이용해 명백한 모순, 즉 'P'와 'P 는 거짓이다' 형태의 한 쌍을 만들어 봅시다. 방금 만든 가정과 다른 전제를 선택하고 <strong>전건 긍정</strong> 규칙을 적용해 보세요.",
              "<strong>플라톤은 지혜롭다</strong>가 도출되었습니다. 하지만 이미 참인 명제 목록에 <strong>플라톤은 지혜롭다 는 거짓이다</strong>가 존재합니다. 이것이 바로 모순입니다.",
              "이제 모순되는 두 명제를 모두 선택하고 <strong>귀류법</strong> 규칙을 적용하세요.",
              "최초의 가정이 틀렸다는 것이 증명되었습니다. 이제 마지막으로 <strong>이중 부정 제거</strong> 규칙을 적용하여 최종 결론을 얻어내세요.",
              "좋습니다. 이제 LOGOS ORGANON의 모든 추론 규칙을 배우셨습니다.<br><br>사유시간 외 언제라도 유레카! 버튼을 눌러 논증 구성 창을 열고, 방금 배운 추론 규칙들을 활용해 자신의 승리 또는 상대의 승리 불가능을 증명하면 즉시 게임에서 승리합니다.",
            ],
            // Stage 9 (Index 8) - 새로 추가되는 부분
            [
              "마지막으로 지금까지 배운 추론 규칙을 활용해 당신의 승리 [소크라테스는 승리한다]나 상대의 패배 [플라톤은 승리한다 는 거짓이다]를 증명해 보세요.",
            ],
          ],
          inferenceRules: {
            basic: "기본 규칙",
            modusPonens: "전건 긍정 (P, P 라면 Q ∴ Q)",
            modusTollens: "후건 부정 (Q 는 거짓이다, P 라면 Q ∴ P 는 거짓이다)",
            hypotheticalSyllogism:
              "가설적 삼단논법 (P 라면 Q, Q 라면 R ∴ P 라면 R)",
            disjunctiveSyllogism:
              "선언적 삼단논법 (P 또는 Q, P 는 거짓이다 ∴ Q)",
            universalApplication: "보편 적용 (A는 P다, 모든 P는 Q다 ∴ A는 Q다)",
            existentialInstantiation: "존재화 (모든 P는 Q다 ∴ 어떤 P는 Q다)",
            conjunctionElimination: "단순화 (P 그리고 Q ∴ P, Q)",
            doubleNegationElimination:
              "이중 부정 제거 (P 는 거짓이다 는 거짓이다 ∴ P)",
            assumptionBased: "가정 기반 규칙",
            conditionalIntroduction: "조건문 도입 (P 가정, Q 도출 ∴ P 라면 Q)",
            reductioAdAbsurdum: "귀류법 (P 가정, 모순 도출 ∴ P 는 거짓이다)",
            advanced: "고급 규칙",
            proofByCases: "경우 논증 (P 또는 Q, P 라면 R, Q 라면 R ∴ R)",
          },

          alerts: {
            invalidCard: "규칙에 맞지 않는 카드입니다!",
            incompleteProposition:
              "완성되지 않은 명제이거나 파싱에 실패했습니다.",
            duplicateProposition: "같은 명제가 이미 존재합니다.",
            contradictionFound:
              "모순이 발견되었습니다!<br>이 명제는 기존의 참 명제들과 양립할 수 없습니다.",
            undoLastCard: "마지막으로 놓은 카드를 되돌렸습니다.",
            undoLastProposition: "마지막으로 완성된 명제를 되돌렸습니다.",
            nothingToUndo: "되돌릴 수 있는 완성된 명제가 없습니다.",
            roundEndNoMoves:
              "'{player}' 플레이어가 더 이상 낼 수 있는 카드가 없어 사유 시간으로 전환합니다.",
            criticalErrorUndo:
              "진리 체계를 재구성하는 중 심각한 오류가 발생했습니다. 게임을 새로 시작해야 할 수 있습니다.",
            oneAssumptionOnly: "가정은 한 번에 하나만 할 수 있습니다.",
            parsingFailed:
              "명제를 파싱할 수 없습니다. 올바른 형식으로 입력해주세요.",
            premiseNeededForIntro:
              "조건문 도입 규칙은 가정으로부터 도출된 '결론' 명제 하나만 선택해야 합니다.",
            assumptionNeededForIntro:
              "조건문 도입 규칙을 사용하려면 먼저 '가정하기'를 통해 가정을 해야 합니다.",
            premiseNotFromAssumption:
              "선택한 명제는 현재 가정과 무관합니다. 가정으로부터 파생된 명제를 선택하세요.",
            premiseCountError: "이 규칙은 {count}개의 전제가 필요합니다.",
            contradictionNeededForRAA:
              "귀류법은 서로 모순되는 2개의 전제가 필요합니다.",
            assumptionNeededForRAA:
              "귀류법을 적용하려면 먼저 '가정하기'를 통해 가정을 해야 합니다.",
            notAContradiction:
              "모순 관계가 아닙니다. 귀류법을 적용할 수 없습니다.",
            ruleFailed: "규칙 적용에 실패했습니다. 전제들을 확인해주세요.",
            noTheoremsToAdd: "추가할 새로운 정리가 없습니다.",
            proofIncomplete:
              "증명이 완료되지 않았습니다.\n자신의 승리 [{myGoal}] 또는\n상대의 패배 [{opponentGoal}] 를 도출해야 합니다.",
            oneCardPerTurn: "한 턴에 한 장의 카드만 낼 수 있습니다.",
            aiEurekaDeclared: "AI가 '유레카!'를 선언했습니다!",
            selectOneTheoremOnly: "하나의 최종 정리만 선택해야 합니다.",
            wittgensteinSuccess:
              "새로운 정리가 추가되었고, 증명에 사용된 전제들이 삭제되었습니다.",
            kantSuccess: "새로운 명제가 참 목록에 추가되었습니다!",
            confirmCloseEureka:
              "유레카! 선언은 한 라운드에 한 번만 할 수 있습니다.<br>정말 창을 닫으시겠습니까?",
            confirmExit: "정말로 종료하시겠습니까?",
            tutorialVictory:
              "잘 하셨습니다.<br>이제 논리 대결에 참여하여 당신의 지혜를 증명해 보세요!",
            puzzleCleared: "축하합니다! 클리어하셨습니다!",
            confirmDeclareEureka:
              "유레카! 선언은 한 라운드에 한 번만 가능합니다.<br>선언하시겠습니까?",
          },
          keywords: {
            if: "라면",
            and: "그리고",
            or: "또는",
            not: "는 거짓이다",
            wins: "승리한다",
            socrates: "소크라테스는",
            plato: "플라톤은",
            universal_q: "모든",
            existential_q: "어떤",
          },
          cards: [
            { type: "양화사", text: "어떤" },
            { type: "양화사", text: "모든" },
            { type: "연산자", text: "라면" },
            { type: "연산자", text: "그리고" },
            { type: "연산자", text: "또는" },
            { type: "연산자", text: "는 거짓이다" },
            { type: "개체", text: "새는" },
            { type: "개체", text: "물고기는" },
            { type: "개체", text: "개는" },
            { type: "고유명사", text: "소크라테스는" },
            { type: "고유명사", text: "플라톤은" },
            { type: "서술어", text: "선하다" },
            { type: "서술어", text: "악하다" },
            { type: "서술어", text: "지혜롭다" },
            { type: "서술어", text: "어리석다" },
            { type: "서술어", text: "새이다" },
            { type: "서술어", text: "물고기이다" },
            { type: "서술어", text: "개이다" },
            { type: "서술어", text: "승리한다" },
          ],
          cardTypes: ["고유명사", "양화사", "개체", "서술어", "연산자"],
          axiom_templates: {
            identity: [
              "어떤 새는 새이다",
              "모든 새는 새이다",
              "어떤 물고기는 물고기이다",
              "모든 물고기는 물고기이다",
              "어떤 개는 개이다",
              "모든 개는 개이다",
            ],
            subject_good_evil: [
              "{S} 선하다 또는 {S} 악하다",
              "{S} 선하다 라면 {S} 악하다 는 거짓이다",
            ],
            subject_wise_foolish: [
              "{S} 지혜롭다 또는 {S} 어리석다",
              "{S} 지혜롭다 라면 {S} 어리석다 는 거짓이다",
            ],
            bird_good_evil_forward: [
              "모든 새는 선하다 라면 어떤 새는 악하다 는 거짓이다",
              "모든 새는 악하다 라면 어떤 새는 선하다 는 거짓이다",
              "모든 새는 지혜롭다 라면 어떤 새는 어리석다 는 거짓이다",
              "모든 새는 어리석다 라면 어떤 새는 지혜롭다 는 거짓이다",
            ],
            bird_good_evil_reverse: [
              "어떤 새는 선하다 는 거짓이다 라면 모든 새는 악하다",
              "어떤 새는 악하다 는 거짓이다 라면 모든 새는 선하다",
              "어떤 새는 지혜롭다 는 거짓이다 라면 모든 새는 어리석다",
              "어떤 새는 어리석다 는 거짓이다 라면 모든 새는 지혜롭다",
            ],
            fish_good_evil_forward: [
              "모든 물고기는 선하다 라면 어떤 물고기는 악하다 는 거짓이다",
              "모든 물고기는 악하다 라면 어떤 물고기는 선하다 는 거짓이다",
              "모든 물고기는 지혜롭다 라면 어떤 물고기는 어리석다 는 거짓이다",
              "모든 물고기는 어리석다 라면 어떤 물고기는 지혜롭다 는 거짓이다",
            ],
            fish_good_evil_reverse: [
              "어떤 물고기는 선하다 는 거짓이다 라면 모든 물고기는 악하다",
              "어떤 물고기는 악하다 는 거짓이다 라면 모든 물고기는 선하다",
              "어떤 물고기는 지혜롭다 는 거짓이다 라면 모든 물고기는 어리석다",
              "어떤 물고기는 어리석다 는 거짓이다 라면 모든 물고기는 지혜롭다",
            ],
            dog_good_evil_forward: [
              "모든 개는 선하다 라면 어떤 개는 악하다 는 거짓이다",
              "모든 개는 악하다 라면 어떤 개는 선하다 는 거짓이다",
              "모든 개는 지혜롭다 라면 어떤 개는 어리석다 는 거짓이다",
              "모든 개는 어리석다 라면 어떤 개는 지혜롭다 는 거짓이다",
            ],
            dog_good_evil_reverse: [
              "어떤 개는 선하다 는 거짓이다 라면 모든 개는 악하다",
              "어떤 개는 악하다 는 거짓이다 라면 모든 개는 선하다",
              "어떤 개는 지혜롭다 는 거짓이다 라면 모든 개는 어리석다",
              "어떤 개는 어리석다 는 거짓이다 라면 모든 개는 지혜롭다",
            ],
          },
          victoryPredicates: ["선하다", "악하다", "지혜롭다", "어리석다"],
          contradictoryPredicates: { 선하다: "악하다", 지혜롭다: "어리석다" },
          labels: {
            proposition: "[명제]",
            axiom: "[공리]",
            victory_condition: "[승리 조건]",
            theorem: "[정리]",
            assumption: "[가정]",
            ci_theorem: "[조건문 도입]",
            raa_theorem: "[귀류법 증명]",
            theorem_source: "[정리] {text} (R{round} 사유)",
            victory_text: "{owner} 승리 조건: <strong>{text}</strong>",
            plato_ability_source: "{text} (이데아 회상)",
            nietzsche_ability_source: "{text} (영원 회귀)",
            wittgenstein_ability_source: "{text} (사다리 걷어차기)",
            derrida_ability_source: "{text} (해체)",
            hume_ability_source: "{text} (귀납의 문제)",
            kuhn_ability_source: "{text} (패러다임 전환)",
            kant_ability_source: "{text} (선험적 종합판단)",
          },
        },
        en: {
          langCode: "en",
          ui: {
            title: "LOGOS ORGANON",
            tutorialButton: "Tutorial",
            tutorialPuzzleButton: "Tutorial Puzzle",
            puzzleButton: "Puzzle",
            exitGameButton: "Exit Game",
            creditsButton: "Credits",
            endTutorialButton: "End Tutorial",
            newGameButton: "New Game",
            fullscreenButton: "Fullscreen",
            settingsButton: "Settings",
            settingsTitle: "Settings",
            bgmLabel: "BGM",
            sfxLabel: "SFX",
            vsAIButton: "1P vs AI",
            vsPlayerButton: "1P vs 2P",
            playerAName: "Socrates",
            playerAColor: "⚪️ White",
            playerBName: "Plato",
            playerBColor: "⚫️ Black",
            currentPropositionTitle: "Current Proposition",
            completeButton: "Complete",
            undoButton: "Undo",
            endTurnButton: "End Turn",
            truePropositionsTitle: "True Propositions",
            eurekaButton: "Eureka!",
            addTheoremButton: "Add Theorem ➕",
            roundDisplay: "Round {round}",
            axiomTitle: "Basic Axioms (Click to expand)",
            statusTurn: "'s Turn",
            statusAITurn: "AI is thinking...",
            thinkingTimeStatus: "Thinking Time. Derive new theorems.",
            thinkingTimeTitle: "Thinking Time",
            thinkingTimeDesc:
              "Derive new theorems and add them to the list using the 'Add Theorem' button.",
            endThinkingTimeButton: "End Thinking Time & Start Next Round",
            victoryMessage: "Player Wins!",
            victorySubMessage: "Succeeded with a logical proof!",
            okButton: "OK",
            cancelButton: "Cancel",
            nextButton: "Next",
            yesButton: "Yes",
            noButton: "No",
            cancelAssumptionButton: "Cancel",
            selectP1Philosopher: "1P, Select Your Philosopher",
            selectP2Philosopher: "2P, Select Your Philosopher",
            selectYourPhilosopher: "Select Your Philosopher",
            selectAIPhilosopher: "Select AI's Philosopher",
            gameStartingSoon: "Game starting soon...",
            turnOrderTitle: "Choose Turn Order",
            selectFirstPlayer: "Go First",
            selectSecondPlayer: "Go Second",
            skillTitle: "Unique Ability",
            thinkingTimeTurnMessage: "'s Thinking Time.",
            useAbilityButton: "Use Ability",
            platoAbilityTitle: "Recollection of Forms",
            platoConfirmButton: "Universalize this Proposition",
            socratesAbilityTitle: "Awareness of Ignorance",
            socratesConfirmButton: "Exclude this proposition from arguments",
            wittgensteinAbilityTitle: "Kicking Away the Ladder",
            wittgensteinConfirmButton: "Derive Theorem & Delete Premises",
            vsAIBattleButton: "AI vs AI",
            selectAIP1Philosopher: "Select AI 1P's Philosopher",
            selectAIP2Philosopher: "Select AI 2P's Philosopher",
            aiSummaryTitleDefault: "AI's Turn Result",
            aiSummaryTitleTheorem: "AI has derived a new theorem.",
            aiSummaryTitleAbility: "AI has used an ability.",
            abilityLabel: "[Ability]",
            theoremLabel: "[Theorem]",
            platoAbilityDescription:
              "[Recollection of Forms] ability was used to derive '{proposition}'.",
            socratesAbilityDescription:
              "[Awareness of Ignorance] ability was used to exclude '{proposition}' from arguments for the next round.",
            descartesAbilityDescription:
              "[Methodic Doubt] ability was used to delete '{proposition}' from the list of true propositions.",
            humeAbilityDescription:
              "[Problem of Induction] ability was used to weaken '{proposition}'.",
            wittgensteinAbilityDescription:
              "[Kicking Away the Ladder] ability was used to derive the theorem '{newTheorem}' and delete its premises.",
            kuhnAbilityDescription:
              "[Paradigm Shift] ability was used to establish a new paradigm: '{newParadigm}'.",
            derridaAbilityDescription:
              "[Deconstruction] ability was used to deconstruct the proposition '{proposition}'.",
            kantAbilityDescription:
              "[Synthetic A Priori Judgment] ability was used to derive '{proposition}'.",
            vsPlayerDesc: "Two players face off on a single computer.",
            vsAIDesc: "Practice the game by playing against the AI.",
            tutorialDesc:
              "Learn the basic rules of the game and the rules of inference.",
            puzzleDesc:
              "Solve pre-made logical reasoning puzzles without competition.",
          },
          modals: {
            characterSelectTitle: "Select Your Philosopher",
            selectSocrates: "Socrates (White) ⚪️",
            selectPlato: "Plato (Black) ⚫️",
            eurekaTitleVictory: "Eureka! Construct Proof",
            eurekaTitleTheorem: "Thinking Time: Construct Theorem",
            premiseSelectionTitle: "Available Premises List",
            applyRuleButton: "Apply",
            addAssumptionButton: "Assume",
            confirmVictoryButton: "Prove Victory with this Argument!",
            confirmTheoremButton: "Add Selected Theorems to True List ➕",
            tutorialTitle: "LOGOS ORGANON Tutorial",
            promptInputPlaceholder: "Enter proposition...",
            puzzleTitle: "Select Level",
          },
          tutorial: [
            // Stage 1 (Index 0)
            [
              "Welcome to LOGOS ORGANON!",
              "Before we begin, let's go over a few core rules.",
              "<strong>Win Condition:</strong> At the start of each game, you get a random <strong>Win Condition</strong>.<br><br>You win by declaring <strong>Eureka!</strong>, which is possible once per round, and proving either <strong>your own victory</strong> or <strong>your opponent's defeat</strong>.<br><br>For example, if your philosopher is Socrates and your opponent's is Plato, you win by proving either <strong>Socrates wins</strong> or <strong>Plato wins is false</strong>.",
              "<strong>First Turn:</strong> The first round always begins with the White player.<br><br><strong>Alternating Turns:</strong> The starting player alternates each round.",
              "Now, let's learn the most basic action: how to form a <strong>proposition</strong>.",
              "This is your <strong>hand</strong>. It contains various word cards.",
              "You will move cards here to form a <strong>proposition</strong>.",
              "Click a card to move it to the <strong>Current Proposition</strong> area.",
              "Excellent! A <strong>Proper Noun</strong> like <strong>Socrates</strong> can start a proposition directly.",
              "However, <strong>Entity</strong> cards like <strong>dog</strong>, <strong>bird</strong>, and <strong>fish</strong> must always follow a <strong>Quantifier</strong> card like <strong>Every</strong> or <strong>Some</strong>.<br><br>Also, a proper noun card cannot be placed after a quantifier.<br>Saying 'Every Socrates' or 'Some Socrates' is impossible, both intuitively and by the rules.<br><br>Please remember this crucial point!",
              "Each player must play exactly one card per turn, and if they have a playable card, they must play it.<br><br>Now that you've played a card, shall we end the turn?",
              "Press the <strong>End Turn</strong> button to pass the turn to your opponent.",
              "Next, let's learn how to respond to the proposition passed by your opponent.",
            ],
            // Stage 2 (Index 1)
            [
              "Your opponent's turn is over. It's your turn again.",
              "The proposition your opponent made is grammatically complete. You have several options now.",
              "<strong>First Option: Complete Proposition.</strong> This accepts the current statement as <strong>true</strong>. Since there are no contradictions for now, let's press the <strong>Complete Proposition</strong> button to add it to the <strong>List of True Propositions</strong>.",
              "The proposition has been added to the List of True Propositions.<br><br>There are two important conditions for a proposition to be added.",
              "First, you cannot add a proposition if the exact same one already exists.",
              "Second, you cannot add a proposition that contradicts an existing truth.",
              "Instead of completing the proposition, other options are also available.",
              "<strong>Second Option: Extend.</strong> You can add <strong>connective</strong> cards like <strong>and</strong>, <strong>or</strong>, or <strong>then</strong> to make the proposition more complex.<br><br>Remember, you can only use one connective per proposition.",
              "<strong>Third Option: Negate.</strong> If a proposition is disadvantageous, you can add the <strong>is false</strong> card from your hand to negate it.<br>But be careful! If your opponent also plays a negation card, your negation can be immediately nullified by the <strong>Double Negation</strong> rule.<br><br>Also, when <strong>is false</strong> is attached to a sentence with a connective, it only negates the smallest proposition it's attached to, not the whole sentence.<br><br>For example, in <strong>Some dog is good and Socrates is evil is false</strong>, only the <strong>Socrates is evil</strong> part is negated.",
              "Now you've learned the various ways to respond to an opponent's proposition. Next, let's learn about the <strong>Basic Axioms</strong> that form the foundation of our arguments.",
            ],
            // Stage 3 (Index 2)
            [
              "The List of True Propositions contains not only the propositions we've made, but also the <strong>Basic Axioms</strong> which are the foundation of all arguments.",
              "Click this item to see what axioms are available.",
              "Axioms are propositions that are accepted as true without proof, such as 'Every dog is a dog'.",
              "According to the axioms, the same entity <strong>cannot have two opposing properties at the same time</strong>, like being both 'good' and 'evil'.<br><br>Furthermore, a statement about an entire group, such as <strong>Every dog</strong>, cannot be contradicted by a statement about a part of that group, such as <strong>Some dog</strong>.<br><br>For example, <strong>Every dog is good</strong> and <strong>Some dog is evil</strong> cannot both be true at the same time.",
              "You can use these axioms as important premises when constructing your arguments.",
              "Now that you've checked the basic axioms, let's find out what happens when you cannot play any card.",
            ],
            // Stage 4 (Index 3)
            [
              "As the game progresses, a situation will arise where the current player can neither play a card nor complete the proposition.",
              "When this happens, the round ends and <strong>Thinking Time</strong> begins.",
              "During Thinking Time, players take one turn each, starting with the player who went second in that round. You can derive new <strong>theorems</strong> based on the existing true propositions.",
              "Your opponent is ending their turn.",
              "Now it's your turn. Press the <strong>Add Theorem</strong> button.",
              "The proof workbench has opened. Let's create a new theorem using the <strong>Universal Application</strong> rule. We will learn the specific uses of inference rules later.",
              "Select the premises <strong>Socrates is a dog</strong> and <strong>Every dog is wise</strong> from the list.",
              "Now, select <strong>Universal Application</strong> from the dropdown and click the <strong>Apply Rule</strong> button.",
              "The new theorem <strong>Socrates is wise</strong> has been derived.<br><br>Now, select this theorem and press the <strong>Add Selected Theorems to True List</strong> button to finalize the proof.",
              "The new theorem has been added to the <strong>List of True Propositions</strong>.<br>In Thinking Time, besides creating new theorems, you can also use your philosopher's <strong>unique ability</strong>. Abilities have limited uses per game, but they are powerful tools that can turn the tide or solidify your advantage.",
              "Now press the <strong>End Turn</strong> button to finish Thinking Time and start the next round.<br>When a new round starts, you get all your played cards back, and the List of True Propositions remains.",
            ],
            // Stage 5 (Index 4)
            [
              "You've learned the game flow. Now, let's learn the <strong>inference rules</strong> used to construct arguments. Press the <strong>Eureka!</strong> button to open the proof workbench.",
              // 1. Modus Ponens
              "First up is <strong>Modus Ponens</strong>. It's the most intuitive rule: if the first part of a 'then' statement is true, the second part must also be true.",
              "From the premise list, select <strong>Socrates is good</strong> and <strong>Socrates is good then Socrates wins</strong>.",
              "Select <strong>Modus Ponens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 2. Modus Tollens
              "Great. The conclusion <strong>Socrates wins</strong> has been derived.<br><br>Now let's practice <strong>Modus Tollens</strong>. If the second part of a 'then' statement is false, the first part must also be false.<br>For example, from 'If it rains, then the ground is wet', if the ground is not wet, you intuitively know it didn't rain.",
              "From the premise list, select <strong>Plato is wise is false</strong> and <strong>Plato wins then Plato is wise</strong>.",
              "Select <strong>Modus Tollens</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 3. Disjunctive Syllogism
              "The conclusion <strong>Plato wins is false</strong> has been derived.<br><br>Next is <strong>Disjunctive Syllogism</strong>.<br>In an <strong>or</strong> statement, if one part is false, the other must be true.",
              "From the premise list, select <strong>Some bird is a fish or Some bird is a bird</strong> and <strong>Some bird is a fish is false</strong>.",
              "Select <strong>Disjunctive Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 4. Hypothetical Syllogism
              "<strong>Some bird is a bird</strong> has been derived.<br><br>Now for <strong>Hypothetical Syllogism</strong>. Let's combine two chaining propositions into one.",
              "Select <strong>Plato is a dog then Plato is good</strong> and <strong>Plato is good then Plato wins</strong>.",
              "Select <strong>Hypothetical Syllogism</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 5. Conjunction Elimination (Simplification)
              "A more concise proposition <strong>Plato is a dog then Plato wins</strong> has been created. Next is the <strong>Simplification</strong> rule.",
              "A statement connected by <strong>and</strong> means both parts are true. From the premise list, select <strong>Socrates is wise and Plato is foolish</strong>.",
              "Select <strong>Simplification</strong> from the rule list and click <strong>Apply Rule</strong>. Two propositions will be derived at once.",
              // 6. Double Negation Elimination
              "As you can see, the two propositions have been separated.<br><br>Now let's learn the <strong>Double Negation Elimination</strong> rule. Two negatives make a positive.",
              "Select <strong>Some fish is good is false is false</strong> from the premise list.",
              "Select <strong>Double Negation Elimination</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 7. Universal Application
              "It's back to the original positive statement.<br><br>Next up is the <strong>Universal Application</strong> rule. A universal rule applies to specific instances.",
              "Select <strong>Every bird is good</strong> and <strong>Plato is a bird</strong> from the premise list.",
              "Select <strong>Universal Application</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // 8. Existential Instantiation
              "<strong>Plato is good</strong> has been derived.<br><br>Next is the <strong>Existential Instantiation</strong> rule. Axioms like 'Some bird is a bird', 'Some dog is a dog', and 'Some fish is a fish' guarantee that entities exist. Therefore, if a property is true for <strong>Every</strong> member of a group, it can be derived that it is true for <strong>Some</strong> members.",
              "Select <strong>Every dog is good</strong> from the premise list.",
              "Select <strong>Existential Instantiation</strong> from the rule list and click <strong>Apply Rule</strong>.",
              // End of Stage 5
              "<strong>Some dog is good</strong> has been derived.<br><br>Next, let's learn a powerful rule for combining multiple propositions at once.",
            ],
            // Stage 6 (Index 5)
            [
              "The <strong>Proof by Cases</strong> rule we'll learn now brings multiple diverging paths to a single conclusion.",
              "We have two cases: <strong>Plato is good or Plato is evil</strong>. However, either case leads to the conclusion <strong>Plato is wise</strong>. First, please select all three required premises.",
              "Now, select <strong>Proof by Cases</strong> from the rule list and click <strong>Apply Rule</strong> to derive the conclusion.",
              "The conclusion <strong>Plato is wise</strong> has been derived.<br><br>Next up are rules that use <strong>assumptions</strong>, the heart of logic.",
            ],
            // Stage 7 (Index 6)
            [
              "Sometimes, to prove something, you need to assume <strong>what if...</strong>. This time, let's logically connect two premises.",
              "Click the <strong>Assume</strong> button and assume <strong>Socrates is wise</strong> by typing it in.",
              "Great. Now, select the assumption and the first premise: <strong>Socrates is wise then Plato is a dog</strong>.",
              "Apply the <strong>Modus Ponens</strong> rule to derive an intermediate conclusion.",
              "Now, select the intermediate conclusion you just got and the second premise: <strong>Plato is a dog then Plato is good</strong>.",
              "Apply the <strong>Modus Ponens</strong> rule again to derive the final conclusion.",
              "Select the final result, <strong>Plato is good</strong>.",
              "Finally, apply the <strong>Conditional Introduction</strong> rule. This will create the new theorem <strong>Socrates is wise then Plato is good</strong>.",
              "Now let's learn about Reductio ad Absurdum.",
            ],
            // Stage 8 (Index 7)
            [
              "<strong>Reductio ad Absurdum</strong> is a method of proving something by assuming its <strong>opposite</strong> to find a contradiction.",
              "Our goal is to prove <strong>Socrates is evil</strong>. Click <strong>Assume</strong> and assume the opposite: <strong>Socrates is evil is false</strong>.",
              "The assumption has been added. Now, let's use it to create an obvious contradiction, a pair of 'P' and '~P'. Select the assumption you just made and the other premise, then apply the <strong>Modus Ponens</strong> rule.",
              "<strong>Plato is wise</strong> has been derived. But we already have <strong>Plato is wise is false</strong> in our list of true propositions. This is a contradiction!",
              "Now, select the two contradictory propositions and apply the <strong>Reductio ad Absurdum</strong> rule.",
              "This proves our initial assumption was wrong. Now, apply the <strong>Double Negation Elimination</strong> rule to the result to get our final conclusion.",
              "Excellent. You have now learned all the inference rules of LOGOS ORGANON.<br><br>At any time outside of Thinking Time, you can open the proof workbench with the Eureka! button. Use the rules you've learned to prove your own victory or your opponent's inability to win, and you will immediately win the game.",
            ],
            [
              "Finally, using the inference rules you've learned so far, try to prove your victory [Socrates wins] or your opponent's defeat [Plato wins is false].",
            ],
          ],
          inferenceRules: {
            basic: "Basic Rules",
            modusPonens: "Modus Ponens (P, P then Q ∴ Q)",
            modusTollens: "Modus Tollens (Q is false, P then Q ∴ ~P)",
            hypotheticalSyllogism:
              "Hypothetical Syllogism (P then Q, Q then R ∴ P then R)",
            disjunctiveSyllogism:
              "Disjunctive Syllogism (P or Q, P is false ∴ Q)",
            universalApplication:
              "Universal Application (A is P, Every P are Q ∴ A is Q)",
            existentialInstantiation:
              "Existential Instantiation (Every P is Q ∴ Some P is Q)",
            conjunctionElimination: "Simplification (P and Q ∴ P, Q)",
            doubleNegationElimination:
              "Double Negation Elimination (P is false is false ∴ P)",
            assumptionBased: "Assumption-Based Rules",
            conditionalIntroduction:
              "Conditional Introduction (Assume P, derive Q ∴ P then Q)",
            reductioAdAbsurdum:
              "Reductio ad Absurdum (Assume P, derive contradiction ∴ P is false)",
            advanced: "Advanced Rules",
            proofByCases: "Proof by Cases (P or Q, P then R, Q then R ∴ R)",
          },
          alerts: {
            invalidCard: "This card cannot be played here.",
            incompleteProposition:
              "The proposition is incomplete or could not be parsed.",
            duplicateProposition: "The same proposition already exists.",
            contradictionFound:
              "Contradiction found!<br>This proposition is not compatible with the set of true propositions.",
            undoLastCard: "Reverted the last played card.",
            undoLastProposition: "Reverted the last completed proposition.",
            nothingToUndo: "There are no completed propositions to undo.",
            roundEndNoMoves:
              "Player '{player}' has no valid moves. Entering thinking time.",
            criticalErrorUndo:
              "A critical error occurred while rebuilding the truth set. You may need to restart the game.",
            oneAssumptionOnly: "You can only have one assumption at a time.",
            parsingFailed:
              "Could not parse the proposition. Please check the format.",
            premiseNeededForIntro:
              "For Conditional Introduction, you must select exactly one conclusion derived from the assumption.",
            assumptionNeededForIntro:
              "You must make an assumption first to use Conditional Introduction.",
            premiseNotFromAssumption:
              "The selected proposition does not depend on the current assumption.",
            premiseCountError: "This rule requires {count} premises.",
            contradictionNeededForRAA:
              "Reductio ad Absurdum requires 2 contradictory premises.",
            assumptionNeededForRAA:
              "You must make an assumption first to use Reductio ad Absurdum.",
            notAContradiction: "The selected premises are not a contradiction.",
            ruleFailed: "Failed to apply the rule. Please check your premises.",
            noTheoremsToAdd: "There are no new, non-dependent theorems to add.",
            proofIncomplete:
              "Proof incomplete.\nYou must derive your victory [{myGoal}] or your opponent's defeat [{opponentGoal}].",
            oneCardPerTurn: "You can only play one card per turn.",
            aiEurekaDeclared: "AI has declared 'Eureka!'",
            selectOneTheoremOnly: "You must select exactly one final theorem.",
            wittgensteinSuccess:
              "The new theorem has been added, and the premises used for its proof have been deleted.",
            kantSuccess: "A new proposition has been added to the true list!",
            confirmCloseEureka:
              "Eureka! can only be declared once per round.<br>Are you sure you want to close this window?",
            confirmExit: "Are you sure you want to exit?",
            tutorialVictory:
              "Well done!<br>Now, engage in a battle of wits and prove your wisdom!",
            puzzleCleared: "Congratulations! You cleared the puzzle!",
            confirmDeclareEureka:
              "Eureka! can only be declared once per round.<br>Do you want to proceed?",
          },
          keywords: {
            if: "then",
            and: "and",
            or: "or",
            not: "is false",
            wins: "wins",
            socrates: "Socrates",
            plato: "Plato",
            universal_q: "Every",
            existential_q: "Some",
          },
          cards: [
            { type: "Quantifier", text: "Some" },
            { type: "Quantifier", text: "Every" },
            { type: "Operator", text: "then" },
            { type: "Operator", text: "and" },
            { type: "Operator", text: "or" },
            { type: "Operator", text: "is false" },
            { type: "Entity", text: "bird" },
            { type: "Entity", text: "fish" },
            { type: "Entity", text: "dog" },
            { type: "Proper Noun", text: "Socrates" },
            { type: "Proper Noun", text: "Plato" },
            { type: "Predicate", text: "is good" },
            { type: "Predicate", text: "is evil" },
            { type: "Predicate", text: "is wise" },
            { type: "Predicate", text: "is foolish" },
            { type: "Predicate", text: "is a bird" },
            { type: "Predicate", text: "is a fish" },
            { type: "Predicate", text: "is a dog" },
            { type: "Predicate", text: "wins" },
          ],
          cardTypes: [
            "Proper Noun",
            "Quantifier",
            "Entity",
            "Predicate",
            "Operator",
          ],
          axiom_templates: {
            identity: [
              "Some bird is a bird",
              "Every bird is a bird",
              "Some fish is a fish",
              "Every fish is a fish",
              "Some dog is a dog",
              "Every dog is a dog",
            ],
            subject_good_evil: [
              "{S} is good or {S} is evil",
              "{S} is good then {S} is evil is false",
            ],
            subject_wise_foolish: [
              "{S} is wise or {S} is foolish",
              "{S} is wise then {S} is foolish is false",
            ],
            bird_good_evil_forward: [
              "Every bird is good then Some bird is evil is false",
              "Every bird is evil then Some bird is good is false",
              "Every bird is wise then Some bird is foolish is false",
              "Every bird is foolish then Some bird is wise is false",
            ],
            bird_good_evil_reverse: [
              "Some bird is good is false then Every bird is evil",
              "Some bird is evil is false then Every bird is good",
              "Some bird is wise is false then Every bird is foolish",
              "Some bird is foolish is false then Every bird is wise",
            ],
            fish_good_evil_forward: [
              "Every fish is good then Some fish is evil is false",
              "Every fish is evil then Some fish is good is false",
              "Every fish is wise then Some fish is foolish is false",
              "Every fish is foolish then Some fish is wise is false",
            ],
            fish_good_evil_reverse: [
              "Some fish is good is false then Every fish is evil",
              "Some fish is evil is false then Every fish is good",
              "Some fish is wise is false then Every fish is foolish",
              "Some fish is foolish is false then Every fish is wise",
            ],
            dog_good_evil_forward: [
              "Every dog is good then Some dog is evil is false",
              "Every dog is evil then Some dog is good is false",
              "Every dog is wise then Some dog is foolish is false",
              "Every dog is foolish then Some dog is wise is false",
            ],
            dog_good_evil_reverse: [
              "Some dog is good is false then Every dog is evil",
              "Some dog is evil is false then Every dog is good",
              "Some dog is wise is false then Every dog is foolish",
              "Some dog is foolish is false then Every dog is wise",
            ],
          },
          victoryPredicates: ["is good", "is evil", "is wise", "is foolish"],
          contradictoryPredicates: {
            "is good": "is evil",
            "is wise": "is foolish",
          },
          labels: {
            proposition: "[Prop]",
            axiom: "[Axiom]",
            victory_condition: "[WinCon]",
            theorem: "[Thm]",
            assumption: "[Asmp]",
            ci_theorem: "[CI Thm]",
            raa_theorem: "[RAA Thm]",
            theorem_source: "[Thm] {text} (R{round} Thinking)",
            victory_text: "{owner} Win Condition: {text}",
            plato_ability_source: "{text} (Recollection of Forms)",
            nietzsche_ability_source: "{text} (Eternal Recurrence)",
            wittgenstein_ability_source: "{text} (Kicking Away the Ladder)",
            derrida_ability_source: "{text} (Deconstruction)",
            hume_ability_source: "{text} (Problem of Induction)",
            kuhn_ability_source: "{text} (Paradigm Shift)",
            kant_ability_source: "{text} (Synthetic A Priori Judgment)",
          },
        },
      };

      const PHILOSOPHERS = {
        aristotle: {
          id: "aristotle",
          name: { ko: "아리스토텔레스", en: "Aristotle" },
          cardText: { ko: "아리스토텔레스는", en: "Aristotle" },
          image: {
            p1: "assets/images/ari_p1.png",
            p2: "assets/images/ari_p2.png",
          },
          icon: "assets/images/ari_icon.png",
          skill: {
            ko: "형식 논리학: 특별한 능력은 없습니다. 하지만 이 게임의 모든 매커니즘은 그 덕분에 존재한다는 사실을 기억하세요.",
            en: "Formal Logic: Has no special ability. However, remember. All the mechanisms of this game exist thanks to him.",
          },
        },
        socrates: {
          id: "socrates",
          name: { ko: "소크라테스", en: "Socrates" },
          cardText: { ko: "소크라테스는", en: "Socrates" },
          image: {
            p1: "assets/images/socrat_p1.png",
            p2: "assets/images/socrat_p2.png",
          },
          icon: "assets/images/socra_icon.png",
          skill: {
            ko: "무지의 자각: 게임당 두 번, 사유 시간에 참 명제 목록에서 공리와 승리조건이 아닌 명제를 하나 선택할 수 있습니다. 그 명제는 다음 라운드동안 양 플레이어 모두 논증의 전제로 사용할 수 없습니다.",
            en: "Awareness of Ignorance: Twice per game, during Thinking Time, you may choose one proposition from the list of true propositions that is not an axiom or a win condition. For the next round, that proposition cannot be used as a premise by either player.",
          },
        },
        plato: {
          id: "plato",
          name: { ko: "플라톤", en: "Plato" },
          cardText: { ko: "플라톤은", en: "Plato" },
          image: {
            p1: "assets/images/pl_p1.png",
            p2: "assets/images/pl_p2.png",
          },
          icon: "assets/images/pl_icon.png",
          skill: {
            ko: "이데아 회상: 게임당 한 번, 사유 시간에 모순이 발생하지 않는 선에서 '어떤 A는 B다'에서 '모든 A는 B다'를 도출할 수 있습니다.",
            en: "Recollection of Forms: Once per game, during Thinking Time, you can derive 'Every A is B' from 'Some A is B' as long as no contradiction arises.",
          },
        },
        descartes: {
          id: "descartes",
          name: { ko: "르네 데카르트", en: "René Descartes" },
          cardText: { ko: "데카르트는", en: "Descartes" },
          image: {
            p1: "assets/images/de_p1.png",
            p2: "assets/images/de_p2.png",
          },
          icon: "assets/images/de_icon.png",
          skill: {
            ko: "방법적 회의: 게임당 한 번, 사유 시간에 참 명제 목록에서 공리와 승리조건이 아닌 명제 하나를 삭제할 수 있습니다.",
            en: "Methodic Doubt: Once per game, during Thinking Time, you may delete one proposition from the list of true propositions that is not an axiom or a win condition.",
          },
        },
        hume: {
          id: "hume",
          name: { ko: "데이비드 흄", en: "David Hume" },
          cardText: { ko: "흄은", en: "Hume" },
          image: {
            p1: "assets/images/hu_p1.png",
            p2: "assets/images/hu_p2.png",
          },
          icon: "assets/images/hu_icon.png",
          skill: {
            ko: "귀납의 문제: 게임당 두 번, 사유 시간에 '모든 A는 B다' 하나를 '어떤 A는 B다'로 교체할 수 있습니다.",
            en: "Problem of Induction: Twice per game, during Thinking Time, you may replace an 'Every A is B' proposition with 'Some A is B'.",
          },
        },
        kant: {
          id: "kant",
          name: { ko: "임마누엘 칸트", en: "Immanuel Kant" },
          cardText: { ko: "칸트는", en: "Kant" },
          image: {
            p1: "assets/images/ka_p1.png",
            p2: "assets/images/ka_p2.png",
          },
          icon: "assets/images/ka_icon.png",
          skill: {
            ko: "선험적 종합판단: 게임당 한 번, 사유 시간에 사용할 수 있습니다. 모순이 발생하지 않는 선에서, 손에 남아있는 카드로 명제 하나를 만들어 참 명제 목록에 추가합니다.",
            en: "Synthetic A Priori Judgment: Once per game, during Thinking Time, you may create one proposition using cards remaining in your hand and add it to the list of true propositions, as long as no contradiction arises.",
          },
        },
        nietzsche: {
          id: "nietzsche",
          name: { ko: "프리드리히 니체", en: "Friedrich Nietzsche" },
          cardText: { ko: "니체는", en: "Nietzsche" },
          image: {
            p1: "assets/images/ni_p1.png",
            p2: "assets/images/ni_p2.png",
          },
          icon: "assets/images/ni_icon.png",
          skill: {
            ko: "영원 회귀: 참 명제 목록에 존재하는 명제를 무제한으로 중복해서 완성할 수 있습니다.",
            en: "Eternal Recurrence: You can complete propositions that already exist in the list of true propositions an unlimited number of times.",
          },
        },
        marx: {
          id: "marx",
          name: { ko: "카를 마르크스", en: "Karl Marx" },
          cardText: { ko: "마르크스는", en: "Marx" },
          image: {
            p1: "assets/images/ma_p1.png",
            p2: "assets/images/ma_p2.png",
          },
          icon: "assets/images/ma_icon.png",
          skill: {
            ko: "프롤레타리아 혁명: 게임 시작 시, 양 플레이어의 손에 '브루주아는' 개체 카드가 추가되며, 참 명제 목록에 '((모든 브루주아는 악하다) 라면 (혁명이 일어난다)) 그리고 ((혁명이 일어난다) 라면 (마르크스는 승리한다))'라는 승리 조건 명제와 브루주아에 관한 공리가 추가됩니다.",
            en: "Proletarian Revolution: At the start of the game, a 'Bourgeois' entity card is added to both players' hands. A victory condition, '((Every Bourgeois is evil) then (a revolution occurs)) and ((a revolution occurs) then (Marx wins))' and axioms about Bourgeois are added to the list of true propositions.",
          },
        },
        wittgenstein: {
          id: "wittgenstein",
          name: { ko: "루트비히 비트겐슈타인", en: "Ludwig Wittgenstein" },
          cardText: { ko: "비트겐슈타인은", en: "Wittgenstein" },
          image: {
            p1: "assets/images/wi_p1.png",
            p2: "assets/images/wi_p2.png",
          },
          icon: "assets/images/wi_icon.png",
          skill: {
            ko: "사다리 걷어차기: 게임당 한 번, 사유 시간에 사용할 수 있습니다. 추론 규칙들을 사용해 하나의 정리를 도출하고, 사용한 전제들중 공리와 승리 조건을 제외한 명제를 모두 삭제합니다.",
            en: "Kicking Away the Ladder: Once per game, during Thinking Time, you may derive one theorem using inference rules. Then, delete all premises used in the derivation, except for axioms and win conditions.",
          },
        },
        kuhn: {
          id: "kuhn",
          name: { ko: "토마스 쿤", en: "Thomas Kuhn" },
          cardText: { ko: "쿤은", en: "Kuhn" },
          image: {
            p1: "assets/images/ku_p1.png",
            p2: "assets/images/ku_p2.png",
          },
          icon: "assets/images/ku_icon.png",
          skill: {
            ko: "패러다임 전환: 게임당 한 번, 플레이어들이 카드를 놓아 생성한 참 명제가 15개 이상일 때 사용할 수 있습니다. 사유시간에 '모든 A는 선하다/악하다' 혹은 '모든 A는 지혜롭다/어리석다' 명제 하나의 술어를 반대로 바꾸고, 그 명제와 모순되는 명제를 모두 삭제합니다.",
            en: "Paradigm Shift: Once per game, when 15 or more true propositions have been created by players, during Thinking Time, you may take a universal proposition like 'Every A is good' or 'Every A is wise', change its predicate to the opposite (e.g., 'is evil' or 'is foolish'), and then delete all propositions that contradict this new paradigm.",
          },
        },
        derrida: {
          id: "derrida",
          name: { ko: "자크 데리다", en: "Jacques Derrida" },
          cardText: { ko: "데리다는", en: "Derrida" },
          image: {
            p1: "assets/images/der_p1.png",
            p2: "assets/images/der_p2.png",
          },
          icon: "assets/images/der_icon.png",
          skill: {
            ko: "해체: 게임당 한 번, 사유 시간에 사용할 수 있습니다. 공리와 승리조건이 아니며, 연결사로 이어진 명제 하나를 모순이 일어나지 않는 선에서 최소단위 명제 두 개로 분해할 수 있습니다.",
            en: "Deconstruction: Once per game, during Thinking Time, you may choose one non-axiom, non-victory-condition proposition connected by a logical operator, and decompose it into two atomic propositions, as long as no contradiction aeises.",
          },
        },
      };

      const PUZZLES = {
        1: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "어떤 개는 악하다 라면 소크라테스는 지혜롭다",
              "소크라테스는 개이다 그리고 플라톤은 물고기이다",
              "어떤 물고기는 어리석다 라면 어떤 개는 지혜롭다",
              "모든 개는 어리석다",
            ],
            en: [
              "(Some dog is evil) then (Socrates is wise)",
              "(Socrates is a dog) and (Plato is a fish)",
              "(Some fish is foolish) then (Some dog is wise)",
              "Every dog is foolish",
            ],
          },
        },
        2: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "어떤 개는 지혜롭다 라면 소크라테스는 선하다",
              "어떤 개는 어리석다 라면 소크라테스는 선하다",
            ],
            en: [
              "(Some dog is wise) then (Socrates is good)",
              "(Some dog is foolish) then (Socrates is good)",
            ],
          },
        },
        3: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "모든 새는 개이다",
              "모든 개는 물고기이다",
              "모든 물고기는 선하다",
              "소크라테스는 새이다 또는 어떤 개는 악하다",
            ],
            en: [
              "Every bird is a dog",
              "Every dog is a fish",
              "Every fish is good",
              "(Socrates is a bird) or (Some dog is evil)",
            ],
          },
        },
        4: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "소크라테스는 악하다 라면 플라톤은 개이다",
              "모든 개는 선하다",
              "플라톤은 악하다",
            ],
            en: [
              "(Socrates is evil) then (Plato is a dog)",
              "Every dog is good",
              "Plato is evil",
            ],
          },
        },
        5: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: ["플라톤은 지혜롭다 또는 플라톤은 지혜롭다"],
            en: ["(Plato is wise) or (Plato is wise)"],
          },
        },
        6: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "플라톤은 새이다",
              "플라톤은 개이다",
              "플라톤은 물고기이다",
              "모든 새는 어리석다 라면 모든 개는 지혜롭다",
              "모든 개는 어리석다 라면 모든 물고기는 지혜롭다",
              "모든 물고기는 어리석다 라면 모든 새는 지혜롭다",
              "모든 새는 어리석다 또는 모든 개는 지혜롭다",
              "모든 개는 어리석다 또는 모든 물고기는 지혜롭다",
              "모든 물고기는 어리석다 또는 모든 새는 지혜롭다",
            ],
            en: [
              "Plato is a bird",
              "Plato is a dog",
              "Plato is a fish",
              "(Every bird is foolish) then (Every dog is wise)",
              "(Every dog is foolish) then (Every fish is wise)",
              "(Every fish is foolish) then (Every bird is wise)",
              "(Every bird is foolish) or (Every dog is wise)",
              "(Every dog is foolish) or (Every fish is wise)",
              "(Every fish is foolish) or (Every bird is wise)",
            ],
          },
        },
        7: {
          goalDescription: {
            ko: "당신의 승리 <strong>[소크라테스는 승리한다]</strong>나 상대의 패배 <strong>[플라톤은 승리한다 는 거짓이다]</strong>를 증명하세요.",
            en: "Prove your victory, <strong>[Socrates wins]</strong> or opponent's defeat <strong>[Plato wins is false]</strong>.",
          },
          victoryConditions: {
            socrates: {
              ko: "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)",
              en: "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)",
            },
            plato: {
              ko: "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)",
              en: "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)",
            },
          },
          premises: {
            ko: [
              "플라톤은 지혜롭다 또는 모든 개는 어리석다",
              "모든 개는 지혜롭다 는 거짓이다 라면 소크라테스는 선하다",
              "플라톤은 지혜롭다 라면 소크라테스는 물고기이다",
              "어떤 물고기는 악하다 는 거짓이다",
            ],
            en: [
              "(Plato is wise) or (Every dog is foolish)",
              "(Every dog is wise) is false then (Socrates is good)",
              "(Plato is wise) then (Socrates is a fish)",
              "Some fish is evil is false",
            ],
          },
        },
      };

      // --- GLOBAL STATE ---

      document
        .getElementById("vs-ai-test-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return;
          isTestMode = true;
          audioManager.fadeOut("main-menu");
          audioManager.play("character-select");
          startCharacterSelection("AI");
        });
      let bgmVolume = 0.4; // 배경음악 기본 볼륨 40%
      let sfxVolume = 0.6; // 효과음 기본 볼륨 100%
      let currentLang;
      let currentPuzzleLevel = null;
      let isPlayerAI = { A: false, B: false };
      let fullDeck, cardTypeOrder;
      let playerA_Hand = [],
        playerB_Hand = [];
      let truePropositions = [];
      let parsedAxioms = [];
      let currentProposition = [];
      let currentPlayer = "A";
      let propositionStarter = "A";
      let gameIsOver = false;
      let currentRound = 1;
      let isThinkingTime = false;
      let lastPropositionMaker = null;
      let internalTruthSet = [];
      let derivedPropositionsInModal = [];
      let currentAssumption = null;
      let lastCardPlayer = null;
      let cardsPlayedThisTurn = { A: 0, B: 0 };
      let eurekaUsedInRound = { A: false, B: false };
      let thinkingTimeTurn = null;
      let abilityUsedState = {};
      let socratesDisabledProps = [];
      let kantProposition = [];

      const audioContext = new (window.AudioContext ||
        window.webkitAudioContext)();

      // 모든 오디오 트랙을 관리하는 중앙 관리자
      const audioManager = {
        tracks: {
          bgm: {
            // 1. BGM을 위한 하위 객체로 묶습니다.
            "main-menu": {
              url: "assets/sounds/main_theme.flac",
              loopStart: 0.0,
              loopEnd: 0.0,
            },
            "character-select": {
              url: "assets/sounds/char_select_theme.flac",
              loopStart: 0.333,
              loopEnd: 32.333,
            },
            "game-play": {
              url: "assets/sounds/game_music.wav",
              loopStart: 0.0,
              loopEnd: 61.091,
            },
            "thinking-time": {
              url: "assets/sounds/thinking_music.wav",
              loopStart: 0.0,
              loopEnd: 0.0,
            },
            "puzzle-theme": {
              url: "assets/sounds/puzzle.wav",
              loopStart: 0.0,
              loopEnd: 0.0,
            },
          },
          sfx: {
            // 2. SFX를 위한 하위 객체를 새로 추가합니다.
            hover: "assets/sounds/hover.ogg",
            playCard: "assets/sounds/play_card.flac",
            complete: "assets/sounds/complete.ogg",
            pop: "assets/sounds/pop.ogg",
            undo: "assets/sounds/undo.flac",
            end: "assets/sounds/end.wav",
            eureka: "assets/sounds/eureka.wav",
            victory: "assets/sounds/victory.wav",
          },
        },
        buffers: {},
        sourceNodes: {},
        gainNodes: {},
        sfxGainNode: null, // 3. SFX 전용 볼륨 조절 노드를 추가합니다.

        async init() {
          // BGM용 Gain Node 생성
          for (const key in this.tracks.bgm) {
            const gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            this.gainNodes[key] = gainNode;
          }
          // SFX용 Gain Node 생성
          this.sfxGainNode = audioContext.createGain();
          this.sfxGainNode.connect(audioContext.destination);

          // 모든 BGM과 SFX 로드
          const loadPromises = [];
          for (const key in this.tracks.bgm) {
            loadPromises.push(this._loadTrack(key, this.tracks.bgm[key].url));
          }
          for (const key in this.tracks.sfx) {
            loadPromises.push(this._loadTrack(key, this.tracks.sfx[key]));
          }
          await Promise.all(loadPromises); // 모든 로딩이 끝날 때까지 기다림
          console.log("모든 오디오 트랙이 준비되었습니다.");
        },
        async _loadTrack(key, url) {
          // key 인자 추가
          try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            this.buffers[key] = await audioContext.decodeAudioData(arrayBuffer); // key를 사용해 버퍼에 저장
          } catch (error) {
            console.error(`오디오 로드 실패: ${url}`, error);
          }
        },

        play(key, volume = 0.5) {
          if (audioContext.state === "suspended") {
            audioContext.resume();
          }

          this.stop(key); // 기존에 재생중인 같은 트랙이 있으면 중지

          const buffer = this.buffers[key];
          if (!buffer) return;

          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.loop = true;
          const trackData = this.tracks.bgm[key];
          source.loopStart = trackData.loopStart || 0.0;

          // loopEnd 값이 유효하게 설정되어 있으면 그 값을 사용하고, 아니면 파일 전체 길이를 사용합니다.
          if (trackData.loopEnd && trackData.loopEnd > 0) {
            source.loopEnd = trackData.loopEnd;
          } else {
            source.loopEnd = buffer.duration; // buffer.duration이 파일의 전체 길이입니다.
          }

          const gainNode = this.gainNodes[key];
          source.connect(gainNode);

          // 페이드 인 효과
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(
            bgmVolume, // 기존: volume
            audioContext.currentTime + 1.5
          );

          source.start(0);
          this.sourceNodes[key] = source;
        },

        fadeOut(key, duration = 1.5) {
          const gainNode = this.gainNodes[key];
          const sourceNode = this.sourceNodes[key];

          // gainNode와 현재 재생 중인 sourceNode가 모두 있을 때만 실행
          if (gainNode && sourceNode) {
            gainNode.gain.linearRampToValueAtTime(
              0.001,
              audioContext.currentTime + duration
            );

            // 볼륨이 모두 줄어드는 시간(duration)이 지난 후에 stop 함수를 호출합니다.
            setTimeout(() => {
              this.stop(key);
            }, duration * 1000); // duration은 초(sec) 단위이므로 1000을 곱해 ms로 변환
          }
        },

        setVolume(volume) {
          // gainNodes 객체에 있는 모든 게인 노드를 순회
          for (const key in this.gainNodes) {
            const gainNode = this.gainNodes[key];
            if (gainNode) {
              // linearRampToValueAtTime을 사용해 부드럽게 볼륨을 변경
              gainNode.gain.linearRampToValueAtTime(
                volume,
                audioContext.currentTime + 0.1
              );
            }
          }
        },

        stop(key) {
          const source = this.sourceNodes[key];
          if (source) {
            try {
              source.stop(0);
            } catch (e) {}
            delete this.sourceNodes[key];
          }
        },

        stopAll() {
          for (const key in this.sourceNodes) {
            this.stop(key);
          }
        },
        /**
         * 미리 로드된 효과음을 재생합니다. (Non-looping)
         * @param {string} key - 재생할 효과음의 키 (예: "hover", "playCard")
         */
        playSfx(key) {
          if (audioContext.state === "suspended") {
            audioContext.resume();
          }

          const buffer = this.buffers[key];
          if (!buffer || !this.sfxGainNode) return;

          // 효과음은 재생할 때마다 새로운 소스 노드를 생성해야 합니다.
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(this.sfxGainNode);
          source.start(0);
        },

        /**
         * 효과음 전체 볼륨을 조절합니다.
         * @param {number} volume - 0.0 ~ 1.0 사이의 볼륨 값
         */
        setSfxVolume(volume) {
          if (this.sfxGainNode) {
            this.sfxGainNode.gain.linearRampToValueAtTime(
              volume,
              audioContext.currentTime + 0.1
            );
          }
        },
      };

      // 게임 시작 전 오디오를 미리 로드하고, 로딩이 끝날 때까지 기다립니다.
      (async () => {
        try {
          await audioManager.init();
          // 오디오 로딩이 성공적으로 완료된 후, 언어 선택 버튼을 활성화하거나
          // 다음 로직을 진행할 수 있습니다. 여기서는 특별한 추가 동작은 필요 없습니다.
          console.log("Audio assets successfully preloaded.");
        } catch (error) {
          console.error("Failed to preload audio assets:", error);
          // 오디오 로딩 실패 시 사용자에게 알림을 띄우는 등의 예외 처리를 할 수 있습니다.
        }
      })();

      let currentAxioms = []; // 현재 게임의 공리를 저장할 배열

      // --- AI Mode State ---
      let gameMode = null;
      let playerCharacter = null;
      let aiPlayer = null;
      let activeGambitPlan = null;

      function getLastName(fullName) {
        if (!fullName) return "";
        const parts = fullName.split(" ");
        return parts[parts.length - 1];
      }

      // --- TUTORIAL STATE ---
      let inTutorialMode = false;
      let inPuzzleMode = false;
      let tutorialStep = 0;
      let tutorialSubStep = 0;
      let temporaryListener = null;

      let selectionMode = null;
      let characterSelectionTurn = null;
      let tempSelections = { p1: null, p2: null };
      let humanPlayerId = null;

      let aiTimeoutId = null;

      function parseTokensToProposition(tokens) {
        if (!tokens || tokens.length === 0) return null;
        if (tokens[0] === "(" && tokens[tokens.length - 1] === ")") {
          let balance = 0;
          let isOuterParens = true;
          for (let i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] === "(") balance++;
            else if (tokens[i] === ")") balance--;
            if (balance === 0) {
              isOuterParens = false;
              break;
            }
          }
          if (isOuterParens) {
            return parseTokensToProposition(tokens.slice(1, -1));
          }
        }
        let balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.if) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conditional", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.or) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "disjunction", left: left, right: right };
          }
        }
        balance = 0;
        for (let i = tokens.length - 1; i >= 0; i--) {
          if (tokens[i] === ")") balance++;
          else if (tokens[i] === "(") balance--;
          if (balance === 0 && tokens[i] === currentLang.keywords.and) {
            const left = parseTokensToProposition(tokens.slice(0, i));
            const right = parseTokensToProposition(tokens.slice(i + 1));
            if (!left || !right) return null;
            return { type: "conjunction", left: left, right: right };
          }
        }
        if (
          tokens.length > 1 &&
          tokens[tokens.length - 1] === currentLang.keywords.not
        ) {
          const prop = parseTokensToProposition(tokens.slice(0, -1));
          if (!prop) return null;
          return { type: "negation", proposition: prop };
        }
        const cardInfo = tokens.map((t) => fullDeck.find((c) => c.text === t));
        if (cardInfo.some((c) => !c)) {
          const [properNoun, quantifier, entity, predicate] =
            currentLang.cardTypes;
          const types = tokens.map((t) => {
            const card = fullDeck.find((c) => c.text === t);
            return card ? card.type : null;
          });
          if (types.length === 2 && types[0] === properNoun) {
            return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
          }
          if (types.length === 3 && types[0] === quantifier) {
            return {
              type:
                tokens[0] === currentLang.keywords.universal_q
                  ? "universal"
                  : "existential",
              entity: tokens[1],
              predicate: tokens[2],
            };
          }
          return null;
        }
        const types = cardInfo.map((c) => c.type);
        const [properNoun, quantifier, entity, predicate] =
          currentLang.cardTypes;
        if (types.length === 2 && types[0] === properNoun) {
          return { type: "atomic", subject: tokens[0], predicate: tokens[1] };
        }
        if (types.length === 3 && types[0] === quantifier) {
          return {
            type:
              tokens[0] === currentLang.keywords.universal_q
                ? "universal"
                : "existential",
            entity: tokens[1],
            predicate: tokens[2],
          };
        }
        return null;
      }

      function parsePropositionFromString(str) {
        const allKeywords = [...fullDeck.map((c) => c.text), "(", ")"].sort(
          (a, b) => b.length - a.length
        );
        let tempStr = str.trim();
        const tokens = [];
        while (tempStr.length > 0) {
          const foundToken = allKeywords.find((k) => tempStr.startsWith(k));
          if (foundToken) {
            tokens.push(foundToken);
            tempStr = tempStr.substring(foundToken.length).trim();
          } else {
            console.error(
              "Tokenizer failed for string:",
              str,
              "at substring:",
              tempStr
            );
            return null;
          }
        }
        return parseTokensToProposition(tokens);
      }

      function parsePropositionFromCards(propInfoArray) {
        if (!propInfoArray || propInfoArray.length === 0) return null;
        const tokens = propInfoArray.map((info) => info.card.text);
        return parseTokensToProposition(tokens);
      }

      function arePropositionsEqual(prop1, prop2) {
        if (!prop1 || !prop2 || prop1.type !== prop2.type) return false;
        switch (prop1.type) {
          case "atomic":
            return (
              prop1.subject === prop2.subject &&
              prop1.predicate === prop2.predicate
            );
          case "universal":
          case "existential":
            return (
              prop1.entity === prop2.entity &&
              prop1.predicate === prop2.predicate
            );
          case "negation":
            return arePropositionsEqual(prop1.proposition, prop2.proposition);
          case "conjunction":
          case "disjunction":
          case "conditional":
            return (
              arePropositionsEqual(prop1.left, prop2.left) &&
              arePropositionsEqual(prop1.right, prop2.right)
            );
          default:
            return false;
        }
      }

      function propositionToText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation":
            return `~(${propositionToText(prop.proposition)})`;
          case "conjunction":
            return `(${propositionToText(prop.left)}) ∧ (${propositionToText(
              prop.right
            )})`;
          case "disjunction":
            return `(${propositionToText(prop.left)}) ∨ (${propositionToText(
              prop.right
            )})`;
          case "conditional":
            return `(${propositionToText(prop.left)}) → (${propositionToText(
              prop.right
            )})`;
          default:
            return "Unknown Proposition";
        }
      }

      function propositionToNaturalText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;
          case "negation": {
            const innerProp = prop.proposition;
            const innerText = propositionToNaturalText(innerProp);
            const notKeyword = `<span class="op-not">${currentLang.keywords.not}</span>`;

            // 핵심 수정 1: 부정 대상이 단일 명제(atomic, universal, existential)일 때만 괄호로 감쌉니다.
            if (
              innerProp.type === "atomic" ||
              innerProp.type === "universal" ||
              innerProp.type === "existential"
            ) {
              return `(${innerText}) ${notKeyword}`;
            }

            // 그 외 (이미 괄호가 있는 복합 명제나 또 다른 부정문)는 그대로 텍스트를 이어붙입니다.
            return `${innerText} ${notKeyword}`;
          }
          case "conjunction": {
            const leftProp = prop.left;
            const rightProp = prop.right;
            let leftText = propositionToNaturalText(leftProp);
            let rightText = propositionToNaturalText(rightProp);

            // 핵심 수정 2: 자식 노드가 부정문이 아닐 경우에만 괄호로 감쌉니다.
            if (leftProp.type !== "negation") {
              leftText = `(${leftText})`;
            }
            if (rightProp.type !== "negation") {
              rightText = `(${rightText})`;
            }

            const andKeyword = `<span class="op-and">${currentLang.keywords.and}</span>`;
            return `${leftText} ${andKeyword} ${rightText}`;
          }
          case "disjunction": {
            const leftProp = prop.left;
            const rightProp = prop.right;
            let leftText = propositionToNaturalText(leftProp);
            let rightText = propositionToNaturalText(rightProp);

            // 핵심 수정 2: 자식 노드가 부정문이 아닐 경우에만 괄호로 감쌉니다.
            if (leftProp.type !== "negation") {
              leftText = `(${leftText})`;
            }
            if (rightProp.type !== "negation") {
              rightText = `(${rightText})`;
            }

            const orKeyword = `<span class="op-or">${currentLang.keywords.or}</span>`;
            return `${leftText} ${orKeyword} ${rightText}`;
          }
          case "conditional": {
            const leftProp = prop.left;
            const rightProp = prop.right;
            let leftText = propositionToNaturalText(leftProp);
            let rightText = propositionToNaturalText(rightProp);

            // 핵심 수정 2: 자식 노드가 부정문이 아닐 경우에만 괄호로 감쌉니다.
            if (leftProp.type !== "negation") {
              leftText = `(${leftText})`;
            }
            if (rightProp.type !== "negation") {
              rightText = `(${rightText})`;
            }

            const ifKeyword = `<span class="op-if">${currentLang.keywords.if}</span>`;
            return `${leftText} ${ifKeyword} ${rightText}`;
          }
          default:
            return "Unknown Proposition";
        }
      }

      function propositionToPlainText(prop) {
        if (!prop) return "";
        switch (prop.type) {
          case "atomic":
            return `${prop.subject} ${prop.predicate}`;
          case "universal":
            return `${currentLang.keywords.universal_q} ${prop.entity} ${prop.predicate}`;
          case "existential":
            return `${currentLang.keywords.existential_q} ${prop.entity} ${prop.predicate}`;

          case "negation": {
            const innerProp = prop.proposition;
            const innerText = propositionToPlainText(innerProp); // 재귀 호출 시에도 새 함수 사용
            const notKeyword = currentLang.keywords.not;
            if (
              innerProp.type === "conjunction" ||
              innerProp.type === "disjunction" ||
              innerProp.type === "conditional"
            ) {
              return `(${innerText}) ${notKeyword}`;
            }
            return `${innerText} ${notKeyword}`;
          }

          case "conjunction": {
            let leftText;
            if (prop.left.type === "negation") {
              const innerText = propositionToPlainText(prop.left.proposition);
              leftText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              leftText = `(${propositionToPlainText(prop.left)})`;
            }

            let rightText;
            if (prop.right.type === "negation") {
              const innerText = propositionToPlainText(prop.right.proposition);
              rightText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              rightText = `(${propositionToPlainText(prop.right)})`;
            }

            const andKeyword = currentLang.keywords.and;
            return `${leftText} ${andKeyword} ${rightText}`;
          }

          case "disjunction": {
            let leftText;
            if (prop.left.type === "negation") {
              const innerText = propositionToPlainText(prop.left.proposition);
              leftText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              leftText = `(${propositionToPlainText(prop.left)})`;
            }

            let rightText;
            if (prop.right.type === "negation") {
              const innerText = propositionToPlainText(prop.right.proposition);
              rightText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              rightText = `(${propositionToPlainText(prop.right)})`;
            }

            const orKeyword = currentLang.keywords.or;
            return `${leftText} ${orKeyword} ${rightText}`;
          }

          case "conditional": {
            let leftText;
            if (prop.left.type === "negation") {
              const innerText = propositionToPlainText(prop.left.proposition);
              leftText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              leftText = `(${propositionToPlainText(prop.left)})`;
            }

            let rightText;
            if (prop.right.type === "negation") {
              const innerText = propositionToPlainText(prop.right.proposition);
              rightText = `(${innerText}) ${currentLang.keywords.not}`;
            } else {
              rightText = `(${propositionToPlainText(prop.right)})`;
            }

            const ifKeyword = currentLang.keywords.if;
            return `${leftText} ${ifKeyword} ${rightText}`;
          }

          default:
            return "Unknown Proposition";
        }
      }

      function initializeGame(lang) {
        currentLang = TEXTS[lang];
        document.documentElement.lang = currentLang.langCode;
        document.title = currentLang.ui.title;

        fullDeck = currentLang.cards;
        cardTypeOrder = currentLang.cardTypes;

        document.getElementById("language-modal").classList.remove("visible");
        setupUI();
        setupModeDescriptionHovers();
        loadSettings();
        showMainMenu();
        addGlobalSoundEvents();
      }

      function showMainMenu() {
        // 새로운 오디오 시스템을 사용하도록 수정
        audioManager.stopAll();
        audioManager.play("main-menu"); // 볼륨 60%로 메인 메뉴 음악 재생

        document
          .getElementById("thinking-time-controls")
          .classList.add("hidden");
        document
          .getElementById("character-select-indicator")
          .classList.add("hidden");
        document.getElementById("container").classList.add("ready");
        document.querySelector(".main-center-bg").classList.remove("hidden");
        document.getElementById("credits-btn").classList.remove("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
      }
      function setupModeDescriptionHovers() {
        const descriptionBox = document.getElementById("mode-description");
        if (!descriptionBox) return;

        const buttonsToDescribe = [
          { id: "vs-player-btn", key: "vsPlayerDesc" },
          { id: "vs-ai-btn", key: "vsAIDesc" },
          { id: "tutorial-btn", key: "tutorialDesc" },
          { id: "puzzle-mode-btn", key: "puzzleDesc" },
        ];

        buttonsToDescribe.forEach((buttonInfo) => {
          const buttonEl = document.getElementById(buttonInfo.id);
          if (buttonEl) {
            buttonEl.addEventListener("mouseenter", (e) => {
              // 1. 현재 언어에 맞는 설명 텍스트를 가져와서 내용 변경
              const descText = currentLang.ui[buttonInfo.key];
              descriptionBox.innerHTML = descText;

              // 2. 설명 박스의 Y축 위치를 현재 마우스가 올라간 버튼의 중앙으로 이동
              const buttonCenterY =
                e.target.offsetTop + e.target.offsetHeight / 2;
              descriptionBox.style.top = `${buttonCenterY}px`;

              // 3. 설명 박스를 부드럽게 표시
              descriptionBox.style.opacity = "1";
              descriptionBox.style.visibility = "visible";
            });

            buttonEl.addEventListener("mouseleave", () => {
              // 마우스가 벗어나면 설명 박스를 다시 숨김
              descriptionBox.style.opacity = "0";
              descriptionBox.style.visibility = "hidden";
            });
          }
        });
      }
      function setupUI() {
        document.getElementById("main-menu-btn").textContent =
          currentLang.langCode === "ko" ? "메인으로" : "Main Menu";

        document.getElementById("main-title").textContent =
          currentLang.ui.title;
        document.getElementById("new-game-btn").textContent =
          currentLang.ui.newGameButton;
        document.getElementById("vs-ai-btn").textContent =
          currentLang.ui.vsAIButton;
        document.getElementById("vs-player-btn").textContent =
          currentLang.ui.vsPlayerButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;
        document.getElementById("exit-game-btn").textContent =
          currentLang.ui.exitGameButton;
        document.getElementById("vs-ai-battle-btn").textContent =
          currentLang.ui.vsAIBattleButton;
        document.getElementById(
          "player-a-title"
        ).innerHTML = `${currentLang.ui.playerAName} - ${currentLang.ui.playerAColor}`;
        document.getElementById(
          "player-b-title"
        ).innerHTML = `${currentLang.ui.playerBName} - ${currentLang.ui.playerBColor}`;
        document.getElementById("eureka-a").textContent =
          currentLang.ui.eurekaButton;
        document.getElementById("eureka-b").textContent =
          currentLang.ui.eurekaButton;
        document
          .getElementById("ability-a")
          .addEventListener("click", () => activateAbility("A"));
        document
          .getElementById("ability-b")
          .addEventListener("click", () => activateAbility("B"));
        document.getElementById("current-proposition-title").textContent =
          currentLang.ui.currentPropositionTitle;
        document.getElementById("complete-btn").textContent =
          currentLang.ui.completeButton;
        document.getElementById("undo-btn").textContent =
          currentLang.ui.undoButton;
        document.getElementById("end-turn-btn").textContent =
          currentLang.ui.endTurnButton;
        document.getElementById("true-propositions-title").textContent =
          currentLang.ui.truePropositionsTitle;
        document.getElementById("thinking-time-title").textContent =
          currentLang.ui.thinkingTimeTitle;
        document.getElementById("thinking-time-desc").innerHTML =
          currentLang.ui.thinkingTimeDesc;
        document.getElementById("fullscreen-btn").textContent =
          currentLang.ui.fullscreenButton;
        document.getElementById("settings-btn").textContent =
          currentLang.ui.settingsButton;
        document.getElementById("tutorial-btn").textContent =
          currentLang.ui.tutorialButton;
        document.getElementById("tutorial-puzzle-btn").textContent =
          currentLang.ui.tutorialPuzzleButton;

        document.getElementById("puzzle-mode-btn").textContent =
          currentLang.ui.puzzleButton;
        document.getElementById("puzzle-modal-title").textContent =
          currentLang.modals.puzzleTitle;

        document.getElementById("tutorial-modal-title").textContent =
          currentLang.modals.tutorialTitle;
        document.getElementById("alert-ok-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("credits-btn").textContent =
          currentLang.ui.creditsButton;
        document.getElementById("credits-title").textContent =
          currentLang.modals.creditsTitle;
        document.getElementById("prompt-cancel-btn").textContent =
          currentLang.ui.cancelButton;
        document.getElementById("prompt-confirm-btn").textContent =
          currentLang.ui.okButton;
        document.getElementById("prompt-input").placeholder =
          currentLang.modals.promptInputPlaceholder;

        document.getElementById("p1-skill-title").textContent =
          currentLang.ui.skillTitle;
        document.getElementById("p2-skill-title").textContent =
          currentLang.ui.skillTitle;

        document.getElementById("premise-selection-title").textContent =
          currentLang.modals.premiseSelectionTitle;
        document.getElementById("apply-rule-btn").textContent =
          currentLang.modals.applyRuleButton;
        document.getElementById("add-assumption-btn").textContent =
          currentLang.modals.addAssumptionButton;
        document.getElementById("cancel-assumption-btn").textContent =
          currentLang.ui.cancelAssumptionButton;

        document.getElementById("settings-title").textContent =
          currentLang.ui.settingsTitle;
        document.getElementById("bgm-label").textContent =
          currentLang.ui.bgmLabel;
        document.getElementById("sfx-label").textContent =
          currentLang.ui.sfxLabel;

        const select = document.getElementById("inference-rule-select");
        select.innerHTML = `
                  <optgroup label="${currentLang.inferenceRules.basic}">
                      <option value="modusPonens">${currentLang.inferenceRules.modusPonens}</option>
                      <option value="modusTollens">${currentLang.inferenceRules.modusTollens}</option>
                      <option value="hypotheticalSyllogism">${currentLang.inferenceRules.hypotheticalSyllogism}</option>
                      <option value="disjunctiveSyllogism">${currentLang.inferenceRules.disjunctiveSyllogism}</option>
                      <option value="universalApplication">${currentLang.inferenceRules.universalApplication}</option>
                      <option value="existentialInstantiation">${currentLang.inferenceRules.existentialInstantiation}</option>
                      <option value="conjunctionElimination">${currentLang.inferenceRules.conjunctionElimination}</option>
                      <option value="doubleNegationElimination">${currentLang.inferenceRules.doubleNegationElimination}</option>
                  </optgroup>
                  <optgroup label="${currentLang.inferenceRules.assumptionBased}">
                      <option value="conditionalIntroduction" style="color:#27ae60; font-weight:normal;">${currentLang.inferenceRules.conditionalIntroduction}</option>
                      <option value="reductioAdAbsurdum" style="color:#c0392b; font-weight:normal;">${currentLang.inferenceRules.reductioAdAbsurdum}</option>
                  </optgroup>
                  <optgroup label="${currentLang.inferenceRules.advanced}">
                      <option value="proofByCases" style="color:#2980b9; font-weight:normal;">${currentLang.inferenceRules.proofByCases}</option>
                  </optgroup>
              `;
      }
      document
        .getElementById("vs-ai-battle-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return;
          gameMode = "AI_VS_AI";
          audioManager.fadeOut("main-menu");
          audioManager.play("character-select");
          startCharacterSelection(gameMode);
        });

      document.getElementById("exit-game-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        showConfirm(currentLang.alerts.confirmExit, () => {
          // '예'를 눌렀을 때의 동작
          window.close();
        });
      });

      function generateAxioms(
        subjectA,
        subjectB,
        langData,
        isMarxInGame = false
      ) {
        const templates = langData.axiom_templates;
        const axiomGroups = {
          identity: [...templates.identity],
          subjectOpposition: [],
          quantifierOpposition: [],
        };

        // 마르크스 정체성 공리 추가
        if (isMarxInGame) {
          if (langData.langCode === "ko") {
            axiomGroups.identity.push("어떤 브루주아는 브루주아이다");
            axiomGroups.identity.push("모든 브루주아는 브루주아이다");
          } else {
            axiomGroups.identity.push("Some Bourgeois is a Bourgeois");
            axiomGroups.identity.push("Every Bourgeois is a Bourgeois");
          }
        }

        // 개체별 속성 대립 공리들
        templates.subject_good_evil.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectA)
          );
        });
        templates.subject_wise_foolish.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectA)
          );
        });
        templates.subject_good_evil.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectB)
          );
        });
        templates.subject_wise_foolish.forEach((template) => {
          axiomGroups.subjectOpposition.push(
            template.replaceAll("{S}", subjectB)
          );
        });

        // 양화사별 속성 대립 공리들
        axiomGroups.quantifierOpposition.push(
          ...templates.bird_good_evil_forward
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.bird_good_evil_reverse
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.fish_good_evil_forward
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.fish_good_evil_reverse
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.dog_good_evil_forward
        );
        axiomGroups.quantifierOpposition.push(
          ...templates.dog_good_evil_reverse
        );

        if (isMarxInGame) {
          let marxBourgeoisAxioms = [];
          if (langData.langCode === "ko") {
            marxBourgeoisAxioms = [
              // 속성의 대립 (선/악)
              "모든 브루주아는 선하다 라면 어떤 브루주아는 악하다 는 거짓이다",
              "모든 브루주아는 악하다 라면 어떤 브루주아는 선하다 는 거짓이다",
              "어떤 브루주아는 선하다 는 거짓이다 라면 모든 브루주아는 악하다",
              "어떤 브루주아는 악하다 는 거짓이다 라면 모든 브루주아는 선하다",
              // 속성의 대립 (지혜/어리석음)
              "모든 브루주아는 지혜롭다 라면 어떤 브루주아는 어리석다 는 거짓이다",
              "모든 브루주아는 어리석다 라면 어떤 브루주아는 지혜롭다 는 거짓이다",
              "어떤 브루주아는 지혜롭다 는 거짓이다 라면 모든 브루주아는 어리석다",
              "어떤 브루주아는 어리석다 는 거짓이다 라면 모든 브루주아는 지혜롭다",
            ];
          } else {
            // langCode === 'en'
            marxBourgeoisAxioms = [
              // Opposition of Predicates (good/evil)
              "Every Bourgeois is good then Some Bourgeois is evil is false",
              "Every Bourgeois is evil then Some Bourgeois is good is false",
              "Some Bourgeois is good is false then Every Bourgeois is evil",
              "Some Bourgeois is evil is false then Every Bourgeois is good",
              // Opposition of Predicates (wise/foolish)
              "Every Bourgeois is wise then Some Bourgeois is foolish is false",
              "Every Bourgeois is foolish then Some Bourgeois is wise is false",
              "Some Bourgeois is wise is false then Every Bourgeois is foolish",
              "Some Bourgeois is foolish is false then Every Bourgeois is wise",
            ];
          }
          axiomGroups.quantifierOpposition.push(...marxBourgeoisAxioms);
        }

        // 하위 호환성을 위해 평면적인 배열로 반환
        const flatAxioms = [
          ...axiomGroups.identity,
          ...axiomGroups.subjectOpposition,
          ...axiomGroups.quantifierOpposition,
        ];

        // 그룹 정보를 속성으로 추가
        flatAxioms.groups = axiomGroups;

        return flatAxioms;
      }
      function getTopicParticle(name) {
        const lastChar = name.charCodeAt(name.length - 1);
        if (lastChar < 0xac00 || lastChar > 0xd7a3) {
          return "는"; // 한글이 아니면 '는'을 기본값으로 반환
        }
        // 받침 유무 확인: (글자코드 - 0xAC00) % 28
        const hasJongseong = (lastChar - 0xac00) % 28 !== 0;
        return hasJongseong ? "은" : "는";
      }

      function setupGame(selectedCharacters, testConfig = null) {
        playerA_Data = PHILOSOPHERS[selectedCharacters.p1];
        playerB_Data = PHILOSOPHERS[selectedCharacters.p2];
        truePropositions = []; // 게임 시작 시 참 명제 목록 초기화

        const p1_id = selectedCharacters.p1;
        const p2_id = selectedCharacters.p2;
        let p1_card_obj, p2_card_obj;
        let subjectA, subjectB;

        subjectA = playerA_Data.cardText[currentLang.langCode];
        subjectB = playerB_Data.cardText[currentLang.langCode];

        // 1. 미러전(동일 철학자 선택) 처리
        if (p1_id === p2_id) {
          if (currentLang.langCode === "ko") {
            const fullName = playerA_Data.name.ko;
            const nameParts = fullName.split(" ");
            const lastName = nameParts[nameParts.length - 1];
            const particle = getTopicParticle(lastName);
            subjectA = `백색 ${lastName}${particle}`;
            subjectB = `흑색 ${lastName}${particle}`;
          } else {
            const fullName = playerA_Data.name.en;
            const nameParts = fullName.split(" ");
            const lastName = nameParts[nameParts.length - 1];
            subjectA = `White ${lastName}`;
            subjectB = `Black ${lastName}`;
          }
          document.getElementById("player-a-title").innerHTML = `⚪️ ${
            playerA_Data.name[currentLang.langCode]
          }(백)`;
          document.getElementById("player-b-title").innerHTML = `⚫️ ${
            playerB_Data.name[currentLang.langCode]
          }(흑)`;
        } else {
          document.getElementById("player-a-title").innerHTML = `⚪️ ${
            playerA_Data.name[currentLang.langCode]
          }`;
          document.getElementById("player-b-title").innerHTML = `⚫️ ${
            playerB_Data.name[currentLang.langCode]
          }`;
        }

        const properNounType =
          currentLang.langCode === "ko" ? "고유명사" : "Proper Noun";
        p1_card_obj = { type: properNounType, text: subjectA };
        p2_card_obj = { type: properNounType, text: subjectB };

        // 2. 게임 덱 구성 (마르크스 카드 포함)
        const masterDeck = currentLang.cards;
        const allPhilosopherCardTexts = Object.values(PHILOSOPHERS).map(
          (p) => p.cardText[currentLang.langCode]
        );
        const baseDeck = masterDeck.filter(
          (card) => !allPhilosopherCardTexts.includes(card.text)
        );

        let currentGameDeck = [...baseDeck, p1_card_obj, p2_card_obj];

        const isMarxInGame = p1_id === "marx" || p2_id === "marx";
        const bourgeoisCard = {
          type: currentLang.langCode === "ko" ? "개체" : "Entity",
          text: currentLang.langCode === "ko" ? "브루주아는" : "Bourgeois",
        };
        const revolutionSubjectCard = {
          type: currentLang.langCode === "ko" ? "고유명사" : "Proper Noun",
          text: currentLang.langCode === "ko" ? "혁명이" : "A revolution",
        };
        const revolutionPredicateCard = {
          type: currentLang.langCode === "ko" ? "서술어" : "Predicate",
          text: currentLang.langCode === "ko" ? "일어난다" : "occurs",
        };

        if (isMarxInGame) {
          currentGameDeck.push(
            bourgeoisCard,
            revolutionSubjectCard,
            revolutionPredicateCard
          );
        }

        fullDeck = currentGameDeck;

        // 3. 손패 분배 (마르크스 플레이 불가능 카드 제거 포함)
        if (testConfig && testConfig.handA) {
          const handATexts = testConfig.handA.split(",").map((s) => s.trim());
          playerA_Hand = handATexts
            .map((text) => fullDeck.find((c) => c.text === text))
            .filter(Boolean);
        } else {
          const nonPlayerCards = ["승리한다", "wins"];
          playerA_Hand = JSON.parse(
            JSON.stringify(
              fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
            )
          );
        }
        if (testConfig && testConfig.handB) {
          const handBTexts = testConfig.handB.split(",").map((s) => s.trim());
          playerB_Hand = handBTexts
            .map((text) => fullDeck.find((c) => c.text === text))
            .filter(Boolean);
        } else {
          const nonPlayerCards = ["승리한다", "wins"];
          playerB_Hand = JSON.parse(
            JSON.stringify(
              fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
            )
          );
        }

        if (isMarxInGame) {
          const unplayableCardTexts = [
            revolutionSubjectCard.text,
            revolutionPredicateCard.text,
          ];
          playerA_Hand = playerA_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          );
          playerB_Hand = playerB_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          );
        }

        // 4. 공리 및 승리 조건 설정
        currentAxioms = generateAxioms(
          subjectA,
          subjectB,
          currentLang,
          isMarxInGame
        );
        parsedAxioms = currentAxioms
          .map((str) => ({
            type: "axiom",
            proposition: parsePropositionFromString(str),
          }))
          .filter((a) => a.proposition);
        internalTruthSet = parsedAxioms.map((a) => a.proposition);

        const { if: ifKeyword, wins, and } = currentLang.keywords;

        const predicateA =
          testConfig?.victoryA ||
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextA = `((${subjectA} ${predicateA}) ${ifKeyword} (${subjectA} ${wins})) ${and} ((${subjectA} ${wins}) ${ifKeyword} (${subjectA} ${predicateA}))`;
        const parsedVictoryA = parsePropositionFromString(victoryTextA);
        truePropositions.push({
          type: "victory",
          text: victoryTextA,
          owner: "A",
          proposition: parsedVictoryA,
          ultimate_target: {
            type: "atomic",
            subject: subjectA,
            predicate: wins,
          },
          core_goal: {
            type: "atomic",
            subject: subjectA,
            predicate: predicateA,
          },
        });
        if (parsedVictoryA) internalTruthSet.push(parsedVictoryA);

        const predicateB =
          testConfig?.victoryB ||
          currentLang.victoryPredicates[
            Math.floor(Math.random() * currentLang.victoryPredicates.length)
          ];
        const victoryTextB = `((${subjectB} ${predicateB}) ${ifKeyword} (${subjectB} ${wins})) ${and} ((${subjectB} ${wins}) ${ifKeyword} (${subjectB} ${predicateB}))`;
        const parsedVictoryB = parsePropositionFromString(victoryTextB);
        truePropositions.push({
          type: "victory",
          text: victoryTextB,
          owner: "B",
          proposition: parsedVictoryB,
          ultimate_target: {
            type: "atomic",
            subject: subjectB,
            predicate: wins,
          },
          core_goal: {
            type: "atomic",
            subject: subjectB,
            predicate: predicateB,
          },
        });
        if (parsedVictoryB) internalTruthSet.push(parsedVictoryB);

        // 5. 마르크스 특별 승리 조건 추가
        const setupMarxVictory = (player, subject) => {
          const revolutionPropText = `${revolutionSubjectCard.text} ${revolutionPredicateCard.text}`;
          const firstClause = `(${currentLang.keywords.universal_q} ${
            bourgeoisCard.text
          } ${currentLang.langCode === "ko" ? "악하다" : "is evil"})`;
          const secondClause = `(${revolutionPropText})`;
          const thirdClause = `(${subject} ${wins})`;
          const marxVictoryString = `(${firstClause} ${ifKeyword} ${secondClause}) ${and} (${secondClause} ${ifKeyword} ${thirdClause})`;
          const parsedMarxVictory =
            parsePropositionFromString(marxVictoryString);

          if (parsedMarxVictory) {
            truePropositions.push({
              owner: player,
              type: "victory",
              source: "marx_revolution",
              text: propositionToPlainText(parsedMarxVictory),
              proposition: parsedMarxVictory,
              ultimate_target: {
                type: "atomic",
                subject: subject,
                predicate: wins,
              },
              core_goal: {
                type: "atomic",
                subject: revolutionSubjectCard.text,
                predicate: revolutionPredicateCard.text,
              },
            });
            internalTruthSet.push(parsedMarxVictory);
          } else {
            console.error(
              "CRITICAL: Failed to parse Marx's victory string.",
              marxVictoryString
            );
          }
        };

        if (p1_id === "marx") {
          setupMarxVictory("A", subjectA);
        }
        if (p2_id === "marx") {
          setupMarxVictory("B", subjectB);
        }

        // 6. 테스트 모드 초기 참 명제 처리
        if (testConfig && testConfig.trueProps) {
          const propStrings = testConfig.trueProps
            .split(";")
            .map((s) => s.trim())
            .filter(Boolean);
          propStrings.forEach((str) => {
            const parsed = parsePropositionFromString(str);
            if (parsed) {
              const verificationResult = verifyAndExpandTruths(
                parsed,
                internalTruthSet
              );
              if (verificationResult.success) {
                truePropositions.push({
                  propId: `prop_${Date.now()}_${Math.random()}`,
                  type: "user-made",
                  round: 0,
                  proposition: parsed,
                  original_cards: [],
                });
                internalTruthSet = verificationResult.expandedSet;
              } else {
                alert(
                  `입력한 초기 참 명제 "${str}"가 기존 공리 또는 다른 명제와 모순되어 추가할 수 없습니다.`
                );
              }
            } else {
              alert(`입력한 초기 참 명제 "${str}"의 형식이 잘못되었습니다.`);
            }
          });
        }

        // 7. 초상화 및 능력 사용 상태 초기화
        const portraitA_El = document.getElementById("player-a-portrait");
        if (portraitA_El) {
          portraitA_El.style.backgroundImage = `url('${playerA_Data.image.p1}')`;
        }
        const portraitB_El = document.getElementById("player-b-portrait");
        if (portraitB_El) {
          portraitB_El.style.backgroundImage = `url('${playerB_Data.image.p2}')`;
        }

        abilityUsedState = {};

        // 플레이어 A의 능력 상태 설정 (이미 선언된 p1_id 변수 사용)
        if (p1_id === "hume" || p1_id === "socrates") {
          abilityUsedState["A"] = { usedCount: 0, maxUses: 2 };
        } else {
          abilityUsedState["A"] = { used: false };
        }

        // 플레이어 B의 능력 상태 설정 (이미 선언된 p2_id 변수 사용)
        if (p2_id === "hume" || p2_id === "socrates") {
          abilityUsedState["B"] = { usedCount: 0, maxUses: 2 };
        } else {
          abilityUsedState["B"] = { used: false };
        }

        render();
        checkNextTurn();
      }

      function resetGame(selectedCharacters, testConfig = null) {
        audioManager.stop("main-menu");
        audioManager.play("game-play");

        // 만약 선택된 캐릭터 정보가 없다면, 기본값으로 소크라테스와 플라톤을 설정
        if (!selectedCharacters) {
          selectedCharacters = { p1: "socrates", p2: "plato" };
        }

        clearAllAITimeouts();

        socratesDisabledProps = []; // 소크라테스 능력으로 비활성화된 명제 목록 초기화

        playerA_Hand = [];
        playerB_Hand = [];
        truePropositions = [];
        currentProposition = [];
        currentPlayer = "A";
        gameIsOver = false;
        currentRound = 1;
        isThinkingTime = false;

        eurekaUsedInRound = { A: false, B: false };

        cardsPlayedThisTurn = { A: 0, B: 0 };

        document.getElementById("thinking-time-controls").style.display =
          "none";
        document.getElementById("status").innerHTML = "";

        setupGame(selectedCharacters, testConfig);
      }
      // --- EVENT LISTENERS ---
      document.getElementById("lang-en").addEventListener("click", () => {
        // AudioContext가 suspended 상태일 경우 즉시 활성화합니다.
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        initializeGame("en");
      });
      document.getElementById("lang-ko").addEventListener("click", () => {
        // AudioContext가 suspended 상태일 경우 즉시 활성화합니다.
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        initializeGame("ko");
      });
      document.getElementById("new-game-btn").addEventListener("click", () => {
        if (inTutorialMode) return;

        audioManager.fadeOut("game-play");
        audioManager.fadeOut("thinking-time");

        // 현재 게임 모드가 설정되어 있는지 확인
        if (gameMode) {
          clearAllAITimeouts(); // 진행 중인 AI 동작이 있다면 중지
          // 현재 게임 모드로 캐릭터 선택을 다시 시작
          startCharacterSelection(gameMode);
        } else {
          // 혹시 모드가 설정되지 않은 예외적인 경우, 메인 메뉴로 이동
          showMainMenu();
        }
      });

      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // 수정된 부분
        audioManager.fadeOut("main-menu");
        audioManager.play("character-select");
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // 수정된 부분
        audioManager.fadeOut("main-menu");
        audioManager.play("character-select");
        startCharacterSelection("AI");
      });

      // NEW Event Listener for the single confirm button
      document
        .getElementById("confirm-selection-btn")
        .addEventListener("click", handleConfirmClick);

      // Keep other event listeners like those for complete-btn, undo-btn, etc. as they are.

      document
        .getElementById("back-to-main-from-char-select-btn")
        .addEventListener("click", goToMainMenu);

      document.getElementById("complete-btn").addEventListener("click", () => {
        if (!inTutorialMode) completeProposition();
      });
      document.getElementById("undo-btn").addEventListener("click", () => {
        if (!inTutorialMode) undoProposition();
      });
      document
        .getElementById("end-turn-btn")
        .addEventListener("click", (event) => {
          // event 객체를 인자로 받도록 수정
          if (inTutorialMode) return;

          // 이벤트가 document.body로 전파(버블링)되는 것을 막아 범용 클릭음 중복 방지
          event.stopPropagation();

          endTurn(); // 기존 턴 종료 함수 호출
        });
      document.getElementById("eureka-a").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("A");
      });
      document.getElementById("eureka-b").addEventListener("click", () => {
        if (!inTutorialMode) declareEureka("B");
      });
      document
        .getElementById("close-eureka-modal-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return;

          // ▼▼▼ [수정] 아래 두 줄을 추가하여 모달의 내부 상태를 초기화합니다. ▼▼▼
          derivedPropositionsInModal = [];
          currentAssumption = null;
          // ▲▲▲ [수정] 코드 추가 끝 ▲▲▲

          if (inPuzzleMode) {
            document.getElementById("eureka-modal").classList.remove("visible");
            document.getElementById("puzzle-goal-box").classList.add("hidden");
            inPuzzleMode = false;
            populatePuzzleLevels();
            document
              .getElementById("puzzle-level-select-modal")
              .classList.add("visible");
            return;
          }

          document.getElementById("eureka-modal").classList.remove("visible");
        });
      document
        .getElementById("close-tutorial-modal-btn")
        .addEventListener("click", () =>
          document.getElementById("tutorial-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-btn")
        .addEventListener("click", () => startTutorial(0)); // Existing tutorial button
      document
        .getElementById("tutorial-puzzle-btn")
        .addEventListener("click", () => startTutorial(8)); // New puzzle button
      document
        .getElementById("apply-rule-btn")
        .addEventListener("click", () => {
          if (!inTutorialMode || tutorialStep === 8) applyRule();
        });
      document
        .getElementById("add-assumption-btn")
        .addEventListener("click", addAssumption);
      document
        .getElementById("cancel-assumption-btn")
        .addEventListener("click", cancelAssumption);
      document
        .getElementById("alert-ok-btn")
        .addEventListener("click", () =>
          document.getElementById("alert-modal").classList.remove("visible")
        );
      document
        .getElementById("tutorial-next-btn")
        .addEventListener("click", advanceTutorial);

      document
        .getElementById("emergency-exit-tutorial-btn")
        .addEventListener("click", endTutorial);

      document
        .getElementById("puzzle-mode-btn")
        .addEventListener("click", () => {
          if (inTutorialMode) return; // 튜토리얼 중에는 동작 안 함

          audioManager.fadeOut("main-menu"); // 메인 메뉴 음악 페이드아웃
          audioManager.play("puzzle-theme"); // 일반 게임 음악 재생

          populatePuzzleLevels();

          document
            .getElementById("puzzle-level-select-modal")
            .classList.add("visible");
        });

      document
        .getElementById("close-puzzle-modal-btn")
        .addEventListener("click", () => {
          document
            .getElementById("puzzle-level-select-modal")
            .classList.remove("visible");
          showMainMenu();
        });

      // --- CHARACTER SELECTION LOGIC (NEW SECTION) ---

      function addGlobalSoundEvents() {
        // body에 단 하나의 클릭 이벤트 리스너를 추가합니다 (이벤트 위임 방식).
        document.body.addEventListener("click", (event) => {
          // 클릭된 요소 또는 그 부모 중에서 우리가 소리를 내고 싶은 대상을 찾습니다.
          const targetElement = event.target.closest("button");

          // 대상이 없으면 아무것도 하지 않습니다.
          if (!targetElement) {
            return;
          }

          // 비활성화된 요소나 AI의 손패에서는 소리를 재생하지 않습니다.
          if (
            targetElement.disabled ||
            targetElement.classList.contains("ai-hand")
          ) {
            return;
          }

          // 모든 조건을 통과하면 사운드를 재생합니다.
          audioManager.playSfx("hover");
        });
      }

      function startCharacterSelection(mode) {
        document.querySelector(".shared-selection-area").style.pointerEvents =
          "auto";
        audioManager.fadeOut("main-menu");
        audioManager.play("character-select");

        gameMode = mode;
        selectionMode = mode;
        tempSelections = { p1: null, p2: null };
        isPlayerAI = { A: false, B: false }; // 상태 초기화

        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");

        updatePlayerDisplay("p1", null);
        updatePlayerDisplay("p2", null);
        document.getElementById("p1-ready-overlay").classList.remove("visible");
        document.getElementById("p2-ready-overlay").classList.remove("visible");

        if (mode === "AI") {
          // 기존 1P vs AI 모드 로직 (수정 없음)
          const turnModal = document.getElementById("turn-order-modal");
          document.getElementById("turn-order-title").textContent =
            currentLang.ui.turnOrderTitle;
          document.getElementById("select-first-player").textContent =
            currentLang.ui.selectFirstPlayer;
          document.getElementById("select-second-player").textContent =
            currentLang.ui.selectSecondPlayer;

          turnModal.classList.add("visible");

          document.getElementById("select-first-player").onclick = () => {
            humanPlayerId = "P1";
            aiPlayer = "B"; // 기존 호환성을 위해 유지
            isPlayerAI.B = true; // 새로운 상태 변수 설정
            turnModal.classList.remove("visible");
            document
              .getElementById("character-selection-screen")
              .classList.remove("hidden");
            beginPlayerSelectionTurn("P1");
          };
          document.getElementById("select-second-player").onclick = () => {
            humanPlayerId = "P2";
            aiPlayer = "A"; // 기존 호환성을 위해 유지
            isPlayerAI.A = true; // 새로운 상태 변수 설정
            turnModal.classList.remove("visible");
            document
              .getElementById("character-selection-screen")
              .classList.remove("hidden");
            beginPlayerSelectionTurn("P1");
          };
        } else if (mode === "AI_VS_AI") {
          aiPlayer = null; // 사용하지 않음
          humanPlayerId = null;
          isPlayerAI = { A: true, B: true }; // 양쪽 모두 AI로 설정
          document
            .getElementById("character-selection-screen")
            .classList.remove("hidden");
          beginPlayerSelectionTurn("P1"); // 1P AI 선택부터 시작
        } else {
          // 2P 모드의 경우 (수정 없음)
          aiPlayer = null;
          humanPlayerId = null;
          document
            .getElementById("character-selection-screen")
            .classList.remove("hidden");
          beginPlayerSelectionTurn("P1");
        }
      }

      function beginPlayerSelectionTurn(player) {
        characterSelectionTurn = player;
        const lang = currentLang.ui;
        let instruction; // instruction 변수 선언

        // 턴에 따라 표시할 안내 문구를 결정하는 부분 (기존과 동일)
        if (selectionMode === "AI") {
          instruction =
            player === humanPlayerId
              ? lang.selectYourPhilosopher // "당신의 철학자를 선택하세요"
              : lang.selectAIPhilosopher; // "AI의 철학자를 선택하세요"
        } else if (selectionMode === "AI_VS_AI") {
          instruction =
            player === "P1"
              ? lang.selectAIP1Philosopher
              : lang.selectAIP2Philosopher;
        } else {
          // 2P 모드
          instruction =
            player === "P1"
              ? lang.selectP1Philosopher // "1P, 철학자를 선택하세요"
              : lang.selectP2Philosopher; // "2P, 철학자를 선택하세요"
        }

        // [수정된 부분 1] 우리가 새로 추가한 전용 인디케이터에 텍스트를 설정하고 화면에 표시
        const charIndicator = document.getElementById(
          "character-select-indicator"
        );
        charIndicator.textContent = instruction;
        charIndicator.classList.remove("hidden");

        // [수정된 부분 2] 누락되었던 캐릭터 아이콘 생성 코드가 여기에 다시 포함되었습니다.
        const grid = document.getElementById("shared-char-grid");
        grid.innerHTML = "";
        for (const key in PHILOSOPHERS) {
          if (key === "derrida") {
            continue; // 키가 'derrida'이면 아이콘을 생성하지 않고 건너뜁니다.
          }
          const philosopher = PHILOSOPHERS[key];
          const iconEl = document.createElement("div");
          iconEl.className = "char-icon";
          iconEl.dataset.id = key;
          iconEl.style.backgroundImage = `url('${philosopher.icon}')`;
          iconEl.onclick = () => handleCharacterClick(key);
          grid.appendChild(iconEl);
        }
        const randomIconEl = document.createElement("div");
        randomIconEl.className = "char-icon";
        randomIconEl.id = "random-char-btn";
        randomIconEl.onclick = () => {
          // 'derrida'를 제외한 철학자 ID 목록을 생성합니다.
          const allCharIds = Object.keys(PHILOSOPHERS).filter(
            (id) => id !== "derrida"
          );
          let availableCharIds;
          if (characterSelectionTurn === "P1") {
            availableCharIds = allCharIds;
          } else {
            availableCharIds = allCharIds.filter(
              (id) => id !== tempSelections.p1
            );
          }
          const randomId =
            availableCharIds[
              Math.floor(Math.random() * availableCharIds.length)
            ];
          handleCharacterClick(randomId);
        };
        grid.appendChild(randomIconEl);
      }

      function handleCharacterClick(philosopherId) {
        const targetPlayer = characterSelectionTurn === "P1" ? "p1" : "p2";
        tempSelections[targetPlayer] = philosopherId;
        updatePlayerDisplay(targetPlayer, philosopherId);

        document.querySelectorAll(".char-icon").forEach((icon) => {
          icon.classList.toggle("selected", icon.dataset.id === philosopherId);
        });

        document.getElementById("confirm-selection-btn").disabled = false;
      }

      function updatePlayerDisplay(player, philosopherId) {
        const portraitEl = document.getElementById(`${player}-portrait`);
        const nameEl = document.getElementById(`${player}-philosopher-name`);
        const skillDescEl = document.getElementById(`${player}-skill-desc`);

        if (philosopherId) {
          const p = PHILOSOPHERS[philosopherId];
          // player('p1' 또는 'p2')에 따라 p.image 객체에서 알맞은 경로를 가져옵니다.
          const imageUrl = p.image[player];
          portraitEl.style.backgroundImage = `url('${imageUrl}')`;
          nameEl.textContent = p.name[currentLang.langCode];
          skillDescEl.textContent = p.skill[currentLang.langCode];
        } else {
          portraitEl.style.backgroundImage = "none";
          nameEl.textContent = "";
          skillDescEl.textContent = currentLang.ui.waitingForOpponent;
        }
      }

      function handleConfirmClick() {
        audioManager.playSfx("hover");
        document.getElementById("confirm-selection-btn").disabled = true;

        if (characterSelectionTurn === "P1") {
          document.getElementById("p1-ready-overlay").classList.add("visible");
          beginPlayerSelectionTurn("P2");
        } else {
          document.getElementById("p2-ready-overlay").classList.add("visible");
          finalizeSelection();
        }
      }

      function finalizeSelection() {
        const charIndicator = document.getElementById(
          "character-select-indicator"
        );
        charIndicator.textContent = currentLang.ui.gameStartingSoon;

        document.querySelector(".shared-selection-area").style.pointerEvents =
          "none";

        audioManager.fadeOut("character-select");

        setTimeout(() => {
          charIndicator.classList.add("hidden");
          document
            .getElementById("character-selection-screen")
            .classList.add("hidden");
          document
            .getElementById("turn-order-modal")
            .classList.remove("visible");
          updateMainMenuBtnVisibility();
          updateMainCenterVisibility();
          resetGame(tempSelections);

          if (isTestMode) {
            // 테스트 모드일 경우, 데이터 입력 및 테스트 게임 시작
            promptAndSetupTestGame(tempSelections);
          } else {
            // 일반 모드일 경우, 기존 게임 시작
            resetGame(tempSelections);
          }
        }, 2000);
      }

      function startTutorial(startStep = 0) {
        const exitBtn = document.getElementById("emergency-exit-tutorial-btn");
        exitBtn.classList.remove("hidden");
        exitBtn.textContent = currentLang.ui.endTutorialButton;
        audioManager.fadeOut("main-menu");
        audioManager.play("game-play");

        // 튜토리얼 시작 시, 철학자를 소크라테스와 플라톤으로 강제 초기화합니다.
        playerA_Data = PHILOSOPHERS["socrates"];
        playerB_Data = PHILOSOPHERS["plato"];

        // 튜토리얼에 사용될 철학자(소크라테스, 플라톤)의 능력 사용 상태를 초기화합니다.
        abilityUsedState = {};
        abilityUsedState["A"] = { usedCount: 0, maxUses: 2 }; // 소크라테스는 2회 사용 가능
        abilityUsedState["B"] = { used: false }; // 플라톤은 1회 사용 가능

        fullDeck = currentLang.cards;

        inTutorialMode = true;
        tutorialStep = startStep;
        tutorialSubStep = 0;

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.endTutorialButton;
        tutorialBtn.removeEventListener("click", startTutorial);
        tutorialBtn.addEventListener("click", endTutorial);

        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            if (
              btn.id !== "tutorial-btn" &&
              btn.id !== "main-menu-btn" &&
              btn.id !== "fullscreen-btn" &&
              btn.id !== "settings-btn"
            ) {
              btn.disabled = true;
            }
          });

        document.getElementById("tutorial-guide").classList.remove("hidden");
        document.getElementById("tutorial-next-btn").textContent =
          currentLang.ui.nextButton;

        setupTutorialScenario(startStep + 1);
        advanceTutorial();
      }

      function advanceTutorial() {
        // Clear previous temporary listeners to prevent stacking
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
          temporaryListener = null;
        }

        const script = currentLang.tutorial[tutorialStep];
        if (!script || tutorialSubStep >= script.length) {
          tutorialStep++;
          tutorialSubStep = 0;
          if (tutorialStep >= currentLang.tutorial.length) {
            endTutorial();
            return;
          }
          setupTutorialScenario(tutorialStep + 1); // Setup for the *next* stage
        }

        const newScript = currentLang.tutorial[tutorialStep];
        if (!newScript || tutorialSubStep >= newScript.length) {
          endTutorial();
          return;
        }

        const guideTextEl = document.getElementById("tutorial-text");
        const tutorialGuideEl = document.getElementById("tutorial-guide");
        const nextBtn = document.getElementById("tutorial-next-btn");
        guideTextEl.innerHTML = newScript[tutorialSubStep];
        nextBtn.classList.remove("hidden");

        // Reset position and highlights
        tutorialGuideEl.classList.remove("top");
        clearHighlights();

        handleTutorialStepLogic();

        tutorialSubStep++;
      }

      function handleTutorialStepLogic() {
        if (tutorialStep === 0) {
          // Stage 1
          switch (tutorialSubStep) {
            case 5:
              highlightElement("#player-a-hand");
              break;
            case 6:
              highlightElement("#proposition-display");
              break;
            case 7:
              const cardToClick = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.socrates);
              if (cardToClick) {
                highlightElement(cardToClick);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(cardToClick, "click", () => {
                  const cardData = playerA_Hand.find(
                    (c) => c.text === currentLang.keywords.socrates
                  );
                  playCardTutorial(cardData);
                  advanceTutorial();
                });
              }
              break;
            case 9:
              clearHighlights();
              const entityCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[2]; // 개체 or Entity
              });
              const quantifierCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter((c) => {
                const cardData = fullDeck.find(
                  (card) => card.text === c.textContent
                );
                return cardData && cardData.type === currentLang.cardTypes[1]; // 양화사 or Quantifier
              });
              entityCards.forEach((card) => {
                card.classList.add("tutorial-highlight");
                card.classList.remove("unplayable"); // 이 줄을 추가합니다.
              });
              quantifierCards.forEach((card) => {
                card.classList.add("tutorial-highlight");
                card.classList.remove("unplayable"); // 이 줄을 추가합니다.
              });
              break;
            case 11:
              const endTurnBtn = document.getElementById("end-turn-btn");
              highlightElement(endTurnBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endTurnBtn, "click", () => {
                endTurnTutorial();
                advanceTutorial();
              });
              break;
          }
        } else if (tutorialStep === 1) {
          // Stage 2
          switch (tutorialSubStep) {
            case 2:
              const completeBtn = document.getElementById("complete-btn");
              highlightElement(completeBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(completeBtn, "click", () => {
                completePropositionTutorial();
                advanceTutorial();
              });
              break;
            case 7:
              clearHighlights();
              const connectiveCards = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).filter(
                (c) =>
                  c.textContent === currentLang.keywords.and ||
                  c.textContent === currentLang.keywords.or ||
                  c.textContent === currentLang.keywords.if
              );
              connectiveCards.forEach((card) => {
                card.classList.add("tutorial-highlight");
                card.classList.remove("unplayable"); // 이 줄을 추가합니다.
              });
              break;
            case 8:
              const negationCard = Array.from(
                document.querySelectorAll("#player-a-hand .card")
              ).find((c) => c.textContent === currentLang.keywords.not);
              if (negationCard) highlightElement(negationCard);
              break;
          }
        } else if (tutorialStep === 2) {
          // Stage 3
          switch (tutorialSubStep) {
            case 0:
              highlightElement("#true-propositions");
              break;
            case 1:
              const axiomSummary = document.querySelector(
                ".axiom-wrapper summary"
              );
              if (axiomSummary) {
                highlightElement(axiomSummary);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(axiomSummary, "click", () => {
                  advanceTutorial();
                });
              }
              break;
            case 2:
            case 3:
            case 4:
            case 5:
              document.getElementById("tutorial-guide").classList.add("top");
              break;
          }
          // handleTutorialStepLogic 함수 내의 'else if (tutorialStep === 3)' 블록을 찾아 통째로 교체합니다.
        } else if (tutorialStep === 3) {
          // Stage 4 - Thinking Time
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 2: // "후공 플레이어부터 시작합니다..." 텍스트 표시
              // 특별한 동작 없이 다음으로 넘어갑니다.
              break;
            case 3: // "(상대방이 턴을 마쳤습니다...)" 텍스트 표시
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              // 상대 턴을 시뮬레이션하고 자동으로 플레이어 턴으로 넘깁니다.
              setTimeout(() => {
                endTurn(); // 상대 턴 종료
                advanceTutorial(); // 다음 단계로 자동 진행
              }, 1500); // 1.5초 후 실행
              break;
            case 4: // "이제 당신의 턴입니다. 정리 추가 버튼을..."
              const addTheoremBtn = document.getElementById("eureka-a");
              highlightElement(addTheoremBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(addTheoremBtn, "click", () => {
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            case 6: // "전제 목록에서..."
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["소크라테스는 개이다", "모든 개는 지혜롭다"]
                  : ["Socrates is a dog", "Every dog is wise"]
              );
              break;
            case 7: // "추론 규칙에서..."
              handleTutorialRuleApplication("universalApplication");
              break;
            case 8: // "좋습니다! ... 이제 이 정리를 선택하고..."
              const confirmBtn = document.getElementById("modal-confirm-btn");
              const newTheoremText =
                currentLang.langCode === "ko"
                  ? "소크라테스는 지혜롭다"
                  : "Socrates is wise";
              const newTheoremProp = parsePropositionFromString(newTheoremText);
              const theoremLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.type === "theorem" &&
                  arePropositionsEqual(data.proposition, newTheoremProp)
                );
              });

              if (theoremLi && confirmBtn) {
                highlightElement(theoremLi);
                confirmBtn.classList.add("tutorial-highlight");
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");

                const confirmHandler = () => {
                  const checkbox = theoremLi.querySelector("input");
                  if (checkbox && checkbox.checked) {
                    addTheoremsToListTutorial();
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "새로 도출된 정리를 먼저 선택해주세요."
                        : "Please select the newly derived theorem first."
                    );
                  }
                };
                waitForInteraction(confirmBtn, "click", confirmHandler);
              }
              break;
            case 9: // "훌륭합니다! 사유 시간에는..."
              // '능력 사용' 버튼을 하이라이트합니다.
              highlightElement("#ability-a");
              break;
            case 10: // "새로운 정리가... 이제 턴 종료 버튼을..."
              const endTurnBtn = document.getElementById("end-turn-btn");
              highlightElement(endTurnBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(endTurnBtn, "click", () => {
                endThinkingTime(); // 사유 시간을 종료하는 함수 호출
                advanceTutorial();
              });

              break;
          }
        } else if (tutorialStep === 4) {
          // Stage 5 - Basic Rules
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            // Intro
            case 0:
              const eurekaBtn = document.getElementById("eureka-a");
              highlightElement(eurekaBtn);
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              waitForInteraction(eurekaBtn, "click", (event) => {
                // event를 인자로 받도록 수정
                event.stopPropagation(); // 전역 리스너로 이벤트가 가는 것을 막음
                audioManager.playSfx("eureka"); // 고유 효과음 재생
                openEurekaModalTutorial();
                advanceTutorial();
              });
              break;
            // Modus Ponens
            case 2:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "소크라테스는 선하다",
                      "(소크라테스는 선하다) 라면 (소크라테스는 승리한다)",
                    ]
                  : [
                      "Socrates is good",
                      "(Socrates is good) then (Socrates wins)",
                    ]
              );
              break;
            case 3:
              handleTutorialRuleApplication("modusPonens");
              break;
            // Modus Tollens
            case 5:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "플라톤은 지혜롭다 는 거짓이다",
                      "(플라톤은 승리한다) 라면 (플라톤은 지혜롭다)",
                    ]
                  : [
                      "Plato is wise is false",
                      "(Plato wins) then (Plato is wise)",
                    ]
              );
              break;
            case 6:
              handleTutorialRuleApplication("modusTollens");
              break;
            // Disjunctive Syllogism
            case 8:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(어떤 새는 물고기이다) 또는 (어떤 새는 새이다)",
                      "어떤 새는 물고기이다 는 거짓이다",
                    ]
                  : [
                      "(Some bird is a fish) or (Some bird is a bird)",
                      "Some bird is a fish is false",
                    ]
              );
              break;
            case 9:
              handleTutorialRuleApplication("disjunctiveSyllogism");
              break;
            // Hypothetical Syllogism
            case 11:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? [
                      "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                      "(플라톤은 선하다) 라면 (플라톤은 승리한다)",
                    ]
                  : [
                      "(Plato is a dog) then (Plato is good)",
                      "(Plato is good) then (Plato wins)",
                    ]
              );
              break;
            case 12:
              handleTutorialRuleApplication("hypotheticalSyllogism");
              break;
            // Conjunction Elimination
            case 14:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["(소크라테스는 지혜롭다) 그리고 (플라톤은 어리석다)"]
                  : ["(Socrates is wise) and (Plato is foolish)"]
              );
              break;
            case 15:
              handleTutorialRuleApplication("conjunctionElimination");
              break;
            // Double Negation
            case 17:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["어떤 물고기는 선하다 는 거짓이다 는 거짓이다"]
                  : ["Some fish is good is false is false"]
              );
              break;
            case 18:
              handleTutorialRuleApplication("doubleNegationElimination");
              break;
            // Universal Application
            case 20:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["모든 새는 선하다", "플라톤은 새이다"]
                  : ["Every bird is good", "Plato is a bird"]
              );
              break;
            case 21:
              handleTutorialRuleApplication("universalApplication");
              break;
            // Existential Instantiation
            case 23:
              handleTutorialRuleInteraction(
                currentLang.langCode === "ko"
                  ? ["모든 개는 선하다"]
                  : ["Every dog is good"]
              );
              break;
            case 24:
              handleTutorialRuleApplication("existentialInstantiation");
              break;
          }
        } else if (tutorialStep === 5) {
          // Stage 6 - Advanced Rules (Proof by Cases)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              const premises =
                currentLang.langCode === "ko"
                  ? [
                      "플라톤은 선하다 또는 플라톤은 악하다",
                      "(플라톤은 선하다) 라면 (플라톤은 지혜롭다)",
                      "(플라톤은 악하다) 라면 (플라톤은 지혜롭다)",
                    ]
                  : [
                      "Plato is good or Plato is evil",
                      "(Plato is good) then (Plato is wise)",
                      "(Plato is evil) then (Plato is wise)",
                    ];
              handleTutorialRuleInteraction(premises);
              break;
            case 2:
              handleTutorialRuleApplication("proofByCases");
              break;
          }
        } else if (tutorialStep === 6) {
          // Stage 7 - Assumption (Conditional Intro) ★★★ MODIFIED SECTION ★★★
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1: // Assume
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionCI =
                currentLang.langCode === "ko"
                  ? "소크라테스는 지혜롭다"
                  : "Socrates is wise";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionCI) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "올바른 명제를 입력해 주십시오."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2: // Select premises for 1st MP
              const premisesCI_1 =
                currentLang.langCode === "ko"
                  ? [
                      "소크라테스는 지혜롭다",
                      "(소크라테스는 지혜롭다) 라면 (플라톤은 개이다)",
                    ]
                  : [
                      "Socrates is wise",
                      "(Socrates is wise) then (Plato is a dog)",
                    ];
              handleTutorialRuleInteraction(premisesCI_1);
              break;
            case 3: // Apply 1st MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 4: // Select premises for 2nd MP
              const premisesCI_2 =
                currentLang.langCode === "ko"
                  ? [
                      "플라톤은 개이다",
                      "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                    ]
                  : ["Plato is a dog", "(Plato is a dog) then (Plato is good)"];
              handleTutorialRuleInteraction(premisesCI_2);
              break;
            case 5: // Apply 2nd MP
              handleTutorialRuleApplication("modusPonens");
              break;
            case 6: // Select final result
              const conclusionTextCI =
                currentLang.langCode === "ko"
                  ? "플라톤은 선하다"
                  : "Plato is good";
              const conclusionPropCI =
                parsePropositionFromString(conclusionTextCI);
              const conclusionLi = Array.from(
                document.querySelectorAll("#premise-list li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                return (
                  data.dependsOnAssumption &&
                  arePropositionsEqual(data.proposition, conclusionPropCI)
                );
              });
              if (conclusionLi) {
                highlightElement(conclusionLi);
                document
                  .getElementById("tutorial-next-btn")
                  .classList.add("hidden");
                waitForInteraction(
                  document.getElementById("premise-list"),
                  "click",
                  () => {
                    const selectedCheckbox =
                      conclusionLi.querySelector("input");
                    const allCheckboxes = document.querySelectorAll(
                      "#premise-list input:checked"
                    );
                    if (
                      selectedCheckbox.checked &&
                      allCheckboxes.length === 1
                    ) {
                      advanceTutorial();
                    }
                  }
                );
              }
              break;
            case 7: // Apply CI
              handleTutorialRuleApplication("conditionalIntroduction");
              break;
          }
        } else if (tutorialStep === 7) {
          // Stage 8 - Assumption (RAA)
          document.getElementById("tutorial-guide").classList.add("top");
          switch (tutorialSubStep) {
            case 1:
              highlightElement("#add-assumption-btn");
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const correctAssumptionRAA =
                currentLang.langCode === "ko"
                  ? "소크라테스는 악하다 는 거짓이다"
                  : "Socrates is evil is false";
              const originalShowPrompt = window.showPrompt;
              window.showPrompt = (message, callback) => {
                originalShowPrompt(message, (value) => {
                  if (value === correctAssumptionRAA) {
                    window.showPrompt = originalShowPrompt;
                    callback(value);
                    advanceTutorial();
                  } else {
                    showAlert(
                      currentLang.langCode === "ko"
                        ? "올바른 명제를 입력해 주십시오."
                        : "Please enter a valid proposition."
                    );
                    callback(null);
                  }
                });
              };
              break;
            case 2:
              const premisesRAA_texts =
                currentLang.langCode === "ko"
                  ? [
                      "소크라테스는 악하다 는 거짓이다",
                      "(소크라테스는 악하다 는 거짓이다) 라면 (플라톤은 지혜롭다)",
                    ]
                  : [
                      "(Socrates is evil is false) then (Plato is wise)",
                      "Socrates is evil is false",
                    ];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList_mp = document.getElementById("premise-list");
              const premiseProps_mp = premisesRAA_texts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis_mp = premiseProps_mp
                .map((prop) =>
                  Array.from(premiseList_mp.querySelectorAll("li")).find(
                    (li) => {
                      const data = JSON.parse(li.dataset.propObject);
                      return arePropositionsEqual(data.proposition, prop);
                    }
                  )
                )
                .filter(Boolean);

              premiseLis_mp.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              document
                .getElementById("inference-rule-select")
                .classList.add("tutorial-highlight");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn_mp = document.getElementById("apply-rule-btn");
              const select_mp = document.getElementById(
                "inference-rule-select"
              );

              const applyRuleHandler_mp = () => {
                const allChecked = premiseLis_mp.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList_mp.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis_mp.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "먼저 가정과 다른 전제를 선택해주세요."
                      : "Please select the assumption and the other premise first."
                  );
                  return;
                }

                if (select_mp.value === "modusPonens") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 3
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn_mp, "click", applyRuleHandler_mp);
              break;
            case 3:
              // This substep now just shows the result text.
              // The logic is handled in case 2.
              // We just need to clear highlights and let the user click "Next".
              clearHighlights();
              break;
            case 4: // This case now handles both selection and application for RAA.
              const contradictionPairTexts =
                currentLang.langCode === "ko"
                  ? ["플라톤은 지혜롭다", "플라톤은 지혜롭다 는 거짓이다"]
                  : ["Plato is wise", "Plato is wise is false"];

              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden");
              const premiseList = document.getElementById("premise-list");
              const premiseProps = contradictionPairTexts.map((text) =>
                parsePropositionFromString(text)
              );
              const premiseLis = premiseProps
                .map((prop) =>
                  Array.from(premiseList.querySelectorAll("li")).find((li) => {
                    const data = JSON.parse(li.dataset.propObject);
                    return arePropositionsEqual(data.proposition, prop);
                  })
                )
                .filter(Boolean);

              premiseLis.forEach((li) =>
                li.classList.add("tutorial-highlight")
              );
              highlightElement("#inference-rule-select");
              document
                .getElementById("apply-rule-btn")
                .classList.add("tutorial-highlight");

              const applyBtn = document.getElementById("apply-rule-btn");
              const select = document.getElementById("inference-rule-select");

              const applyRuleHandler = () => {
                const allChecked = premiseLis.every(
                  (li) => li.querySelector("input").checked
                );
                const totalChecked =
                  premiseList.querySelectorAll("input:checked").length;
                if (!allChecked || totalChecked !== premiseLis.length) {
                  showAlert(
                    currentLang.langCode === "ko"
                      ? "먼저 모순되는 두 전제를 선택해주세요."
                      : "Please select the two contradictory premises first."
                  );
                  return;
                }

                if (select.value === "reductioAdAbsurdum") {
                  applyRuleTutorial();
                  advanceTutorial(); // Advances to subStep 5
                } else {
                  showAlert(currentLang.alerts.ruleFailed);
                }
              };
              waitForInteraction(applyBtn, "click", applyRuleHandler);
              break;
            case 5: // This is the step where the RAA result is shown and DNE is expected
              clearHighlights();
              document
                .getElementById("tutorial-next-btn")
                .classList.add("hidden"); // Hide the "Next" button

              const raaResultText =
                currentLang.langCode === "ko"
                  ? "소크라테스는 악하다 는 거짓이다 는 거짓이다"
                  : "Socrates is evil is false is false";
              const raaResultProp = parsePropositionFromString(raaResultText);

              const premiseListForDNE = document.getElementById("premise-list");
              const raaResultLi = Array.from(
                premiseListForDNE.querySelectorAll("li")
              ).find((li) => {
                const data = JSON.parse(li.dataset.propObject);
                // Check if it's a theorem derived from RAA and matches the expected proposition
                return (
                  data.type === "theorem" &&
                  data.label === currentLang.labels.raa_theorem &&
                  arePropositionsEqual(data.proposition, raaResultProp)
                );
              });

              if (raaResultLi) {
                highlightElement(raaResultLi); // Highlight the RAA result
                highlightElement("#inference-rule-select"); // Highlight the rule dropdown
                document
                  .getElementById("apply-rule-btn")
                  .classList.add("tutorial-highlight"); // Highlight the apply button

                const applyBtnDNE = document.getElementById("apply-rule-btn");
                const selectDNE = document.getElementById(
                  "inference-rule-select"
                );

                const applyRuleHandlerDNE = () => {
                  const selectedCheckboxes = premiseListForDNE.querySelectorAll(
                    'input[type="checkbox"]:checked'
                  );
                  const isRaaResultSelected = Array.from(
                    selectedCheckboxes
                  ).some((chk) => chk.parentElement === raaResultLi);

                  // Check if exactly one premise is selected, it's the RAA result, and DNE rule is chosen
                  if (
                    selectedCheckboxes.length === 1 &&
                    isRaaResultSelected &&
                    selectDNE.value === "doubleNegationElimination"
                  ) {
                    applyRuleTutorial(); // Apply the rule
                    advanceTutorial(); // Proceed to the next tutorial step
                  } else {
                    showAlert(currentLang.alerts.ruleFailed); // Show error if conditions not met
                  }
                };
                waitForInteraction(applyBtnDNE, "click", applyRuleHandlerDNE);
              } else {
                // Fallback if RAA result not found (shouldn't happen in normal tutorial flow)
                console.error(
                  "Tutorial Error: RAA result not found for DNE step."
                );
                advanceTutorial(); // Proceed to next step if something went wrong
              }
              break;
            case 6: // This is the final text step
              clearHighlights();
              // No specific interaction needed, just display text and allow "Next" to end tutorial
              break;
          }
        } else if (tutorialStep === 8) {
          // Stage 9 - Final Puzzle Logic
          document.getElementById("tutorial-guide").classList.add("top");
          document.getElementById("tutorial-next-btn").classList.add("hidden"); // 다음 버튼 숨김
          // 사용자가 직접 문제를 해결해야 하므로, 여기서 더 이상 자동 진행하지 않습니다.
        }
      }

      function handleTutorialRuleInteraction(premiseTexts) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        const premiseList = document.getElementById("premise-list");
        const premiseProps = premiseTexts.map((text) =>
          parsePropositionFromString(text)
        );
        const premiseLis = premiseProps
          .map((prop) =>
            Array.from(premiseList.querySelectorAll("li")).find((li) => {
              // 구분선 요소는 건너뛰기
              if (!li.dataset.propObject) return false;
              const data = JSON.parse(li.dataset.propObject);
              return arePropositionsEqual(data.proposition, prop);
            })
          )
          .filter(Boolean);

        if (premiseLis.length !== premiseTexts.length) {
          console.error(
            "Tutorial Error: Could not find all required premises in the list.",
            premiseTexts
          );
          return;
        }

        premiseLis.forEach((li) => li.classList.add("tutorial-highlight"));

        const checkPremises = () => {
          const allChecked = premiseLis.every(
            (li) => li.querySelector("input").checked
          );
          const totalChecked =
            premiseList.querySelectorAll("input:checked").length;
          if (allChecked && totalChecked === premiseLis.length) {
            advanceTutorial();
          }
        };
        waitForInteraction(premiseList, "click", checkPremises);
      }

      function handleTutorialRuleApplication(ruleValue) {
        document.getElementById("tutorial-next-btn").classList.add("hidden");
        highlightElement("#inference-rule-select");
        document
          .getElementById("apply-rule-btn")
          .classList.add("tutorial-highlight");

        // 체크박스들을 비활성화
        const checkboxes = document.querySelectorAll(
          "#premise-list input[type='checkbox']"
        );
        checkboxes.forEach((checkbox) => {
          checkbox.disabled = true;
        });

        const applyBtn = document.getElementById("apply-rule-btn");
        const select = document.getElementById("inference-rule-select");

        const applyRuleHandler = () => {
          if (select.value === ruleValue) {
            // 전제가 선택되었는지 확인
            const selectedPremises = document.querySelectorAll(
              "#premise-list input:checked"
            );
            if (selectedPremises.length === 0) {
              showAlert(
                currentLang.langCode === "ko"
                  ? "전제를 선택해주세요."
                  : "Please select premises."
              );
              return;
            }

            applyRuleTutorial();
            advanceTutorial();
          } else {
            showAlert(currentLang.alerts.ruleFailed);
          }
        };
        waitForInteraction(applyBtn, "click", applyRuleHandler);
      }

      function playCardTutorial(cardToPlay) {
        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (c) => c.text === cardToPlay.text && c.type === cardToPlay.type
        );

        audioManager.playSfx("playCard");

        if (cardIndex > -1) {
          const [playedCard] = hand.splice(cardIndex, 1);
          currentProposition.push({ card: playedCard, player: currentPlayer });
          cardsPlayedThisTurn[currentPlayer]++;
          lastCardPlayer = currentPlayer;
          render();
        }
      }

      function endTurnTutorial() {
        audioManager.playSfx("end");
        currentPlayer = currentPlayer === "A" ? "B" : "A";
        cardsPlayedThisTurn.A = 0;
        cardsPlayedThisTurn.B = 0;
        render();
      }

      function completePropositionTutorial() {
        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (parsedProp) {
          truePropositions.push({
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          });

          audioManager.playSfx("complete");

          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
        }
      }

      function openEurekaModalTutorial() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions.filter(
            (p) =>
              p.type === "user-made" ||
              p.type === "theorem" ||
              p.type === "victory"
          ),
        ];
        // 공리들을 그룹별로 분류하고 순서대로 추가 (튜토리얼 버전)
        const axioms = allSelectablePropositions.filter(p => p.type === "axiom");
        const nonAxioms = allSelectablePropositions.filter(p => p.type !== "axiom");
        
        // 공리를 그룹화하여 추가 - 작은 서브그룹별로 구분선 추가
        if (currentAxioms.groups && axioms.length > 0) {
          const groups = currentAxioms.groups;
          const templates = currentLang.axiom_templates;
          let axiomIndex = 0;
          
          // 정체성 공리 그룹
          if (groups.identity && groups.identity.length > 0) {
            for (let i = 0; i < groups.identity.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 정체성 그룹 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // 개체별 속성 대립 그룹 - 서브그룹별로 나누기
          if (groups.subjectOpposition && groups.subjectOpposition.length > 0) {
            // 첫 번째 철학자 선악 공리
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 첫 번째 철학자 지혜 공리
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 두 번째 철학자 선악 공리
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 두 번째 철학자 지혜 공리
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 개체별 속성 대립 그룹 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // 집단별 속성 대립 그룹 - 서브그룹별로 나누기
          if (groups.quantifierOpposition && groups.quantifierOpposition.length > 0) {
            // 새 집단 순방향
            for (let i = 0; i < templates.bird_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 새 집단 역방향
            for (let i = 0; i < templates.bird_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 물고기 집단 순방향
            for (let i = 0; i < templates.fish_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 물고기 집단 역방향
            for (let i = 0; i < templates.fish_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 개 집단 순방향
            for (let i = 0; i < templates.dog_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 개 집단 역방향
            for (let i = 0; i < templates.dog_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  proposition: axioms[axiomIndex].proposition,
                  type: axioms[axiomIndex].type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 마르크스 공리가 있으면 추가
            const remainingAxioms = axioms.slice(axiomIndex);
            const marxAxioms = remainingAxioms.filter(a => {
              const text = propositionToNaturalText(a.proposition);
              return text.includes("브루주아") || text.includes("Bourgeois");
            });
            
            if (marxAxioms.length > 0) {
              // 서브그룹 구분선
              addPremiseToWorkbench({
                type: "separator",
                label: "",
                proposition: null,
                isSeparator: true
              });
              
              marxAxioms.forEach((axiomData) => {
                addPremiseToWorkbench({
                  proposition: axiomData.proposition,
                  type: axiomData.type,
                  dependsOnAssumption: false,
                  isAssumption: false,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              });
            }
            
            // 집단별 속성 대립 그룹 마지막 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        } else {
          // 기존 방식으로 공리 추가 (하위 호환성)
          axioms.forEach((propData) => {
            addPremiseToWorkbench({
              proposition: propData.proposition,
              type: propData.type,
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.axiom
            });
          });
          
          // 공리 마지막 구분선 추가
          if (axioms.length > 0) {
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        }
        
        // 공리가 아닌 명제들 추가
        nonAxioms.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });

        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        modalTitle.textContent = isThinkingTime
          ? currentLang.modals.eurekaTitleTheorem
          : currentLang.modals.eurekaTitleVictory;
        confirmBtn.textContent = isThinkingTime
          ? currentLang.modals.confirmTheoremButton
          : currentLang.modals.confirmVictoryButton;

        confirmBtn.onclick = isThinkingTime ? addTheoremsToList : proveVictory;

        document.getElementById("cancel-assumption-btn").style.display =
          currentAssumption ? "inline-block" : "none";

        renderModal();
        document.getElementById("inference-rule-select").onchange =
          updateConclusionPreview;
        updateConclusionPreview();
        modal.classList.add("visible");
      }

      function applyRuleTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premisesData = selectedLis
          .map((chk) => {
            const propString = chk.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter(Boolean);

        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];

        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (rule === "conditionalIntroduction") {
          const result = {
            type: "conditional",
            left: currentAssumption,
            right: premises[0],
          };
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.ci_theorem,
            });
            // 튜토리얼 조건부 도입 성공 시 사운드 재생
            audioManager.playSfx("pop");
          }
        } else if (rule === "reductioAdAbsurdum") {
          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
            });
            // 튜토리얼 귀류법 성공 시 사운드 재생
            audioManager.playSfx("pop");
          }
        } else if (threePremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }

        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
            });
          });
          // 튜토리얼 추론 규칙 적용 성공 시 사운드 재생
          audioManager.playSfx("pop");
        }
        renderModal();
        updateConclusionPreview();
      }

      function addTheoremsToListTutorial() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const newTheorems = selectedLis
          .map((li) => {
            const propString = li.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString) : null;
          })
          .filter((p) => p && p.type === "theorem" && !p.dependsOnAssumption);

        newTheorems.forEach((theoremData) => {
          const isDuplicate = truePropositions.some((p) =>
            arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          if (!isDuplicate) {
            truePropositions.push({
              propId: `prop_${Date.now()}_${Math.random()}`, // ✅ 이 줄이 추가되었습니다.
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
          }
        });
        document.getElementById("eureka-modal").classList.remove("visible");
        render();
      }

      function highlightElement(elementOrSelector, remove = false) {
        clearHighlights();
        if (remove) return;

        const element =
          typeof elementOrSelector === "string"
            ? document.querySelector(elementOrSelector)
            : elementOrSelector;
        if (element) {
          element.classList.add("tutorial-highlight");
          element.classList.remove("unplayable");
        }
      }

      function clearHighlights() {
        const previouslyHighlighted = document.querySelectorAll(
          ".tutorial-highlight"
        );

        previouslyHighlighted.forEach((el) => {
          el.classList.remove("tutorial-highlight");

          // 하이라이트가 제거된 요소가 손패에 있는 카드라면,
          if (
            el.classList.contains("card") &&
            el.parentElement &&
            (el.parentElement.id === "player-a-hand" ||
              el.parentElement.id === "player-b-hand")
          ) {
            const cardText = el.textContent;
            const player = el.parentElement.id === "player-a-hand" ? "A" : "B";
            const hand = player === "A" ? playerA_Hand : playerB_Hand;
            const cardData = hand.find((c) => c.text === cardText);

            if (cardData) {
              // 현재 게임 상태에 따라 카드가 비활성화 되어야 하는지 다시 확인합니다.
              const shouldBeUnplayable =
                isThinkingTime ||
                player !== currentPlayer ||
                cardsPlayedThisTurn[player] >= 1 ||
                !isValidPlay(cardData, currentProposition);

              if (shouldBeUnplayable) {
                el.classList.add("unplayable");
              }
            }
          }
        });
      }

      function waitForInteraction(element, eventType, callback) {
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
        }
        const handler = (event) => {
          // For checkbox clicks, we don't want to stop propagation
          if (eventType !== "click" || event.target.type !== "checkbox") {
          }
          callback(event);
        };
        element.addEventListener(eventType, handler, {
          once: eventType !== "click",
        });

        temporaryListener = { element, type: eventType, handler };
      }

      function endTutorial() {
        document
          .getElementById("emergency-exit-tutorial-btn")
          .classList.add("hidden");
        audioManager.fadeOut("game-play");
        audioManager.fadeOut("thinking-time");

        // --- 💡[수정된 부분 시작] ---

        // 1. 튜토리얼 진행 단계를 완전히 초기화합니다.
        inTutorialMode = false;
        tutorialStep = 0;
        tutorialSubStep = 0;

        // 2. 튜토리얼 진행을 위해 임시로 추가되었을 수 있는 이벤트 리스너를 안전하게 제거합니다.
        if (temporaryListener) {
          temporaryListener.element.removeEventListener(
            temporaryListener.type,
            temporaryListener.handler
          );
          temporaryListener = null;
        }

        // --- [수정된 부분 끝] ---

        document.getElementById("tutorial-guide").classList.add("hidden");
        clearHighlights();

        const tutorialBtn = document.getElementById("tutorial-btn");
        tutorialBtn.textContent = currentLang.ui.tutorialButton;
        tutorialBtn.removeEventListener("click", endTutorial);
        tutorialBtn.addEventListener("click", startTutorial);

        document
          .querySelectorAll(
            ".header-buttons-left button, .header-buttons-right button"
          )
          .forEach((btn) => {
            btn.disabled = false;
          });
        document.getElementById("eureka-modal").classList.remove("visible");

        // 메인 메뉴를 표시하여 게임 상태를 완전히 초기화합니다.
        showMainMenu();
      }
      function showAlert(message, callback) {
        const modal = document.getElementById("alert-modal");
        document.getElementById("alert-message").innerHTML = message;
        modal.classList.add("visible");

        // 기존 이벤트 제거
        const okBtn = document.getElementById("alert-ok-btn");
        const newBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newBtn, okBtn);

        newBtn.addEventListener("click", () => {
          modal.classList.remove("visible");
          if (callback) callback();
        });
      }

      function showPrompt(message, callback) {
        const modal = document.getElementById("prompt-modal");
        document.getElementById("prompt-message").textContent = message;
        const input = document.getElementById("prompt-input");
        const confirmBtn = document.getElementById("prompt-confirm-btn");
        const cancelBtn = document.getElementById("prompt-cancel-btn");
        input.value = "";

        const confirmHandler = () => {
          cleanup();
          callback(input.value);
        };
        const cancelHandler = () => {
          cleanup();
          callback(null);
        };
        const cleanup = () => {
          modal.classList.remove("visible");
          confirmBtn.removeEventListener("click", confirmHandler);
          cancelBtn.removeEventListener("click", cancelHandler);
        };

        confirmBtn.addEventListener("click", confirmHandler);
        cancelBtn.addEventListener("click", cancelHandler);
        modal.classList.add("visible");
        input.focus();
      }

      function showConfirm(message, onConfirm, onCancel) {
        const modal = document.getElementById("prompt-modal");
        document.getElementById("prompt-message").innerHTML = message;
        const input = document.getElementById("prompt-input");
        const confirmBtn = document.getElementById("prompt-confirm-btn");
        const cancelBtn = document.getElementById("prompt-cancel-btn");

        input.style.display = "none";
        confirmBtn.textContent = currentLang.ui.yesButton;
        cancelBtn.textContent = currentLang.ui.noButton;

        const confirmHandler = (event) => {
          // 💡 변경점: event 객체를 받도록 수정
          cleanup();
          if (onConfirm) onConfirm(event); // 💡 변경점: onConfirm 콜백으로 event 객체를 전달
        };

        const cancelHandler = () => {
          cleanup();
          if (onCancel) onCancel();
        };

        const cleanup = () => {
          modal.classList.remove("visible");
          input.style.display = "";
          confirmBtn.textContent = currentLang.ui.okButton;
          cancelBtn.textContent = currentLang.ui.cancelButton;
          confirmBtn.removeEventListener("click", confirmHandler);
          cancelBtn.removeEventListener("click", cancelHandler);
        };

        confirmBtn.addEventListener("click", confirmHandler);
        cancelBtn.addEventListener("click", cancelHandler);
        modal.classList.add("visible");
      }

      // --- GAME FLOW & TURN MANAGEMENT ---
      function modusPonens(p1, p2) {
        if (!p1 || !p2) return null;
        if (p2.type === "conditional" && arePropositionsEqual(p1, p2.left))
          return p2.right;
        if (p1.type === "conditional" && arePropositionsEqual(p2, p1.left))
          return p1.right;
        return null;
      }

      function modusTollens(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c, o) => {
          if (c.type !== "conditional") return null;
          const consequent = c.right;
          let isContradiction = false;
          if (
            o.type === "negation" &&
            arePropositionsEqual(o.proposition, consequent)
          ) {
            isContradiction = true;
          }
          if (
            consequent.type === "negation" &&
            arePropositionsEqual(consequent.proposition, o)
          ) {
            isContradiction = true;
          }
          if (isContradiction) {
            return { type: "negation", proposition: c.left };
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function disjunctiveSyllogism(p1, p2) {
        /**
         * 두 명제가 서로 모순 관계인지 확인하는 헬퍼 함수.
         * 예: (P, ~P) 또는 (~P, P)는 참을 반환합니다.
         * @param {object} propA - 명제 객체 1
         * @param {object} propB - 명제 객체 2
         * @returns {boolean} 모순 관계이면 true
         */
        const areContradictory = (propA, propB) => {
          // propA가 ~X이고 propB가 X인 경우
          if (
            propA.type === "negation" &&
            arePropositionsEqual(propA.proposition, propB)
          ) {
            return true;
          }
          // propB가 ~X이고 propA가 X인 경우
          if (
            propB.type === "negation" &&
            arePropositionsEqual(propB.proposition, propA)
          ) {
            return true;
          }
          return false;
        };

        /**
         * 선언적 삼단논법을 적용하는 내부 함수.
         * @param {object} d - disjunction 타입으로 추정되는 명제
         * @param {object} o - 나머지 명제
         * @returns {object|null} 추론 결과 또는 null
         */
        const check = (d, o) => {
          if (d.type !== "disjunction") return null;

          // 다른 전제(o)가 선언문의 왼쪽 부분(d.left)과 모순 관계일 때
          // 예: (P ∨ Q)와 ~P가 주어지면 Q를 반환 (이때 ~P는 ~~P와도 모순)
          if (areContradictory(d.left, o)) {
            return d.right;
          }

          // 다른 전제(o)가 선언문의 오른쪽 부분(d.right)과 모순 관계일 때
          // 예: (P ∨ Q)와 ~Q가 주어지면 P를 반환
          if (areContradictory(d.right, o)) {
            return d.left;
          }

          return null;
        };

        // p1, p2 순서와 p2, p1 순서 모두 확인
        return check(p1, p2) || check(p2, p1);
      }

      function conjunctionIntroduction(p1, p2) {
        if (!p1 || !p2) return null;
        return { type: "conjunction", left: p1, right: p2 };
      }

      function conjunctionElimination(p) {
        if (p && p.type === "conjunction") return [p.left, p.right];
        return null;
      }

      function doubleNegationElimination(p) {
        if (p && p.type === "negation" && p.proposition.type === "negation")
          return p.proposition.proposition;
        return null;
      }

      function hypotheticalSyllogism(p1, p2) {
        if (!p1 || !p2) return null;
        const check = (c1, c2) => {
          if (
            c1.type === "conditional" &&
            c2.type === "conditional" &&
            arePropositionsEqual(c1.right, c2.left)
          )
            return { type: "conditional", left: c1.left, right: c2.right };
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function existentialInstantiation(p) {
        if (p && p.type === "universal") {
          return {
            type: "existential",
            entity: p.entity,
            predicate: p.predicate,
          };
        }
        return null;
      }

      function universalApplication(p1, p2) {
        if (!p1 || !p2) return null;
        const getBaseNoun = (text) => {
          if (currentLang.langCode === "ko") {
            return text.replace(/(이다|는|은)$/, "").trim();
          } else {
            return text.replace(/^is a /, "").trim();
          }
        };
        const check = (propA, propB) => {
          if (propA.type === "atomic" && propB.type === "universal") {
            const atomicPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (atomicPredicateBase === universalEntityBase) {
              return {
                type: "atomic",
                subject: propA.subject,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "existential" && propB.type === "universal") {
            const existentialPredicateBase = getBaseNoun(propA.predicate);
            const universalEntityBase = getBaseNoun(propB.entity);
            if (existentialPredicateBase === universalEntityBase) {
              return {
                type: "existential",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          if (propA.type === "universal" && propB.type === "universal") {
            const propAPredicateBase = getBaseNoun(propA.predicate);
            const propBEntityBase = getBaseNoun(propB.entity);
            if (propAPredicateBase === propBEntityBase) {
              return {
                type: "universal",
                entity: propA.entity,
                predicate: propB.predicate,
              };
            }
          }
          return null;
        };
        return check(p1, p2) || check(p2, p1);
      }

      function reductioAdAbsurdum(p1, p2, assumption) {
        if (!p1 || !p2) return null;
        const isContradiction =
          (p1.type === "negation" &&
            arePropositionsEqual(p1.proposition, p2)) ||
          (p2.type === "negation" && arePropositionsEqual(p2.proposition, p1));
        if (isContradiction && assumption) {
          return { type: "negation", proposition: assumption };
        }
        return null;
      }

      function proofByCases(p1, p2, p3) {
        if (!p1 || !p2 || !p3) return null;
        const premises = [p1, p2, p3];
        const disjunction = premises.find((p) => p.type === "disjunction");
        if (!disjunction) return null;
        const conditionals = premises.filter((p) => p.type === "conditional");
        if (conditionals.length !== 2) return null;
        const p = disjunction.left;
        const q = disjunction.right;
        const cond1 = conditionals[0];
        const cond2 = conditionals[1];
        const caseA =
          arePropositionsEqual(cond1.left, p) &&
          arePropositionsEqual(cond2.left, q) &&
          arePropositionsEqual(cond1.right, cond2.right);
        const caseB =
          arePropositionsEqual(cond1.left, q) &&
          arePropositionsEqual(cond2.left, p) &&
          arePropositionsEqual(cond1.right, cond2.right);
        if (caseA || caseB) {
          return cond1.right;
        }
        return null;
      }

      function isContradictory(newProp, allTrueProps) {
        for (const trueProp of allTrueProps) {
          if (
            trueProp.type === "negation" &&
            arePropositionsEqual(newProp, trueProp.proposition)
          )
            return true;
          if (
            newProp.type === "negation" &&
            arePropositionsEqual(newProp.proposition, trueProp)
          )
            return true;
        }
        if (newProp.type === "atomic" || newProp.type === "universal") {
          const predicatePairs = currentLang.contradictoryPredicates;
          let oppositePredicate = null;
          for (const key in predicatePairs) {
            if (key === newProp.predicate) {
              oppositePredicate = predicatePairs[key];
              break;
            }
            if (predicatePairs[key] === newProp.predicate) {
              oppositePredicate = key;
              break;
            }
          }
          if (oppositePredicate) {
            for (const trueProp of allTrueProps) {
              if (trueProp.type === newProp.type) {
                const sameSubject =
                  (newProp.type === "atomic" &&
                    trueProp.subject === newProp.subject) ||
                  (newProp.type === "universal" &&
                    trueProp.entity === newProp.entity);
                if (sameSubject && trueProp.predicate === oppositePredicate) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }

      function verifyAndExpandTruths(
        newProposition,
        initialTruths = internalTruthSet
      ) {
        let knownTruths = [...initialTruths];

        // 1. newProposition이 null이 아닐 경우에만 초기 모순 검사를 수행합니다.
        if (newProposition && isContradictory(newProposition, knownTruths)) {
          return { success: false, expandedSet: null };
        }

        // 2. 모순이 없을 경우, newProposition이 null이 아닐 경우에만 집합에 추가합니다.
        if (
          newProposition &&
          !knownTruths.some((p) => arePropositionsEqual(p, newProposition))
        ) {
          knownTruths.push(newProposition);
        }

        let newTruthsFoundInIteration = true;
        let iterations = 0;
        const maxIterations = 50; // 깊이는 50으로 유지

        // 2. 더 이상 새로운 결론이 나오지 않을 때까지 모든 조합을 반복적으로 검사합니다.
        while (newTruthsFoundInIteration && iterations < maxIterations) {
          newTruthsFoundInIteration = false;
          iterations++;

          const currentSnapshot = [...knownTruths]; // 현재까지 알려진 모든 진실의 스냅샷

          // ★★★ 핵심 수정: 기존의 모든 명제들끼리 서로 비교하는 완전 탐색 (N x N)
          for (let i = 0; i < currentSnapshot.length; i++) {
            const p1 = currentSnapshot[i];

            // 1개의 전제만 필요한 규칙들을 먼저 적용합니다.
            const onePremiseRules = [
              doubleNegationElimination,
              conjunctionElimination,
              existentialInstantiation,
            ];
            for (const rule of onePremiseRules) {
              const results = rule(p1);
              if (results) {
                const resultArray = Array.isArray(results)
                  ? results
                  : [results];
                for (const result of resultArray) {
                  if (isContradictory(result, knownTruths))
                    return { success: false, expandedSet: null };
                  if (
                    !knownTruths.some((p) => arePropositionsEqual(p, result))
                  ) {
                    knownTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }

            // 2개의 전제가 필요한 규칙들을 적용합니다.
            for (let j = 0; j < currentSnapshot.length; j++) {
              if (i === j) continue;
              const p2 = currentSnapshot[j];
              const twoPremiseRules = [
                modusPonens,
                modusTollens,
                hypotheticalSyllogism,
                disjunctiveSyllogism,
                universalApplication,
              ];

              for (const rule of twoPremiseRules) {
                const result = rule(p1, p2);
                if (result) {
                  if (isContradictory(result, knownTruths))
                    return { success: false, expandedSet: null };
                  if (
                    !knownTruths.some((p) => arePropositionsEqual(p, result))
                  ) {
                    knownTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }
          }
        }

        return { success: true, expandedSet: knownTruths };
      }

      function isValidPlay(cardToPlay, proposition) {
        if (inTutorialMode) {
          const highlightedCard = document.querySelector(".tutorial-highlight");
          return (
            highlightedCard && highlightedCard.textContent === cardToPlay.text
          );
        }

        const propLength = proposition.length;
        const { if: ifKeyword, and, or, not } = currentLang.keywords;
        const isConnective = (card) => [ifKeyword, and, or].includes(card.text);
        const [properNoun, quantifier, entity, predicate, operator] =
          currentLang.cardTypes;

        if (propLength === 0) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const lastCardInfo = proposition[propLength - 1];

        if (cardToPlay.text === not) {
          // '는 거짓이다'가 적용될 절(clause)을 찾습니다.
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const clauseToNegate =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : [...proposition];
          const newClauseWithNegation = [
            ...clauseToNegate,
            { card: cardToPlay, player: currentPlayer },
          ];
          return parsePropositionFromCards(newClauseWithNegation) !== null;
        }

        if (isConnective(cardToPlay)) {
          if (proposition.some((info) => isConnective(info.card))) return false;
          const connectiveIndex = proposition
            .map((info) => info.card)
            .findIndex(isConnective);
          const partToCheck =
            connectiveIndex > -1
              ? proposition.slice(connectiveIndex + 1)
              : proposition;
          return parsePropositionFromCards(partToCheck) !== null;
        }

        if (isConnective(lastCardInfo.card)) {
          return (
            cardToPlay.type === properNoun || cardToPlay.type === quantifier
          );
        }

        const connectiveIndex = proposition
          .map((info) => info.card)
          .findIndex(isConnective);
        const currentSimpleProp =
          connectiveIndex > -1
            ? proposition.slice(connectiveIndex + 1)
            : proposition;

        if (currentSimpleProp.length === 1) {
          const lastType = currentSimpleProp[0].card.type;
          if (lastType === properNoun) return cardToPlay.type === predicate;
          if (lastType === quantifier) return cardToPlay.type === entity;
        }
        if (currentSimpleProp.length === 2) {
          if (
            currentSimpleProp[0].card.type === quantifier &&
            currentSimpleProp[1].card.type === entity
          ) {
            return cardToPlay.type === predicate;
          }
        }
        return false;
      }

      function checkNextTurn() {
        if (gameIsOver || inTutorialMode) return; // 게임오버, 튜토리얼 중에는 실행 안 함

        clearAllAITimeouts(); // 기존에 예약된 AI 동작이 있다면 모두 취소

        if (isThinkingTime) {
          // --- 사유 시간일 때의 턴 관리 ---
          // 현재 생각해야 할 플레이어가 AI라면, AI의 사유 시간 턴을 예약
          if (isPlayerAI[thinkingTimeTurn]) {
            aiTimeoutId = setTimeout(aiThinkingTimeTurn, 1500);
          }
          // 사람이 턴이라면, 아무것도 하지 않고 사용자 입력을 기다림
        } else {
          // --- 일반 턴일 때의 턴 관리 ---
          // 현재 턴의 플레이어가 AI라면, AI의 일반 턴을 예약
          if (isPlayerAI[currentPlayer]) {
            const delay = gameMode === "AI_VS_AI" ? 250 : 1500;
            aiTimeoutId = setTimeout(aiTurn, delay);
          }
          // 사람이 턴이라면, 행동 가능 여부만 체크 (행동 없으면 사유 시간 전환)
          else {
            checkRoundEndConditions();
          }
        }
      }
      function endTurn() {
        // 사유 시간 중일 때의 턴 종료 로직
        if (isThinkingTime) {
          audioManager.playSfx("end");
          // 해당 라운드를 먼저 시작했던 플레이어 (사유 시간에는 두 번째로 행동함)
          const roundStarter = currentRound % 2 === 1 ? "A" : "B";

          // 지금 턴을 마친 플레이어가 '두 번째' 순서라면, 사유 시간을 완전히 종료합니다.
          if (thinkingTimeTurn === roundStarter) {
            endThinkingTime();
          } else {
            // '첫 번째' 순서의 플레이어라면, 턴을 상대에게 넘깁니다.
            thinkingTimeTurn = roundStarter;

            if (gameMode === "AI" && thinkingTimeTurn === aiPlayer) {
              clearAllAITimeouts();
              aiTimeoutId = setTimeout(aiThinkingTimeTurn, 2000);
            }
            render();

            // ✅ [핵심 수정]
            // 두 번째 AI에게 턴을 넘겼으니, 턴 관리자(checkNextTurn)를 호출해서
            // 두 번째 AI의 턴을 실제로 시작시킵니다.
            checkNextTurn();
          }
          return;
        }

        // --- 이하 일반 턴 종료 로직 (수정 없음) ---
        if (cardsPlayedThisTurn[currentPlayer] === 0) return;

        audioManager.playSfx("end");

        const playerWhoEndedTurn = currentPlayer;
        cardsPlayedThisTurn[playerWhoEndedTurn] = 0;

        currentPlayer = currentPlayer === "A" ? "B" : "A";

        render();
        checkNextTurn();
      }

      function activateAbility(player) {
        if (inTutorialMode) {
          return; // 튜토리얼 모드에서는 아무것도 하지 않고 즉시 함수를 종료합니다.
        }
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;

        const state = abilityUsedState[player];
        if (state) {
          // 흄의 경우 usedCount가 maxUses 이상인지 확인
          if (philosopherId === "hume" && state.usedCount >= state.maxUses) {
            showAlert(
              currentLang.langCode === "ko"
                ? "이미 능력을 모두 사용했습니다."
                : "Ability has already been used up."
            );
            return;
          }
          // 그 외 철학자는 기존 방식대로 used 플래그 확인
          else if (philosopherId !== "hume" && state.used) {
            showAlert(
              currentLang.langCode === "ko"
                ? "이미 능력을 사용했습니다."
                : "Ability has already been used."
            );
            return;
          }
        }

        console.log(`Activating ability for ${philosopherId}`);
        switch (philosopherId) {
          case "plato":
            activatePlatoAbility(player); // 이 부분을 수정합니다.
            break;
          case "socrates":
            activateSocratesAbility(player);
            break;
          case "descartes":
            activateDescartesAbility(player);
            break;
          case "wittgenstein":
            activateWittgensteinAbility(player);
            break;
          case "derrida":
            activateDerridaAbility(player);
            break;
          case "hume":
            activateHumeAbility(player);
            break;
          case "kuhn":
            activateKuhnAbility(player);
            break;
          case "kant":
            activateKantAbility(player);
            break;

          // ... 다른 모든 철학자들의 능력 호출 ...
          default:
            showAlert(
              currentLang.langCode === "ko"
                ? "이 철학자는 사용할 수 있는 능력이 없습니다."
                : "This philosopher has no active ability."
            );
        }
      }

      function updateAbilityButtonsState() {
        // 플레이어 A의 능력 버튼 상태를 가져옵니다.
        const stateA = getAbilityButtonStateFor("A");
        const buttonA = document.getElementById("ability-a");
        buttonA.style.display = stateA.visible ? "block" : "none";
        buttonA.disabled = stateA.disabled;
        buttonA.textContent = stateA.text;

        // 플레이어 B의 능력 버튼 상태를 가져옵니다.
        const stateB = getAbilityButtonStateFor("B");
        const buttonB = document.getElementById("ability-b");
        buttonB.style.display = stateB.visible ? "block" : "none";
        buttonB.disabled = stateB.disabled;
        buttonB.textContent = stateB.text;
      }

      function getAbilityButtonStateFor(player) {
        // 기본값: 버튼은 보이지 않고 비활성화 상태
        const defaultState = { visible: false, disabled: true, text: "" };

        // 현재 게임이 진행 중이 아니거나, 해당 플레이어의 철학자 정보가 없으면 기본 상태 반환
        if (
          gameIsOver ||
          (player === "A" && !playerA_Data) ||
          (player === "B" && !playerB_Data)
        ) {
          return defaultState;
        }

        const philosopherData = player === "A" ? playerA_Data : playerB_Data;
        const philosopherId = philosopherData.id;

        // 해당 철학자의 능력이 이미 사용되었다면 기본 상태 반환
        if (abilityUsedState[player] && abilityUsedState[player].used) {
          return defaultState;
        }

        // ⭐ 앞으로 모든 능력의 조건은 이 switch 문 안에 추가됩니다.
        switch (philosopherId) {
          case "plato":
            // 능력 사용 조건: '사유 시간'일 때 항상 버튼을 표시
            if (isThinkingTime) {
              return {
                visible: true,
                // 자기 턴이 아닐 때(!==) 비활성화(disabled: true)
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }

            break; // platocase 끝

          case "socrates":
            // 사유 시간이고, 사용 횟수가 남아있을 때 버튼 표시
            if (
              isThinkingTime &&
              abilityUsedState[player].usedCount <
                abilityUsedState[player].maxUses
            ) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          case "nietzsche":
            // 니체의 능력은 패시브이므로, 활성화 버튼이 필요 없습니다.
            // 따라서 아무것도 반환하지 않고 그냥 break 합니다.
            break;

          case "descartes":
            if (isThinkingTime) {
              return {
                visible: true,
                // 자신의 사유 시간 턴이 아닐 경우 버튼을 비활성화합니다.
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          case "wittgenstein":
            if (isThinkingTime) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // 자신의 턴일 때만 활성화
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          case "derrida":
            if (isThinkingTime) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // 자신의 턴일 때만 활성화
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;
          case "hume":
            // 사유 시간이고, 사용 횟수가 남아있을 때 버튼 표시
            if (
              isThinkingTime &&
              abilityUsedState[player].usedCount <
                abilityUsedState[player].maxUses
            ) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // 자신의 턴일 때만 활성화
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;
          case "kuhn":
            // 플레이어가 카드를 놓아 생성한 명제만 카운트
            const userMadePropsCount = truePropositions.filter(
              (p) => p.type === "user-made"
            ).length;

            if (isThinkingTime && userMadePropsCount >= 15) {
              return {
                visible: true,
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player), // 자신의 턴일 때만 활성화
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;
          case "kant":
            // 사유 시간이고, 아직 능력을 사용하지 않았을 때 버튼 표시
            if (isThinkingTime && !abilityUsedState[player]?.used) {
              return {
                visible: true,
                // 자신의 턴이 아니면 비활성화
                disabled:
                  thinkingTimeTurn !== player ||
                  (isPlayerAI[player] && thinkingTimeTurn === player),
                text: currentLang.ui.useAbilityButton,
              };
            }
            break;

          // --- 여기에 새로운 철학자들의 case를 계속 추가 ---
          // case 'descartes':
          //     if (isThinkingTime && thinkingTimeTurn === player) { ... }
          //     break;
        }

        // 위 switch 문에서 아무 조건도 맞지 않으면 기본 상태를 반환합니다.
        return defaultState;
      }

      /**
       * 상대방의 손패를 분석하여 위협적인 카드 정보를 반환합니다.
       * @param {Array} opponentHand - 상대방의 카드 객체 배열.
       * @param {string} myCorePredicate - AI의 승리 조건과 직결된 핵심 서술어.
       * @param {object} langData - 현재 언어 설정 데이터 (TEXTS.ko 또는 TEXTS.en).
       * @returns {{hasNegation: boolean, hasContradictoryToMyWinCon: boolean}}
       * - hasNegation: 부정 카드('는 거짓이다') 존재 여부
       * - hasContradictoryToMyWinCon: AI의 승리 조건과 모순되는 서술어 존재 여부
       */
      function analyzeOpponentThreats(opponentHand, myCorePredicate, langData) {
        const threats = {
          hasNegation: false,
          hasContradictoryToMyWinCon: false,
        };

        // AI의 핵심 서술어와 모순되는 서술어 찾기
        let contradictoryPredicate = null;
        const predicatePairs = langData.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === myCorePredicate) {
            contradictoryPredicate = predicatePairs[key];
            break;
          }
          if (predicatePairs[key] === myCorePredicate) {
            contradictoryPredicate = key;
            break;
          }
        }

        // 상대방 손패 순회
        for (const card of opponentHand) {
          // 부정 카드 확인
          if (card.text === langData.keywords.not) {
            threats.hasNegation = true;
          }
          // AI 승리 조건과 모순되는 서술어 카드 확인
          if (
            card.type === langData.cardTypes[3] /* 서술어 or Predicate */ &&
            card.text === contradictoryPredicate
          ) {
            threats.hasContradictoryToMyWinCon = true;
          }
        }

        return threats;
      }

      /**
       * AI의 승리 조건을 달성하기 위한 모든 잠재적 '계획'을 생성하고 점수를 매기는 함수
       * @returns {object | null} 가장 점수가 높은 최적의 계획 객체 또는 null
       */
      function generateAndScorePlans() {
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === aiPlayer
        );
        if (!myVictoryData) return null;
        const goalPredicate = myVictoryData.core_goal.predicate;

        // '모든 [개체]는 ...' 이 이미 참 명제 목록에 있는 경우만 찾습니다.
        const allUniversalProps = internalTruthSet.filter(
          (p) => p.type === "universal"
        );
        if (allUniversalProps.length === 0) return null;

        // 예: '모든 개는 동물이다'가 참일 때, '소크라테스는 개이다'만 만들면 이길 수 있는 계획
        for (const universalProp of allUniversalProps) {
          // 만약 '모든 [A]는 [나의 승리서술어]' 형태의 명제가 이미 있다면,
          if (universalProp.predicate === goalPredicate) {
            const entityText = universalProp.entity; // 예: '개는'
            let predicateText; // 서술어 텍스트를 담을 변수 선언

            if (currentLang.langCode === "ko") {
              // 한국어 모드: 기존 로직을 유지 (완벽하진 않지만 의도는 보존)
              // "개는" -> "개이다"
              predicateText = entityText.replace(/는$/, "이다");
            } else {
              // 영어 모드: 새로운 변환 규칙 적용
              // "dog" -> "is a dog"
              predicateText = "is a " + entityText;
            }

            // 완성된 서술어를 사용해 최종 명제를 구성
            const neededPropText = `${myVictoryData.core_goal.subject} ${predicateText}`;
            const neededProp = parsePropositionFromString(neededPropText);

            // 그 명제가 아직 참이 아니라면, 이것을 최우선 계획으로 삼습니다.
            if (
              neededProp &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, neededProp))
            ) {
              return {
                name: `FINISH_HIM_${entityText}`,
                score: 9000, // 압도적인 점수
                // 실행 로직은 aiTurn에서 직접 처리하므로, 여기서는 목표만 제시
                targetPropositionText: neededPropText,
              };
            }
          }
        }
        return null;
      }
      function aiThinkingTimeTurn() {
        const summaryActions = []; // 이번 턴에 AI가 수행한 모든 행동을 기록
        const aiPhilosopherData =
          thinkingTimeTurn === "A" ? playerA_Data : playerB_Data;
        const philosopherId = aiPhilosopherData.id;

        // 1단계: 새로운 정리 도출 시도
        const candidateTheorems = generateCandidateTheorems();
        if (candidateTheorems.length > 0) {
          const scoredTheorems = scoreCandidateTheorems(candidateTheorems);
          const theoremActions = executeTheoremDerivation(scoredTheorems);
          if (theoremActions.length > 0) {
            summaryActions.push(...theoremActions);
          }
        }

        // --- 2단계: 능력 사용 로직 (수정된 부분) ---

        // 플라톤 능력 체크 (단일 사용)
        if (philosopherId === "plato") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // 👈 수정
            const abilityAction = executePlatoAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }

        // 소크라테스 능력 체크 (다중 사용)
        if (philosopherId === "socrates") {
          while (
            abilityUsedState[thinkingTimeTurn] && // 👈 수정
            abilityUsedState[thinkingTimeTurn].usedCount < // 👈 수정
              abilityUsedState[thinkingTimeTurn].maxUses // 👈 수정
          ) {
            const abilityAction = executeSocratesAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            } else {
              break;
            }
          }
        }

        // 데카르트 능력 체크 (단일 사용)
        if (philosopherId === "descartes") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // 👈 수정
            const abilityAction =
              executeDescartesAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        // 흄 능력 체크 (2회 사용)
        if (philosopherId === "hume") {
          while (
            abilityUsedState[thinkingTimeTurn] && // 👈 수정
            abilityUsedState[thinkingTimeTurn].usedCount < // 👈 수정
              abilityUsedState[thinkingTimeTurn].maxUses // 👈 수정
          ) {
            const abilityAction = executeHumeAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            } else {
              break;
            }
          }
        }
        if (philosopherId === "wittgenstein") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // 👈 수정
            const abilityAction =
              executeWittgensteinAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        if (philosopherId === "kuhn") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // 👈 수정
            const abilityAction = executeKuhnAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        // 데리다 능력 체크 (단일 사용)
        if (philosopherId === "derrida") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // 👈 수정
            const abilityAction = executeDerridaAbilityCheck(thinkingTimeTurn);
            if (abilityAction) {
              summaryActions.push(abilityAction);
            }
          }
        }
        if (philosopherId === "kant") {
          if (!abilityUsedState[thinkingTimeTurn]?.used) {
            // 👈 수정
            const kantAction = executeKantAbilityCheck(thinkingTimeTurn);
            if (kantAction) {
              summaryActions.push(kantAction);
            }
          }
        }

        // ... 여기에 다른 철학자들의 능력 체크 로직 추가 가능 ...

        // 3단계: 최종적으로 게임 상태를 렌더링하고 턴을 넘김
        render();

        if (summaryActions.length > 0) {
          if (gameMode === "AI_VS_AI") {
            endTurn();
          } else {
            showAITurnSummary(summaryActions);
          }
        } else {
          console.log("AI found no valuable actions. Passing turn.");
          endTurn();
        }
      }
      function generateCandidateTheorems() {
        const knownTruths = [...internalTruthSet];
        const candidates = new Map(); // Map을 사용해 이번 턴에 중복 생성되는 것만 막습니다.

        // 후보 목록에 '새로운' 정리만 추가하던 기존 로직을 수정합니다.
        const addCandidate = (prop) => {
          // 1. 유효한 명제인지, 그리고 이번 턴에서 이미 생성된 후보가 아닌지 확인
          if (prop) {
            const propText = propositionToNaturalText(prop);
            if (candidates.has(propText)) {
              return; // 이미 이번 턴에 고려된 후보이므로 중단
            }

            // 2. 이미 게임의 '참 명제 목록'에 존재하는지 확인 (핵심 수정)
            const isAlreadyKnown = truePropositions.some(
              (p) => p.proposition && arePropositionsEqual(p.proposition, prop)
            );
            // 3. 아직 알려지지 않은 새로운 명제일 경우에만 후보로 추가
            if (!isAlreadyKnown) {
              candidates.set(propText, prop);
            }
          }
        };

        // --- 이하 모든 추론 규칙 적용 로직은 기존과 동일합니다. ---

        // 1개의 전제가 필요한 규칙들
        for (const p1 of knownTruths) {
          const onePremiseRules = [
            doubleNegationElimination,
            conjunctionElimination,
            existentialInstantiation,
          ];
          for (const rule of onePremiseRules) {
            const results = rule(p1);
            if (results) {
              const resultArray = Array.isArray(results) ? results : [results];
              resultArray.forEach(addCandidate);
            }
          }
        }

        // 2개의 전제가 필요한 규칙들
        for (let i = 0; i < knownTruths.length; i++) {
          for (let j = 0; j < knownTruths.length; j++) {
            if (i === j) continue;
            const p1 = knownTruths[i];
            const p2 = knownTruths[j];
            const twoPremiseRules = [
              modusPonens,
              modusTollens,
              hypotheticalSyllogism,
              disjunctiveSyllogism,
              universalApplication,
            ];
            for (const rule of twoPremiseRules) {
              const result = rule(p1, p2);
              addCandidate(result);
            }
          }
        }

        // 3개의 전제가 필요한 규칙 (경우 논증)
        const disjunctions = knownTruths.filter(
          (p) => p.type === "disjunction"
        );
        const conditionals = knownTruths.filter(
          (p) => p.type === "conditional"
        );

        if (disjunctions.length > 0 && conditionals.length >= 2) {
          for (const dis of disjunctions) {
            for (let i = 0; i < conditionals.length; i++) {
              for (let j = i + 1; j < conditionals.length; j++) {
                const result = proofByCases(
                  dis,
                  conditionals[i],
                  conditionals[j]
                );
                addCandidate(result);
              }
            }
          }
        }

        console.log(
          "Generated Candidate Theorems:",
          Array.from(candidates.values()).map((p) =>
            propositionToNaturalText(p)
          )
        );
        return Array.from(candidates.values());
      }

      function scoreCandidateTheorems(candidates) {
        const opponentPlayer = thinkingTimeTurn === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === thinkingTimeTurn
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryData || !opponentVictoryData) return [];

        const myCoreGoal = myVictoryData.core_goal;
        const myUltimateGoal = myVictoryData.ultimate_target;

        const opponentCoreGoal = opponentVictoryData.core_goal;
        const opponentUltimateGoal = opponentVictoryData.ultimate_target;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentUltimateGoal,
        };

        const opponentDefeatPredicate =
          currentLang.contradictoryPredicates[opponentCoreGoal.predicate] ||
          Object.keys(currentLang.contradictoryPredicates).find(
            (key) =>
              currentLang.contradictoryPredicates[key] ===
              opponentCoreGoal.predicate
          );

        const scored = candidates.map((candidate) => {
          let score = 10;

          if (arePropositionsEqual(candidate, myUltimateGoal)) score += 1000000;
          if (arePropositionsEqual(candidate, opponentLossCondition))
            score += 1000000;

          if (arePropositionsEqual(candidate, opponentUltimateGoal))
            score -= 500000;

          if (arePropositionsEqual(candidate, myCoreGoal)) score += 500;
          if (arePropositionsEqual(candidate, opponentCoreGoal)) score -= 1000;

          if (candidate.type === "universal") {
            if (candidate.predicate === myCoreGoal.predicate) {
              score += 200;
            }
            if (
              opponentDefeatPredicate &&
              candidate.predicate === opponentDefeatPredicate
            ) {
              score += 200;
            }
            if (candidate.predicate === opponentCoreGoal.predicate) {
              score -= 400;
            }
          } else if (candidate.type === "existential") {
            if (candidate.predicate === myCoreGoal.predicate) {
              score += 200;
            }
            if (
              opponentDefeatPredicate &&
              candidate.predicate === opponentDefeatPredicate
            ) {
              score += 200;
            }
            if (candidate.predicate === opponentCoreGoal.predicate) {
              score -= 400;
            }
          }

          const simulatedTruths = [...internalTruthSet, candidate];
          if (aiFindProof(opponentUltimateGoal, simulatedTruths)) {
            score -= 2000;
          }

          return { proposition: candidate, score: score };
        });

        scored.sort((a, b) => b.score - a.score);
        console.log("Scored Theorems:", scored);
        return scored;
      }
      function executeTheoremDerivation(scoredTheorems) {
        const MINIMUM_SCORE_THRESHOLD = 50;
        const actions = [];
        const addedThisTurn = [];

        for (const scoredTheorem of scoredTheorems) {
          if (scoredTheorem.score >= MINIMUM_SCORE_THRESHOLD) {
            const candidateProp = scoredTheorem.proposition;
            const isDuplicateThisTurn = addedThisTurn.some((p) =>
              arePropositionsEqual(p, candidateProp)
            );
            if (isDuplicateThisTurn) {
              continue;
            }

            actions.push({ type: "theorem", proposition: candidateProp });
            truePropositions.push({
              propId: `prop_${Date.now()}_${Math.random()}`,
              type: "theorem",
              round: currentRound,
              proposition: candidateProp,
            });
            addedThisTurn.push(candidateProp);
          }
        }
        return actions; // 실행한 행동 목록을 반환
      }
      function showAITurnSummary(actions) {
        const modal = document.getElementById("ai-turn-summary-modal");
        const titleEl = document.getElementById("ai-summary-title");
        const contentEl = document.getElementById("ai-summary-content");
        const okBtn = document.getElementById("ai-summary-ok-btn");

        // 모달 내용 초기화
        contentEl.innerHTML = "";
        okBtn.textContent = currentLang.ui.okButton;

        // 제목 설정
        titleEl.textContent = currentLang.ui.aiSummaryTitleDefault; // 기본 제목

        // 행동 내역에 따라 내용 채우기 (확장성 고려)
        actions.forEach((action) => {
          const p = document.createElement("p");
          switch (action.type) {
            case "theorem":
              titleEl.textContent = currentLang.ui.aiSummaryTitleTheorem;
              p.innerHTML = `<strong>${
                currentLang.ui.theoremLabel
              }</strong> ${propositionToNaturalText(action.proposition)}`;
              break;
            case "ability":
              titleEl.textContent = currentLang.ui.aiSummaryTitleAbility;
              p.innerHTML = `<strong>${currentLang.ui.abilityLabel}</strong> ${action.description}`;
              break;
            // 향후 다른 행동 유형 추가 가능
          }
          contentEl.appendChild(p);
        });

        // 확인 버튼 클릭 이벤트 설정 (기존 리스너 제거 후 새로 추가)
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);

        newOkBtn.addEventListener("click", () => {
          modal.classList.remove("visible");
          // ★★★ 중요: 모달을 닫은 후에 턴을 종료합니다.
          endTurn();
        });

        modal.classList.add("visible");
      }

      function isBoardDangerous(opponentVictoryData) {
        if (currentProposition.length === 0) return null;
        const parsedProp = parsePropositionFromCards(currentProposition);
        if (!parsedProp || !opponentVictoryData) return null;

        // 위협 유형 1: 상대의 핵심 승리 조건과 '직접 일치'하는 경우
        if (arePropositionsEqual(parsedProp, opponentVictoryData.core_goal)) {
          console.log("Threat Detected (Type 1: Direct Match)");
          return parsedProp;
        }

        // 위협 유형 2: 이 명제를 참으로 인정할 경우, 상대의 승리가 '추론 가능'해지는 경우
        const simulatedTruths = [...internalTruthSet, parsedProp];
        if (aiFindProof(opponentVictoryData.ultimate_target, simulatedTruths)) {
          console.log("Threat Detected (Type 2: Inferred Defeat)");
          return parsedProp;
        }

        return null;
      }

      function isBoardCompletable() {
        // 명제판에 카드가 없으면 완성 불가능
        if (currentProposition.length === 0) return false;
        // AI 자신이 마지막 카드를 냈다면 완성 불가능 (상대 턴에만 완성 가능)
        if (lastCardPlayer === aiPlayer) return false;

        // 문법적으로 완성 가능한 명제인지 확인
        const parsedProp = parsePropositionFromCards(currentProposition);
        return parsedProp !== null;
      }

      function assessOpponentAdvantage(proposition, opponentVictoryData) {
        if (!proposition || !opponentVictoryData) return 0;

        // ★★★ 핵심 수정: 평가 전에 명제를 정규화합니다. ★★★
        const normalizedProp = normalizeProposition(proposition);

        let penalty = 0;
        const opponentCoreGoal = opponentVictoryData.core_goal;
        const opponentSubject = opponentCoreGoal.subject;
        const opponentPredicate = opponentCoreGoal.predicate;

        if (normalizedProp.type === "atomic") {
          if (
            normalizedProp.subject === opponentSubject &&
            normalizedProp.predicate === opponentPredicate
          ) {
            penalty += 1500;
          }
        } else if (
          normalizedProp.type === "existential" ||
          normalizedProp.type === "universal"
        ) {
          if (normalizedProp.predicate === opponentPredicate) {
            penalty += normalizedProp.type === "universal" ? 3000 : 1800;
          }
        }
        return penalty;
      }
      function aiCanActuallyComplete() {
        if (!isBoardCompletable()) return false;

        const propToComplete = parsePropositionFromCards(currentProposition);
        if (!propToComplete) return false;

        const aiPhilosopherId =
          currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
        if (aiPhilosopherId !== "nietzsche") {
          const isAxiom = parsedAxioms.some((a) =>
            arePropositionsEqual(a.proposition, propToComplete)
          );
          const isAlreadyProven = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, propToComplete)
          );
          if (isAxiom || isAlreadyProven) {
            return false;
          }
        }

        // 모순 검사는 니체를 포함한 모든 철학자에게 동일하게 적용됩니다.
        const verificationResult = verifyAndExpandTruths(propToComplete);
        return verificationResult.success;
      }

      function isImmediateWinSecure(opponentHand, aiHand, langData) {
        const {
          if: ifKeyword,
          or: orKeyword,
          not: notKeyword,
        } = langData.keywords;

        // 조건 1: 상대 핸드에 '라면' 또는 '또는' 카드가 있어서 명제를 이어갈 수 있는지 확인
        const opponentCanExtend = opponentHand.some(
          (card) => card.text === ifKeyword || card.text === orKeyword
        );

        if (opponentCanExtend) {
          // 상대가 명제를 연장하여 턴을 넘길 수 있다면, 즉시 승리가 아님
          return false;
        }

        // 조건 2: 상대의 부정 카드('는 거짓이다') 보유 여부 확인
        const opponentHasNot = opponentHand.some(
          (card) => card.text === notKeyword
        );

        if (!opponentHasNot) {
          // 상대에게 부정 카드가 없으면, 내 승리를 막을 수 없으므로 안전함
          return true;
        } else {
          // 상대에게 부정 카드가 있다면, 나에게도 부정 카드가 있어야만 안전함
          // (상대의 부정을 나의 이중 부정으로 되받아칠 수 있기 때문)
          const aiHasNot = aiHand.some((card) => card.text === notKeyword);
          return aiHasNot;
        }
      }

      function checkForGuaranteedWinMove() {
        // 1. 기본 조건 확인: 명제판에 카드가 2장 이상 있어야 함
        if (currentProposition.length < 2) {
          return null;
        }

        const propLength = currentProposition.length;
        const lastCardInfo = currentProposition[propLength - 1];
        const secondLastCardInfo = currentProposition[propLength - 2];

        // 2. '는 거짓이다' 카드 보유 상황 대칭성 확인
        const { not: notKeyword } = currentLang.keywords;
        const aiHand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const opponentHand =
          currentPlayer === "A" ? playerB_Hand : playerA_Hand;

        const aiHasNot = aiHand.some((card) => card.text === notKeyword);
        const opponentHasNot = opponentHand.some(
          (card) => card.text === notKeyword
        );

        if (aiHasNot !== opponentHasNot) {
          return null;
        }

        // 3. 마지막 카드가 '나' 또는 '상대'의 이름(고유명사)인지 확인
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner !== currentPlayer
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        const mySubject = myVictoryData.core_goal.subject;
        const opponentSubject = opponentVictoryData.core_goal.subject;

        if (
          lastCardInfo.card.type !==
            (currentLang.langCode === "ko" ? "고유명사" : "Proper Noun") ||
          (lastCardInfo.card.text !== mySubject &&
            lastCardInfo.card.text !== opponentSubject)
        ) {
          return null;
        }

        // 4. 3가지 패턴 확인
        const {
          and: andKeyword,
          if: ifKeyword,
          or: orKeyword,
        } = currentLang.keywords;
        let isWinningOpportunity = false;

        // 패턴 1: ... 그리고 [이름]
        if (secondLastCardInfo.card.text === andKeyword) {
          isWinningOpportunity = true;
        } else {
          const firstPartCards = currentProposition.slice(0, propLength - 2);
          const parsedFirstPart = parsePropositionFromCards(firstPartCards);

          if (parsedFirstPart) {
            // 패턴 2: (참인 명제) 라면 [이름]
            if (
              secondLastCardInfo.card.text === ifKeyword &&
              aiFindProof(parsedFirstPart, internalTruthSet)
            ) {
              isWinningOpportunity = true;
            }
            // 패턴 3: (거짓인 명제) 또는 [이름]
            else if (secondLastCardInfo.card.text === orKeyword) {
              const negationOfFirstPart = {
                type: "negation",
                proposition: parsedFirstPart,
              };
              if (aiFindProof(negationOfFirstPart, internalTruthSet)) {
                isWinningOpportunity = true;
              }
            }
          }
        }

        // 5. 기회가 맞다면, 상황에 맞는 올바른 술어 카드를 찾아 반환
        if (isWinningOpportunity) {
          const nameOnBoard = lastCardInfo.card.text;
          const myName = myVictoryData.core_goal.subject;
          let predicateToPlay = null;

          // Case 1: 명제판의 이름이 내 이름일 경우
          if (nameOnBoard === myName) {
            // 나의 승리 술어를 찾는다.
            predicateToPlay = myVictoryData.core_goal.predicate;
            console.log(
              `[AI Logic] Pattern matched with my name. Seeking predicate: ${predicateToPlay}`
            );
          }
          // Case 2: 명제판의 이름이 상대 이름일 경우
          else {
            // 상대의 승리 술어와 '반대'되는 술어를 찾는다.
            const opponentWinPredicate =
              opponentVictoryData.core_goal.predicate;
            const predicatePairs = currentLang.contradictoryPredicates;

            predicateToPlay =
              predicatePairs[opponentWinPredicate] ||
              Object.keys(predicatePairs).find(
                (key) => predicatePairs[key] === opponentWinPredicate
              );
            console.log(
              `[AI Logic] Pattern matched with opponent's name. Seeking contradictory predicate: ${predicateToPlay}`
            );
          }

          // 찾아낸 술어 카드가 내 손에 있는지 확인하고, 있다면 그 카드를 반환한다.
          if (predicateToPlay) {
            const winningMove = aiHand.find(
              (card) => card.text === predicateToPlay
            );

            if (winningMove && isValidPlay(winningMove, currentProposition)) {
              console.log("확정 승리 패턴 발견! 승리 수를 둡니다.");
              return winningMove;
            }
          }
        }

        return null; // 조건에 맞지 않으면 null 반환
      }

      function scorePlans(plans, aiHand) {
        const aiHandTexts = aiHand.map((c) => c.text);

        const scored = plans.map((plan) => {
          let score = 500; // 계획이 존재 자체로 기본 점수 획득

          // 1. 계획의 단계가 짧을수록 높은 점수를 부여합니다. (단계당 200점 감점)
          score -= plan.steps.length * 200;

          // 2. 계획의 최종 단계를 손패의 카드로 완성할 수 있는지 확인합니다.
          const finalStep = plan.steps[plan.steps.length - 1];
          const finalStepText = propositionToNaturalText(finalStep);
          const cardsNeeded = finalStepText.split(" ");

          const canMakeFinalStep = cardsNeeded.every((cardText) =>
            aiHandTexts.includes(cardText)
          );

          if (canMakeFinalStep) {
            // 최종 단계를 완성할 카드를 모두 들고 있다면 매우 높은 보너스를 부여합니다.
            score += 1000;
          } else {
            // 계획의 마지막 단계를 완성할 수 없다면, 이 계획은 현재 실행 불가능합니다.
            // 점수를 매우 낮게 책정하여 선택되지 않도록 합니다.
            score = -1;
          }

          // 3. 현재 명제판의 상황을 고려하여 점수를 가감합니다.
          const currentBoardText = currentProposition
            .map((info) => info.card.text)
            .join(" ");
          if (currentBoardText === "") {
            // 명제판이 비어있다면, 계획을 바로 시작할 수 있으므로 약간의 보너스를 줍니다.
            score += 500;
          } else {
            // 명제판에 카드가 있을 때, 그 위에 바로 이어갈 수 있는 계획이라면 높은 보너스를 줍니다.
            if (finalStepText.startsWith(currentBoardText)) {
              score += 1000;
            }
          }

          plan.score = score;
          plan.targetPropositionText = finalStepText; // aiTurn에서 사용할 수 있도록 텍스트 저장

          return plan;
        });

        // 실행 불가능한 계획(점수 -1)을 걸러냅니다.
        return scored.filter((p) => p.score > 0);
      }

      function generateWinningPlan() {
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        if (!myVictoryData) return null;

        const myCoreGoal = myVictoryData.core_goal;
        let allPossiblePlans = [];
        findAllProofPaths(myCoreGoal, [], allPossiblePlans, 0);

        if (allPossiblePlans.length === 0) return null;

        // 각 계획의 점수를 계산합니다.
        const scoredPlans = scorePlans(
          allPossiblePlans,
          currentPlayer === "A" ? playerA_Hand : playerB_Hand
        );

        if (scoredPlans.length === 0) return null;

        // 가장 점수가 높은 계획을 선택합니다.
        scoredPlans.sort((a, b) => b.score - a.score);
        return scoredPlans[0];
      }

      function findAllProofPaths(goal, path, allPlans, depth) {
        if (depth > 5) return; // 탐색 깊이 제한

        // 기저 조건 1: 목표가 이미 참으로 증명되었다면, 이 경로는 완전한 계획입니다.
        if (internalTruthSet.some((p) => arePropositionsEqual(p, goal))) {
          allPlans.push({ steps: [...path] }); // 더 이상 하위 목표가 필요 없습니다.
          return;
        }

        // 기저 조건 2: 목표를 현재 손패의 카드로 만들 수 있다면, 계획으로 간주합니다.
        const cardsNeededForGoal = propositionToNaturalText(goal).split(" ");
        const aiHand = (
          currentPlayer === "A" ? playerA_Hand : playerB_Hand
        ).map((c) => c.text);
        if (cardsNeededForGoal.every((card) => aiHand.includes(card))) {
          allPlans.push({ steps: [...path, goal] });
          return;
        }

        // 순환 경로 방지: 현재 찾으려는 목표가 이미 경로에 있다면 탐색을 중단합니다.
        if (path.some((p) => arePropositionsEqual(p, goal))) {
          return;
        }

        const newPath = [...path, goal]; // 현재 목표를 경로에 추가합니다.

        // **재귀 단계**: 다양한 추론 규칙을 역으로 적용하여 하위 목표를 찾습니다.

        // 1. 전건 긍정(Modus Ponens) 역추적
        const modusPonensBridges = internalTruthSet.filter(
          (p) => p.type === "conditional" && arePropositionsEqual(p.right, goal)
        );
        for (const bridge of modusPonensBridges) {
          const subGoal = bridge.left;
          findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
        }

        // 2. 후건 부정(Modus Tollens) 역추적
        if (goal.type === "negation") {
          const p = goal.proposition; // goal = ~p
          const modusTollensBridges = internalTruthSet.filter(
            (prop) =>
              prop.type === "conditional" && arePropositionsEqual(prop.left, p)
          );
          for (const bridge of modusTollensBridges) {
            const subGoal = { type: "negation", proposition: bridge.right }; // new sub-goal = ~q
            findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
          }
        }

        // 3. 선언적 삼단논법(Disjunctive Syllogism) 역추적
        const disjunctiveBridges = internalTruthSet.filter(
          (p) => p.type === "disjunction"
        );
        for (const bridge of disjunctiveBridges) {
          let subGoal = null;
          // (P ∨ goal)을 찾았다면, 하위 목표는 ~P
          if (arePropositionsEqual(bridge.right, goal)) {
            subGoal = { type: "negation", proposition: bridge.left };
          }
          // (goal ∨ P)를 찾았다면, 하위 목표는 ~P
          else if (arePropositionsEqual(bridge.left, goal)) {
            subGoal = { type: "negation", proposition: bridge.right };
          }
          if (subGoal) {
            findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
          }
        }

        // 4. 보편 적용(Universal Application) 역추적
        if (goal.type === "atomic") {
          const universalBridges = internalTruthSet.filter(
            (p) => p.type === "universal" && p.predicate === goal.predicate
          );
          for (const bridge of universalBridges) {
            // 예: "소크라테스는 지혜롭다"를 증명하기 위해 "모든 철학자는 지혜롭다"를 찾음
            // 새로운 하위 목표: "소크라테스는 철학자이다"
            let newPredicateText;
            const entityText = bridge.entity;
            if (currentLang.langCode === "ko") {
              newPredicateText = entityText.slice(0, -1) + "이다"; // '철학자는' -> '철학자이다'
            } else {
              newPredicateText = `is a ${entityText}`; // 'philosopher' -> 'is a philosopher'
            }
            const subGoal = {
              type: "atomic",
              subject: goal.subject,
              predicate: newPredicateText,
            };
            findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
          }
        }

        // 5. 존재화(Existential Instantiation) 역추적
        if (goal.type === "existential") {
          const subGoal = {
            type: "universal",
            entity: goal.entity,
            predicate: goal.predicate,
          };
          findAllProofPaths(subGoal, newPath, allPlans, depth + 1);
        }

        // 6. 이중 부정 제거(Double Negation) 역추적
        const doubleNegationSubGoal = {
          type: "negation",
          proposition: { type: "negation", proposition: goal },
        };
        findAllProofPaths(doubleNegationSubGoal, newPath, allPlans, depth + 1);
      }
      function assessSelfDisadvantage(proposition, myVictoryData) {
        if (!proposition || !myVictoryData) return 0;

        // ★★★ 핵심 수정: 평가 전에 명제를 정규화합니다. ★★★
        const normalizedProp = normalizeProposition(proposition);

        let penalty = 0;
        const myCoreGoal = myVictoryData.core_goal;
        const mySubject = myCoreGoal.subject;
        const myPredicate = myCoreGoal.predicate;

        const oppositePredicate =
          currentLang.contradictoryPredicates[myPredicate] ||
          Object.keys(currentLang.contradictoryPredicates).find(
            (key) => currentLang.contradictoryPredicates[key] === myPredicate
          );

        if (!oppositePredicate) return 0;

        if (normalizedProp.type === "atomic") {
          if (
            normalizedProp.subject === mySubject &&
            normalizedProp.predicate === oppositePredicate
          ) {
            penalty += 1500;
          }
        } else if (
          normalizedProp.type === "existential" ||
          normalizedProp.type === "universal"
        ) {
          if (normalizedProp.predicate === oppositePredicate) {
            penalty += normalizedProp.type === "universal" ? 3000 : 1800;
          }
        }
        return penalty;
      }
      function normalizeProposition(prop) {
        if (
          prop &&
          prop.type === "negation" &&
          prop.proposition.type === "negation"
        ) {
          // ~~P 형태이므로, 안쪽의 P에 대해 다시 정규화를 시도합니다.
          return normalizeProposition(prop.proposition.proposition);
        }
        // 이중 부정이 아니거나, 더 이상 제거할 이중 부정이 없으면 그대로 반환합니다.
        return prop;
      }
      function aiTurn() {
        if (gameIsOver || isThinkingTime) return;

        // --- 1. 새로운 갬빗 계획 수립 및 기존 계획 유효성 검사 ---
        activeGambitPlan = findBestGambitPlan(currentPlayer);
        if (activeGambitPlan) {
          console.log(
            `%c[AI GAMBIT] New Plan Adopted: ${
              activeGambitPlan.gambitName
            }. Goal: Prove '${propositionToNaturalText(
              activeGambitPlan.subGoal
            )}'`,
            "color: #8A2BE2; font-weight: bold;"
          );
        }

        console.log(
          `%c--- AI TURN DEBUG START (Round ${currentRound}, Player: ${currentPlayer}) ---`,
          "color: blue; font-weight: bold; font-size: 1.2em;"
        );
        console.log(
          "%c1. AI's Knowledge Base (internalTruthSet):",
          "color: green; font-weight: bold;"
        );
        console.log(internalTruthSet.map((p) => propositionToNaturalText(p)));
        console.log(
          "%c2. Proposition on Board to be Evaluated:",
          "color: green; font-weight: bold;"
        );
        console.log(currentProposition.map((c) => c.card.text).join(" "));

        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        const aiHand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const notKeyword = currentLang.keywords.not;
        const notCardInHand = aiHand.find((c) => c.text === notKeyword);

        if (notCardInHand && currentProposition.length > 0 && myVictoryData) {
          const propOnBoard = parsePropositionFromCards(currentProposition);
          if (propOnBoard && propOnBoard.type === "negation") {
            const newTruthFromDoubleNegation = propOnBoard.proposition;
            const hypotheticalTruths = [
              ...internalTruthSet,
              newTruthFromDoubleNegation,
            ];
            const myUltimateTarget = myVictoryData.ultimate_target;
            if (aiFindProof(myUltimateTarget, hypotheticalTruths)) {
              console.log(
                `%c[AI OVERRIDE] Derived Win via Double Negation DETECTED! Playing '${notKeyword}'`,
                "background: #ff0000; color: #ffffff; font-size: 1.3em;"
              );
              playCard(currentPlayer, notCardInHand);
              setTimeout(completeProposition, 250);
              return;
            }
          }
        }

        const guaranteedMove = checkForGuaranteedWinMove();
        if (guaranteedMove) {
          playCard(currentPlayer, guaranteedMove);
          setTimeout(endTurn, 500);
          return;
        }

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        const hasValidCardMove = aiHand.some((card) =>
          isValidPlay(card, currentProposition)
        );
        const canActuallyComplete = aiCanActuallyComplete();

        if (!hasValidCardMove && !canActuallyComplete) {
          console.log(
            "🔒 FORCED BY RULES: Round end (no actions available for AI)"
          );
          checkRoundEndConditions();
          return;
        }

        if (aiDeclareEureka()) {
          return;
        }

        let isRiskyToComplete = false;
        if (isBoardCompletable()) {
          const propToComplete = parsePropositionFromCards(currentProposition);
          const verificationResult = verifyAndExpandTruths(propToComplete);
          const myLossCondition = myVictoryData
            ? { type: "negation", proposition: myVictoryData.core_goal }
            : null;
          if (
            !verificationResult.success ||
            (opponentVictoryData &&
              aiFindProof(
                opponentVictoryData.ultimate_target,
                verificationResult.expandedSet
              )) ||
            (myLossCondition &&
              aiFindProof(myLossCondition, verificationResult.expandedSet))
          ) {
            isRiskyToComplete = true;
          }
        }

        let bestCardAction = null;
        const validMoves = aiHand.filter((card) =>
          isValidPlay(card, currentProposition)
        );

        if (validMoves.length > 0) {
          const scoredMoves = validMoves.map((move) => {
            let score = 100;

            // ★★★ 핵심 수정: 현재 행동이 갬빗 계획의 일부인지 확인하고 보너스 부여 ★★★
            if (activeGambitPlan) {
              const firstStepOfPlan = activeGambitPlan.path[0];
              const cardsNeededForStep =
                propositionToNaturalText(firstStepOfPlan).split(" ");

              // 현재 보드 + 이번에 낼 카드가 계획의 첫 단계를 구성하는가?
              const expectedNextStep = [
                ...currentProposition.map((c) => c.card.text),
                move.text,
              ].join(" ");
              if (cardsNeededForStep.join(" ").startsWith(expectedNextStep)) {
                console.log(
                  `%c[AI GAMBIT] Move '${move.text}' follows the plan. BIG BONUS!`,
                  "color: #8A2BE2;"
                );
                score += 40000; // 갬빗 계획을 따르는 행동에 매우 높은 보너스 점수
              }
            }
            // ★★★ 여기까지 수정 ★★★

            if (move.text === notKeyword) {
              const propOnBoard = parsePropositionFromCards(currentProposition);

              // 1. 명제판에 되받아칠 부정 명제(~P)가 있는지 확인합니다.
              if (propOnBoard && propOnBoard.type === "negation") {
                const resultingProp = propOnBoard.proposition; // 이중 부정으로 만들어질 명제 (P)
                const normalizedResultingProp =
                  normalizeProposition(resultingProp); // 의미를 정확히 파악하기 위해 정규화

                // 2. 필승 확인: 이 수로 즉시 이길 수 있는지 먼저 확인합니다.
                const hypotheticalTruths = [
                  ...internalTruthSet,
                  normalizedResultingProp,
                ];
                if (
                  myVictoryData &&
                  aiFindProof(myVictoryData.ultimate_target, hypotheticalTruths)
                ) {
                  score += 1000000; // 이길 수 있다면 막대한 보너스
                } else {
                  // 3. 소소한 이득 계산: 즉시 이기는 게 아니라면, 전략적 가치를 계산합니다.
                  const benefitScore = calculateStrategicValue(
                    normalizedResultingProp,
                    currentPlayer
                  );

                  // 계산된 가치만큼 행동 점수에 보너스를 부여합니다.
                  score += benefitScore;

                  if (benefitScore > 0) {
                    console.log(
                      `%c[Double Negation Gambit] Countering with 'not' creates a beneficial prop '${propositionToNaturalText(
                        normalizedResultingProp
                      )}'. Bonus: +${benefitScore}`,
                      "color: #00aaff"
                    );
                  }
                }
              }
            }

            if (currentProposition.length > 0 && myVictoryData) {
              const myName = myVictoryData.core_goal.subject;
              if (move.text === myName) {
                const lastCardOnBoard =
                  currentProposition[currentProposition.length - 1].card;
                if (lastCardOnBoard.text === currentLang.keywords.if) {
                  const propOnBoard = parsePropositionFromCards(
                    currentProposition.slice(0, -1)
                  );
                  if (
                    propOnBoard &&
                    arePropositionsEqual(propOnBoard, myVictoryData.core_goal)
                  ) {
                    console.warn(
                      `AI SUICIDE PREVENTION: Penalizing move '${move.text}' after own win condition + 'then'.`
                    );
                    score -= 900000;
                  }
                }
              }
            }

            if (
              move.type ===
              (currentLang.langCode === "ko" ? "고유명사" : "Proper Noun")
            ) {
              const opponentHand =
                currentPlayer === "A" ? playerB_Hand : playerA_Hand;
              const { not: notKeyword } = currentLang.keywords;
              const aiHasNot = aiHand.some((card) => card.text === notKeyword);
              const opponentHasNot = opponentHand.some(
                (card) => card.text === notKeyword
              );
              if (
                aiHasNot === opponentHasNot &&
                currentProposition.length > 0
              ) {
                const propLength = currentProposition.length;
                const lastCardInfo = currentProposition[propLength - 1];
                const {
                  and: andKeyword,
                  if: ifKeyword,
                  or: orKeyword,
                } = currentLang.keywords;
                let isTrap = false;
                if (lastCardInfo.card.text === andKeyword) {
                  isTrap = true;
                } else {
                  const firstPartCards = currentProposition.slice(
                    0,
                    propLength - 1
                  );
                  const parsedFirstPart =
                    parsePropositionFromCards(firstPartCards);
                  if (parsedFirstPart) {
                    if (
                      lastCardInfo.card.text === ifKeyword &&
                      aiFindProof(parsedFirstPart, internalTruthSet)
                    ) {
                      isTrap = true;
                    } else if (lastCardInfo.card.text === orKeyword) {
                      const negationOfFirstPart = {
                        type: "negation",
                        proposition: parsedFirstPart,
                      };
                      if (aiFindProof(negationOfFirstPart, internalTruthSet)) {
                        isTrap = true;
                      }
                    }
                  }
                }
                if (isTrap) {
                  console.log(
                    `방어 로직 발동: 상대에게 필승 기회를 줄 수 있는 '${move.text}' 카드의 점수를 삭감합니다.`
                  );
                  score -= 50000;
                }
              }
            }

            const aiPhilosopherId =
              currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
            const opponentPhilosopherId =
              opponentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
            const bourgeoisText =
              currentLang.langCode === "ko" ? "브루주아는" : "Bourgeois";
            const evilText =
              currentLang.langCode === "ko" ? "악하다" : "is evil";
            const goodText =
              currentLang.langCode === "ko" ? "선하다" : "is good";
            const existentialQuantifier =
              currentLang.langCode === "ko" ? "어떤" : "Some";
            const andKeyword = currentLang.keywords.and;
            if (currentProposition.length > 0) {
              const lastCardText =
                currentProposition[currentProposition.length - 1].card.text;
              const isQuantifiedBourgeois =
                currentProposition.length === 2 &&
                currentProposition[0].card.text === existentialQuantifier &&
                currentProposition[1].card.text === bourgeoisText;
              if (lastCardText === bourgeoisText || isQuantifiedBourgeois) {
                if (aiPhilosopherId === "marx") {
                  if (move.text === evilText) score += 15000;
                  else if (move.text === goodText) score -= 15000;
                } else if (opponentPhilosopherId === "marx") {
                  if (move.text === evilText) score -= 15000;
                  else if (move.text === goodText) score += 15000;
                }
              }
            }
            if (move.text === andKeyword) {
              const propOnBoard = parsePropositionFromCards(currentProposition);
              if (propOnBoard) {
                if (aiPhilosopherId === "marx") {
                  const antiGoalUniversal = {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: goodText,
                  };
                  const antiGoalExistential = {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: goodText,
                  };
                  if (
                    arePropositionsEqual(propOnBoard, antiGoalUniversal) ||
                    arePropositionsEqual(propOnBoard, antiGoalExistential)
                  ) {
                    score -= 18000;
                  }
                } else if (opponentPhilosopherId === "marx") {
                  const opponentGoalUniversal = {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: evilText,
                  };
                  const opponentGoalExistential = {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: evilText,
                  };
                  if (
                    arePropositionsEqual(propOnBoard, opponentGoalUniversal) ||
                    arePropositionsEqual(propOnBoard, opponentGoalExistential)
                  ) {
                    console.log(
                      "AI vs Marx: Preventing adding 'and' after a pro-revolution proposition. Massive Penalty!"
                    );
                    score -= 200000;
                  }
                }
              }
            }

            if (isRiskyToComplete) {
              if (move.text === currentLang.keywords.and) score -= 5000;
              if (move.text === currentLang.keywords.if) score += 200;
            }
            if (move.text === currentLang.keywords.and) {
              const propOnBoard = parsePropositionFromCards(currentProposition);
              if (propOnBoard) {
                if (opponentVictoryData) {
                  const opponentAdvantagePenalty = assessOpponentAdvantage(
                    propOnBoard,
                    opponentVictoryData
                  );
                  score -= opponentAdvantagePenalty;
                  const opponentWinPredicate =
                    opponentVictoryData.core_goal.predicate;
                  const predicatePairs = currentLang.contradictoryPredicates;
                  let oppositePredicate =
                    Object.keys(predicatePairs).find(
                      (key) => predicatePairs[key] === opponentWinPredicate
                    ) || predicatePairs[opponentWinPredicate];
                  if (
                    oppositePredicate &&
                    propOnBoard.type === "negation" &&
                    propOnBoard.proposition.type === "existential" &&
                    propOnBoard.proposition.predicate === oppositePredicate
                  ) {
                    score -= 3000;
                  }
                }
                if (myVictoryData) {
                  const myWinPredicate = myVictoryData.core_goal.predicate;
                  if (
                    propOnBoard.type === "negation" &&
                    propOnBoard.proposition.type === "existential" &&
                    propOnBoard.proposition.predicate === myWinPredicate
                  ) {
                    score -= 3000;
                  }
                }
              }
            }
            const hypotheticalProposition = [
              ...currentProposition,
              { card: move, player: currentPlayer },
            ];
            const parsedHypothetical = parsePropositionFromCards(
              hypotheticalProposition
            );
            if (!parsedHypothetical) return { move, score };
            const verificationResult =
              verifyAndExpandTruths(parsedHypothetical);
            if (!verificationResult.success) {
              score = -999999;
              return { move, score };
            }
            if (
              myVictoryData &&
              aiFindProof(
                myVictoryData.ultimate_target,
                verificationResult.expandedSet
              )
            ) {
              const opponentHand =
                currentPlayer === "A" ? playerB_Hand : playerA_Hand;
              if (isImmediateWinSecure(opponentHand, aiHand, currentLang)) {
                score += 1000000;
              }
            }
            if (
              opponentVictoryData &&
              aiFindProof(
                opponentVictoryData.ultimate_target,
                verificationResult.expandedSet
              )
            )
              score -= 999999;
            if (myVictoryData) {
              const myLossCondition = {
                type: "negation",
                proposition: myVictoryData.core_goal,
              };
              if (aiFindProof(myLossCondition, verificationResult.expandedSet))
                score -= 750000;
            }
            if (opponentVictoryData) {
              const advantagePenalty = assessOpponentAdvantage(
                parsedHypothetical,
                opponentVictoryData
              );
              if (advantagePenalty > 0) score -= advantagePenalty;
            }
            if (myVictoryData) {
              const disadvantagePenalty = assessSelfDisadvantage(
                parsedHypothetical,
                myVictoryData
              );
              if (disadvantagePenalty > 0) {
                console.log(
                  `Evaluation: Move creates self-disadvantage. Applying penalty: -${disadvantagePenalty}`
                );
                score -= disadvantagePenalty;
              }
            }
            const isNewClauseStart =
              currentProposition.length === 0 ||
              [
                currentLang.keywords.and,
                currentLang.keywords.or,
                currentLang.keywords.if,
              ].includes(
                currentProposition[currentProposition.length - 1]?.card.text
              );
            if (isNewClauseStart) {
              if (move.type === currentLang.cardTypes[1]) {
                if (move.text === currentLang.keywords.universal_q) score += 60;
                else score += 30;
              } else if (move.type === currentLang.cardTypes[0]) {
                score -= 40;
              }
            }
            if (parsedHypothetical) {
              const verificationResult = verifyAndExpandTruths(
                parsedHypothetical,
                internalTruthSet
              );
              if (verificationResult.success) {
                const expandedSet = verificationResult.expandedSet;
                const myVictoryData = truePropositions.find(
                  (p) => p.type === "victory" && p.owner === currentPlayer
                );
                if (myVictoryData) {
                  const myCoreGoal = myVictoryData.core_goal;
                  const contradictoryPredicate =
                    currentLang.contradictoryPredicates[myCoreGoal.predicate] ||
                    Object.keys(currentLang.contradictoryPredicates).find(
                      (key) =>
                        currentLang.contradictoryPredicates[key] ===
                        myCoreGoal.predicate
                    );
                  if (contradictoryPredicate) {
                    const selfHarmProposition = {
                      type: "atomic",
                      subject: myCoreGoal.subject,
                      predicate: contradictoryPredicate,
                    };
                    if (aiFindProof(selfHarmProposition, expandedSet)) {
                      console.warn(
                        `AI SUICIDE PREVENTION: Move '${
                          move.text
                        }' proves '${propositionToNaturalText(
                          selfHarmProposition
                        )}', which is self-destructive. Applying massive penalty.`
                      );
                      score -= 1000000;
                    }
                  }
                }
              }
            }
            return { move, score };
          });

          scoredMoves.sort((a, b) => b.score - a.score);
          if (scoredMoves.length > 0) {
            const topScore = scoredMoves[0].score;
            const bestMoves = scoredMoves.filter(
              (move) => move.score === topScore
            );
            bestCardAction =
              bestMoves[Math.floor(Math.random() * bestMoves.length)];
          } else {
            bestCardAction = null;
          }
        }

        let completeAction = null;
        if (isBoardCompletable()) {
          console.log(
            "%c3. Evaluating 'Complete Proposition' Action:",
            "color: orange; font-weight: bold;"
          );
          if (!aiCanActuallyComplete()) {
            console.log(
              "❌ AI cannot actually complete this proposition (duplicate/contradiction)"
            );
            completeAction = null;
          } else {
            let completeScore = 120;
            const aiPhilosopherId =
              currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
            if (aiPhilosopherId === "nietzsche") {
              const propToComplete =
                parsePropositionFromCards(currentProposition);
              if (propToComplete) {
                const isAlreadyProven = truePropositions.some(
                  (p) =>
                    p.proposition &&
                    arePropositionsEqual(p.proposition, propToComplete)
                );
                if (isAlreadyProven) {
                  console.log(
                    "니체 능력 활성화: 중복 명제 완성에 보너스 점수 부여!"
                  );
                  completeScore += 5000;
                }
              }
            }

            if (isRiskyToComplete) {
              console.log(
                "Evaluation: Completing is too risky. Assigning massive penalty."
              );
              completeScore = -999999;
            } else {
              const propToComplete =
                parsePropositionFromCards(currentProposition);
              if (propToComplete) {
                if (opponentVictoryData) {
                  const opponentAdvantagePenalty = assessOpponentAdvantage(
                    propToComplete,
                    opponentVictoryData
                  );
                  if (opponentAdvantagePenalty > 0) {
                    console.log(
                      `Evaluation: Completing helps opponent. Applying penalty: -${opponentAdvantagePenalty}`
                    );
                    completeScore -= opponentAdvantagePenalty;
                  }
                }
                if (myVictoryData) {
                  const selfDisadvantagePenalty = assessSelfDisadvantage(
                    propToComplete,
                    myVictoryData
                  );
                  if (selfDisadvantagePenalty > 0) {
                    console.log(
                      `Evaluation: Completing is self-disadvantageous. Applying penalty: -${selfDisadvantagePenalty}`
                    );
                    completeScore -= selfDisadvantagePenalty;
                  }
                  const myWinPredicate = myVictoryData.core_goal.predicate;
                  if (
                    propToComplete.type === "negation" &&
                    propToComplete.proposition.type === "existential" &&
                    propToComplete.proposition.predicate === myWinPredicate
                  ) {
                    console.log(
                      `Evaluation: Completing contradicts own win condition path. Applying penalty: -3000`
                    );
                    completeScore -= 3000;
                  }
                }
                if (opponentVictoryData) {
                  const opponentWinPredicate =
                    opponentVictoryData.core_goal.predicate;
                  const predicatePairs = currentLang.contradictoryPredicates;
                  let oppositePredicate =
                    Object.keys(predicatePairs).find(
                      (key) => predicatePairs[key] === opponentWinPredicate
                    ) || predicatePairs[opponentWinPredicate];
                  if (
                    oppositePredicate &&
                    propToComplete.type === "negation" &&
                    propToComplete.proposition.type === "existential" &&
                    propToComplete.proposition.predicate === oppositePredicate
                  ) {
                    console.log(
                      `Evaluation: Completing implies a universal proposition that helps opponent. Applying penalty: -3000`
                    );
                    completeScore -= 3000;
                  }
                }
                const opponentPhilosopherId =
                  opponentPlayer === "A" ? playerA_Data.id : playerB_Data.id;
                const bourgeoisText =
                  currentLang.langCode === "ko" ? "브루주아는" : "Bourgeois";
                const evilText =
                  currentLang.langCode === "ko" ? "악하다" : "is evil";
                const goodText =
                  currentLang.langCode === "ko" ? "선하다" : "is good";
                const notText = currentLang.keywords.not;
                const marxGoalProp = {
                  type: "universal",
                  entity: bourgeoisText,
                  predicate: evilText,
                };
                const marxExistentialGoalProp = {
                  type: "existential",
                  entity: bourgeoisText,
                  predicate: evilText,
                };
                const marxHelpfulNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: goodText,
                  },
                };
                const marxHelpfulExistentialNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: goodText,
                  },
                };
                const marxAntiGoalProp = {
                  type: "universal",
                  entity: bourgeoisText,
                  predicate: goodText,
                };
                const marxExistentialAntiGoalProp = {
                  type: "existential",
                  entity: bourgeoisText,
                  predicate: goodText,
                };
                const marxHarmfulNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "universal",
                    entity: bourgeoisText,
                    predicate: evilText,
                  },
                };
                const marxHarmfulExistentialNegationProp = {
                  type: "negation",
                  proposition: {
                    type: "existential",
                    entity: bourgeoisText,
                    predicate: evilText,
                  },
                };

                if (aiPhilosopherId === "marx") {
                  if (
                    arePropositionsEqual(propToComplete, marxGoalProp) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxExistentialGoalProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing a pro-revolution proposition. Bonus!"
                    );
                    completeScore += 200000;
                  } else if (
                    arePropositionsEqual(
                      propToComplete,
                      marxHelpfulNegationProp
                    ) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxHelpfulExistentialNegationProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing a helpful negated proposition. Bonus!"
                    );
                    completeScore += 200000;
                  } else if (
                    arePropositionsEqual(propToComplete, marxAntiGoalProp) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxExistentialAntiGoalProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing an anti-revolution proposition. Penalty!"
                    );
                    completeScore -= 20000;
                  } else if (
                    arePropositionsEqual(
                      propToComplete,
                      marxHarmfulNegationProp
                    ) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxHarmfulExistentialNegationProp
                    )
                  ) {
                    console.log(
                      "AI Marx is completing a harmful negated proposition. Penalty!"
                    );
                    completeScore -= 20000;
                  }
                } else if (opponentPhilosopherId === "marx") {
                  if (
                    arePropositionsEqual(propToComplete, marxGoalProp) ||
                    arePropositionsEqual(
                      propToComplete,
                      marxExistentialGoalProp
                    )
                  ) {
                    console.log(
                      "AI vs Marx: Completing a pro-revolution proposition helps the opponent. Penalty!"
                    );
                    completeScore -= 200000;
                  }
                }
                const verificationResult =
                  verifyAndExpandTruths(propToComplete);
                if (verificationResult.success && myVictoryData) {
                  if (
                    aiFindProof(
                      myVictoryData.ultimate_target,
                      verificationResult.expandedSet
                    )
                  ) {
                    completeScore += 1000000;
                  }
                }
              }
            }
            completeAction = { action: "complete", score: completeScore };
            console.log(
              `%c>>> Calculated Score for COMPLETING: ${completeScore}`,
              "color: red; font-weight: bold;"
            );
          }
        }

        if (
          bestCardAction &&
          (!completeAction || bestCardAction.score >= completeAction.score)
        ) {
          console.log(
            `%c--- AI FINAL DECISION: PLAY CARD '${bestCardAction.move.text}' (Score: ${bestCardAction.score}) ---`,
            "background: #222; color: #bada55; font-size: 1.2em;"
          );
          playCard(currentPlayer, bestCardAction.move);
          setTimeout(endTurn, 500);
        } else if (completeAction) {
          console.log(
            `%c--- AI FINAL DECISION: COMPLETE PROPOSITION (Score: ${completeAction.score}) ---`,
            "background: #222; color: #bada55; font-size: 1.2em;"
          );
          completeProposition();
        } else {
          checkRoundEndConditions();
        }
      }

      function playCard(player, cardToPlay) {
        if (player !== currentPlayer || gameIsOver || isThinkingTime) return;

        if (cardsPlayedThisTurn[player] >= 1) {
          showAlert(currentLang.alerts.oneCardPerTurn);
          return;
        }

        if (!isValidPlay(cardToPlay, currentProposition)) {
          if (player !== aiPlayer) {
            showAlert(currentLang.alerts.invalidCard);
          }
          return;
        }
        if (currentProposition.length === 0) propositionStarter = player;
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        const cardIndex = hand.findIndex(
          (card) =>
            card.text === cardToPlay.text && card.type === cardToPlay.type
        );
        if (cardIndex === -1) return;
        currentProposition.push({
          card: hand.splice(cardIndex, 1)[0],
          player: player,
          originalIndex: cardIndex, // 카드의 원래 위치를 함께 저장
        });

        audioManager.playSfx("playCard");

        lastCardPlayer = player;
        cardsPlayedThisTurn[player]++;

        render();
      }

      function completeProposition() {
        if (currentProposition.length === 0 || gameIsOver || isThinkingTime)
          return false;

        const parsedProp = parsePropositionFromCards([...currentProposition]);
        if (!parsedProp) {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.incompleteProposition);
          }
          return false;
        }

        const isAxiom = parsedAxioms.some((a) =>
          arePropositionsEqual(a.proposition, parsedProp)
        );
        const isAlreadyInTrueList = truePropositions.some(
          (p) =>
            p.proposition && arePropositionsEqual(p.proposition, parsedProp)
        );

        // 공리이거나, 이미 참 목록에 있으면 '증명된 것'으로 간주합니다.
        const isAlreadyProven = isAxiom || isAlreadyInTrueList;
        const currentPlayerId =
          currentPlayer === "A" ? playerA_Data.id : playerB_Data.id;

        // 1. "불가능한 경우"를 먼저 확인하고 함수를 즉시 종료시킵니다.
        // 현재 플레이어가 니체가 "아닌데" 중복 명제를 완성하려는 경우 -> 거부
        if ((isAxiom || isAlreadyProven) && currentPlayerId !== "nietzsche") {
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.duplicateProposition);
          }
          return false;
        }

        // 2. 여기까지 왔다면, 아래 두 경우 중 하나입니다:
        //    - 새로운 명제인 경우 (모든 플레이어)
        //    - 중복 명제인 경우 (니체만 해당)

        const verificationResult = verifyAndExpandTruths(parsedProp);

        if (verificationResult.success) {
          // 3. 논리적으로 참임이 증명되었으므로, 명제를 추가합니다.
          internalTruthSet = verificationResult.expandedSet;

          // 추가할 명제 객체를 기본 형태로 생성합니다.
          const propToAdd = {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "user-made",
            round: currentRound,
            proposition: parsedProp,
            original_cards: [...currentProposition],
          };

          // 만약 "니체가 중복 명제를 완성"한 경우, 'source'를 추가합니다.
          if (isAlreadyProven && currentPlayerId === "nietzsche") {
            propToAdd.source = "nietzsche_ability";
          }

          console.log("니체 명제 생성 시점: ", propToAdd);

          truePropositions.push(propToAdd);

          // --- 명제 추가 성공 후 공통 로직 ---
          audioManager.playSfx("complete");
          lastPropositionMaker =
            currentProposition[currentProposition.length - 1].player;
          currentPlayer = lastPropositionMaker === "A" ? "B" : "A";
          currentProposition = [];
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          render();
          const truePropositionsEl =
            document.getElementById("true-propositions");
          truePropositionsEl.scrollTop = truePropositionsEl.scrollHeight;
          checkNextTurn();
          return true;
        } else {
          // 4. 모순이 발견된 경우
          if (currentPlayer !== aiPlayer) {
            showAlert(currentLang.alerts.contradictionFound);
          }
          return false;
        }
      }

      function undoProposition() {
        if (gameIsOver || isThinkingTime) return;
        if (gameMode === "AI" && currentPlayer === aiPlayer) return;

        if (currentProposition.length > 0) {
          audioManager.playSfx("undo");
          const lastPlayedInfo = currentProposition.pop();
          if (gameMode === "AI" && lastPlayedInfo.player === aiPlayer) {
            currentProposition.push(lastPlayedInfo);
            return;
          }
          const hand =
            lastPlayedInfo.player === "A" ? playerA_Hand : playerB_Hand;

          // hand.push 대신 splice를 사용하여 원래 위치에 카드를 삽입합니다.
          if (typeof lastPlayedInfo.originalIndex !== "undefined") {
            hand.splice(lastPlayedInfo.originalIndex, 0, lastPlayedInfo.card);
          } else {
            // 혹시 모를 예외 상황을 위한 대비 코드
            hand.push(lastPlayedInfo.card);
          }
          cardsPlayedThisTurn[lastPlayedInfo.player]--;
          currentPlayer = lastPlayedInfo.player;

          if (currentProposition.length > 0) {
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
          } else {
            lastCardPlayer = null;
          }

          render();
        } else {
          let lastUserMadePropIndex = -1;
          for (let i = truePropositions.length - 1; i >= 0; i--) {
            if (truePropositions[i].type === "user-made") {
              lastUserMadePropIndex = i;
              break;
            }
          }
          if (lastUserMadePropIndex !== -1) {
            const propToUndo = truePropositions[lastUserMadePropIndex];
            const lastMaker =
              propToUndo.original_cards[propToUndo.original_cards.length - 1]
                .player;
            if (gameMode === "AI" && lastMaker === aiPlayer) {
              showAlert(currentLang.alerts.nothingToUndo);
              return;
            }
            audioManager.playSfx("undo");
            truePropositions.splice(lastUserMadePropIndex, 1);
            let newTruthSet = parsedAxioms.map((a) => a.proposition);
            const propositionsToReverify = truePropositions
              .filter(
                (p) =>
                  p.type === "victory" ||
                  p.type === "theorem" ||
                  p.type === "user-made"
              )
              .map((p) => p.proposition);
            for (const prop of propositionsToReverify) {
              internalTruthSet = JSON.parse(JSON.stringify(newTruthSet));
              const verificationResult = verifyAndExpandTruths(prop);
              if (verificationResult.success) {
                newTruthSet = verificationResult.expandedSet;
              } else {
                console.error(
                  "Critical error: Inconsistency found while rebuilding truth set after undo.",
                  prop
                );
                showAlert(currentLang.alerts.criticalErrorUndo);
                truePropositions.splice(lastUserMadePropIndex, 0, propToUndo);
                return;
              }
            }
            internalTruthSet = newTruthSet;
            currentProposition = propToUndo.original_cards;
            currentPlayer =
              currentProposition[currentProposition.length - 1].player;
            lastCardPlayer =
              currentProposition[currentProposition.length - 1].player;
            cardsPlayedThisTurn = { A: 0, B: 0 };
            showAlert(currentLang.alerts.undoLastProposition);
            render();
          } else {
            showAlert(currentLang.alerts.nothingToUndo);
          }
        }
      }

      function declareEureka(player) {
        if (gameIsOver) return;

        if (!isThinkingTime && player !== currentPlayer) return;

        if (gameMode === "AI" && player === aiPlayer) return;

        if (!isThinkingTime) {
          if (eurekaUsedInRound[player]) {
            return;
          }

          showConfirm(currentLang.alerts.confirmDeclareEureka, (event) => {
            // 💡 변경점: event 객체를 받도록 수정
            event.stopPropagation(); // 💡 변경점: 이벤트 전파를 막아 중복 소리를 제거

            audioManager.playSfx("eureka");
            eurekaUsedInRound[player] = true;
            openEurekaModal();
            render();
          });
        } else {
          openEurekaModal();
          render();
        }
      }
      function getTemporaryUsableTruths() {
        // '무지의 자각'이 사용되지 않았다면, AI도 internalTruthSet을 그대로 씁니다.
        if (socratesDisabledProps.length === 0) {
          return internalTruthSet;
        }

        // --- '무지의 자각'이 사용된 경우, AI의 지식을 재구성합니다. ---

        // 1. 화면의 참 명제 목록에서 비활성화된 명제를 먼저 제외합니다.
        const filteredUserMadeProps = truePropositions.filter(
          (p) =>
            !p.propId ||
            !socratesDisabledProps.some((dp) => dp.propId === p.propId)
        );

        // 2. 공리와 필터링된 명제를 합쳐 AI가 사용할 최종 전제 목록을 만듭니다.
        const filteredPremises = [
          ...parsedAxioms.map((a) => a.proposition),
          ...filteredUserMadeProps.map((p) => p.proposition).filter(Boolean),
        ];

        // 3. 필터링된 전제로부터 모든 결론을 재구성
        const { success, expandedSet } = verifyAndExpandTruths(
          null,
          filteredPremises
        );

        if (success) {
          return expandedSet;
        } else {
          console.error("AI: Truth set reconstruction failed.");
          return internalTruthSet; // 오류 시 안전하게 기존 값 반환
        }
      }
      function aiDeclareEureka() {
        if (isThinkingTime) return false;

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryCondition || !opponentVictoryCondition) return false;

        const temporaryTruthSetForAI = getTemporaryUsableTruths();

        const myGoal = myVictoryCondition.ultimate_target;
        const opponentGoal = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        if (aiFindProof(myGoal, temporaryTruthSetForAI)) {
          console.log(
            "AI Eureka! Proved own victory based on fair, reconstructed knowledge."
          );
          audioManager.playSfx("eureka");

          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(currentPlayer)
          );
          return true;
        }

        if (aiFindProof(opponentGoal, temporaryTruthSetForAI)) {
          console.log(
            "AI Eureka! Proved opponent's defeat based on fair, reconstructed knowledge."
          );
          audioManager.playSfx("eureka");

          showAlert(currentLang.alerts.aiEurekaDeclared, () =>
            endGame(currentPlayer)
          );
          return true;
        }

        return false;
      }
      function aiFindProof(
        targetProposition,
        initialTruths = internalTruthSet
      ) {
        let knownTruths = [...initialTruths];
        let newTruthsFoundInIteration = true;
        let iterations = 0;
        const maxIterations = 50; // 무한 루프 방지

        while (newTruthsFoundInIteration && iterations < maxIterations) {
          newTruthsFoundInIteration = false;
          iterations++;

          const currentTruthsCount = knownTruths.length;
          let tempTruths = [...knownTruths];

          // 목표를 이미 달성했는지 확인
          if (
            tempTruths.some((p) => arePropositionsEqual(p, targetProposition))
          ) {
            return true;
          }

          // 1개 전제 규칙 적용
          for (const p of knownTruths) {
            const rules = [
              conjunctionElimination,
              doubleNegationElimination,
              existentialInstantiation,
            ];
            for (const rule of rules) {
              const result = rule(p);
              if (result) {
                const results = Array.isArray(result) ? result : [result];
                results.forEach((res) => {
                  if (!tempTruths.some((t) => arePropositionsEqual(t, res))) {
                    tempTruths.push(res);
                    newTruthsFoundInIteration = true;
                  }
                });
              }
            }
          }

          // 2개 전제 규칙 적용
          for (let i = 0; i < knownTruths.length; i++) {
            for (let j = 0; j < knownTruths.length; j++) {
              if (i === j) continue;
              const p1 = knownTruths[i];
              const p2 = knownTruths[j];
              const rules = [
                modusPonens,
                modusTollens,
                hypotheticalSyllogism,
                disjunctiveSyllogism,
                universalApplication,
              ];
              for (const rule of rules) {
                const result = rule(p1, p2);
                if (
                  result &&
                  !tempTruths.some((t) => arePropositionsEqual(t, result))
                ) {
                  tempTruths.push(result);
                  newTruthsFoundInIteration = true;
                }
              }
            }
          }

          // ★★★ 수정된 부분: 경우 논증 (Proof by Cases) 최적화 ★★★
          // 1. 모든 '또는' 명제와 '라면' 명제를 미리 분류하여 검색 범위를 줄입니다.
          const disjunctions = knownTruths.filter(
            (p) => p.type === "disjunction"
          );
          const conditionals = knownTruths.filter(
            (p) => p.type === "conditional"
          );

          // 2. '또는' 명제를 기준으로 탐색을 시작합니다.
          for (const disjunction of disjunctions) {
            // 예: (P ∨ Q)
            const p = disjunction.left;
            const q = disjunction.right;

            // 3. P로 시작하는 '라면' 명제들 (P → R)을 찾습니다.
            const pConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, p)
            );
            if (pConditionals.length === 0) continue; // 없으면 다음 '또는' 명제로 넘어감

            // 4. Q로 시작하는 '라면' 명제들 (Q → R)을 찾습니다.
            const qConditionals = conditionals.filter((c) =>
              arePropositionsEqual(c.left, q)
            );
            if (qConditionals.length === 0) continue; // 없으면 다음 '또는' 명제로 넘어감

            // 5. 찾아낸 두 '라면' 명제 그룹을 비교하여 결론(R)이 같은 쌍을 찾습니다.
            for (const pCond of pConditionals) {
              for (const qCond of qConditionals) {
                // 결론(pCond.right와 qCond.right)이 동일한지 확인
                if (arePropositionsEqual(pCond.right, qCond.right)) {
                  const result = pCond.right; // 최종 결론 R
                  // 새로운 결론이라면 참 목록에 추가
                  if (
                    result &&
                    !tempTruths.some((t) => arePropositionsEqual(t, result))
                  ) {
                    tempTruths.push(result);
                    newTruthsFoundInIteration = true;
                  }
                }
              }
            }
          }

          knownTruths = tempTruths;
        }

        // 최종적으로 목표가 달성되었는지 확인
        return knownTruths.some((p) =>
          arePropositionsEqual(p, targetProposition)
        );
      }

      function endGame(winner, winningProposition) {
        audioManager.playSfx("victory");
        audioManager.fadeOut("game-play");
        audioManager.fadeOut("thinking-time");
        gameIsOver = true;
        document.getElementById("eureka-modal").classList.remove("visible");
        const statusEl = document.getElementById("status");
        let winnerName;
        const isMirrorMatch = playerA_Data.id === playerB_Data.id;

        if (winner === "A") {
          winnerName = getLastName(playerA_Data.name[currentLang.langCode]);
          if (isMirrorMatch) {
            // 미러전일 경우, A플레이어(선공)에게 색상 식별자를 추가합니다.
            winnerName += currentLang.langCode === "ko" ? "(백)" : " (White)";
          }
        } else {
          // winner === 'B'
          winnerName = getLastName(playerB_Data.name[currentLang.langCode]);
          if (isMirrorMatch) {
            // 미러전일 경우, B플레이어(후공)에게 색상 식별자를 추가합니다.
            winnerName += currentLang.langCode === "ko" ? "(흑)" : " (Black)";
          }
        }
        const victoryText = `${winnerName} ${currentLang.ui.victoryMessage}<br>${currentLang.ui.victorySubMessage}`;
        statusEl.innerHTML = `<span class="turn-indicator">${victoryText}</span>`;
        render();

        // 1. 모든 오버레이 이미지를 일단 숨깁니다.
        document.querySelectorAll(".overlay-image").forEach((img) => {
          img.classList.add("hidden");
        });

        // 2. ★★★ 수정된 핵심 로직 ★★★
        //    승리한 철학자의 '승리' 오버레이를 논리 증명과 관계없이 즉시 표시합니다.
        const winnerOverlayId =
          winner === "A" ? "socrates-win-overlay" : "plato-win-overlay";
        const winnerOverlay = document.getElementById(winnerOverlayId);
        if (winnerOverlay) {
          winnerOverlay.classList.remove("hidden");
          // z-index를 다른 승리 이미지보다 높게 설정하여 항상 위에 오도록 보장합니다.
          // (CSS에서 이미 z-index: 3으로 설정했으므로 이 줄은 선택적입니다.)
          winnerOverlay.style.zIndex = "5";
        }

        // 3. '승리'를 제외한 나머지 상태 오버레이들은 기존처럼 논리적 참/거짓에 따라 표시합니다.
        const characters = [
          currentLang.keywords.socrates,
          currentLang.keywords.plato,
        ];
        const predicates = [
          ...currentLang.cards
            .filter(
              (card) =>
                card.type === currentLang.cardTypes[3] ||
                card.type === "Predicate"
            )
            // ★★★ '승리한다' 서술어는 위에서 수동으로 처리했으므로, 반복문에서 제외합니다.
            .filter(
              (card) =>
                card.text !== currentLang.keywords.wins &&
                card.text !== "승리한다"
            )
            .map((card) => card.text),
        ];

        characters.forEach((subjectText) => {
          predicates.forEach((predicateText) => {
            const targetProposition = {
              type: "atomic",
              subject: subjectText,
              predicate: predicateText,
            };

            if (aiFindProof(targetProposition, internalTruthSet)) {
              const subjectId =
                subjectText === currentLang.keywords.socrates
                  ? "socrates"
                  : "plato";
              const predicateMap = {
                선하다: "good",
                "is good": "good",
                악하다: "evil",
                "is evil": "evil",
                지혜롭다: "wise",
                "is wise": "wise",
                어리석다: "foolish",
                "is foolish": "foolish",
                새이다: "bird",
                "is a bird": "bird",
                물고기이다: "fish",
                "is a fish": "fish",
                개이다: "dog",
                "is a dog": "dog",
              };
              const predicateId = predicateMap[predicateText];

              if (predicateId) {
                const overlayId = `${subjectId}-${predicateId}-overlay`;
                const overlayToShow = document.getElementById(overlayId);
                if (overlayToShow) {
                  overlayToShow.classList.remove("hidden");
                }
              }
            }
          });
        });
      }
      function checkRoundEndConditions() {
        if (
          gameIsOver ||
          isThinkingTime ||
          cardsPlayedThisTurn[currentPlayer] > 0
        )
          return;

        const hand = currentPlayer === "A" ? playerA_Hand : playerB_Hand;
        const hasValidCardMove = hand.some((card) =>
          isValidPlay(card, currentProposition)
        );

        let canComplete = false;
        if (currentProposition.length > 0 && lastCardPlayer !== currentPlayer) {
          const parsedProp = parsePropositionFromCards(currentProposition);
          if (parsedProp) {
            const verificationResult = verifyAndExpandTruths(parsedProp);
            if (verificationResult.success) {
              canComplete = true;
            }
          }
        }

        if (!hasValidCardMove && !canComplete) {
          const playerName =
            currentPlayer === "A"
              ? playerA_Data.name[currentLang.langCode]
              : playerB_Data.name[currentLang.langCode];

          // 'AI vs AI' 모드일 경우에만 경고창을 건너뜁니다.
          if (gameMode === "AI_VS_AI") {
            console.log(
              `AI (${currentPlayer}) has no moves. Starting Thinking Time automatically in AI_VS_AI mode.`
            );
            startThinkingTime();
          } else {
            // 그 외의 모든 모드(사람 vs AI 포함)에서는 경고창을 띄웁니다.
            showAlert(
              currentLang.alerts.roundEndNoMoves.replace(
                "{player}",
                playerName
              ),
              () => startThinkingTime()
            );
          }
        }
      }

      function startThinkingTime() {
        audioManager.fadeOut("game-play");
        audioManager.play("thinking-time");

        currentProposition = [];
        lastCardPlayer = null;
        isThinkingTime = true;
        cardsPlayedThisTurn = { A: 0, B: 0 };

        const thinkingTimeEl = document.getElementById(
          "thinking-time-controls"
        );
        thinkingTimeEl.classList.remove("hidden");
        thinkingTimeEl.style.display = "";

        // 후공 플레이어부터 사유 시간 턴을 시작
        const roundStarter = currentRound % 2 === 1 ? "A" : "B";
        const thinkingTimeStarter = roundStarter === "A" ? "B" : "A";
        thinkingTimeTurn = thinkingTimeStarter;

        render();

        // ✅ [핵심 수정] 턴 시작은 이제 checkNextTurn 함수가 전담하므로,
        // 상태 변경 후 checkNextTurn을 호출하여 턴 관리를 넘겨줍니다.
        checkNextTurn();
      }
      function endThinkingTime() {
        audioManager.fadeOut("thinking-time"); // 기존 코드
        audioManager.play("game-play"); // 기존 코드

        socratesDisabledProps = socratesDisabledProps.filter(
          (prop) => prop.reEnableRound > currentRound + 1
        ); // 기존 코드

        isThinkingTime = false; // 기존 코드
        thinkingTimeTurn = null; // 기존 코드

        document
          .getElementById("thinking-time-controls")
          .classList.add("hidden"); // 기존 코드

        currentRound++; // 기존 코드
        eurekaUsedInRound = { A: false, B: false }; // 기존 코드

        // 손패를 새로 분배하는 부분 (기존 코드)
        const nonPlayerCards = [currentLang.keywords.wins]; // 기존 코드
        playerA_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        ); // 기존 코드
        playerB_Hand = JSON.parse(
          JSON.stringify(
            fullDeck.filter((c) => !nonPlayerCards.includes(c.text))
          )
        ); // 기존 코드

        // 현재 게임에 마르크스가 있는지 확인합니다.
        const isMarxInGame =
          playerA_Data.id === "marx" || playerB_Data.id === "marx"; // playerA_Data와 playerB_Data를 참조하여 마르크스 존재 여부 확인

        // 마르크스가 있다면, 새로 분배된 손패에서 플레이 불가능한 카드들을 제거합니다.
        if (isMarxInGame) {
          const unplayableCardTexts = [
            currentLang.langCode === "ko" ? "혁명이" : "A revolution",
            currentLang.langCode === "ko" ? "일어난다" : "occurs",
          ]; // 제거할 카드 목록 정의

          playerA_Hand = playerA_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          ); // 손패 A에서 필터링
          playerB_Hand = playerB_Hand.filter(
            (card) => !unplayableCardTexts.includes(card.text)
          ); // 손패 B에서 필터링
        }

        currentPlayer = currentRound % 2 === 1 ? "A" : "B"; // 기존 코드
        render(); // 기존 코드
        checkNextTurn(); // 기존 코드
      }
      function openEurekaModal() {
        derivedPropositionsInModal = [];
        currentAssumption = null;
        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";
        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions
            .map((p) => ({ ...p, proposition: p.proposition }))
            .filter((p) => p.proposition),
        ].filter(
          (propData) =>
            // ✅ propData에 propId가 있고, 그 ID가 socratesDisabledProps 배열에 포함되지 않은 경우만 true를 반환
            !propData.propId ||
            !socratesDisabledProps.some((dp) => dp.propId === propData.propId)
        );
        
        // 공리들을 그룹별로 분류하고 순서대로 추가
        const axioms = allSelectablePropositions.filter(p => p.type === "axiom");
        const nonAxioms = allSelectablePropositions.filter(p => p.type !== "axiom");
        
        // 공리를 그룹화하여 추가 - 작은 서브그룹별로 구분선 추가
        if (currentAxioms.groups && axioms.length > 0) {
          const groups = currentAxioms.groups;
          const templates = currentLang.axiom_templates;
          let axiomIndex = 0;
          
          // 정체성 공리 그룹
          if (groups.identity && groups.identity.length > 0) {
            for (let i = 0; i < groups.identity.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 정체성 그룹 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // 개체별 속성 대립 그룹 - 서브그룹별로 나누기
          if (groups.subjectOpposition && groups.subjectOpposition.length > 0) {
            // 첫 번째 철학자 선악 공리
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 첫 번째 철학자 지혜 공리
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 두 번째 철학자 선악 공리
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 두 번째 철학자 지혜 공리
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 개체별 속성 대립 그룹 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // 집단별 속성 대립 그룹 - 서브그룹별로 나누기
          if (groups.quantifierOpposition && groups.quantifierOpposition.length > 0) {
            // 새 집단 순방향
            for (let i = 0; i < templates.bird_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 새 집단 역방향
            for (let i = 0; i < templates.bird_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 물고기 집단 순방향
            for (let i = 0; i < templates.fish_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 물고기 집단 역방향
            for (let i = 0; i < templates.fish_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 개 집단 순방향
            for (let i = 0; i < templates.dog_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 개 집단 역방향
            for (let i = 0; i < templates.dog_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 마르크스 공리가 있으면 추가
            const remainingAxioms = axioms.slice(axiomIndex);
            const marxAxioms = remainingAxioms.filter(a => {
              const text = propositionToNaturalText(a.proposition);
              return text.includes("브루주아") || text.includes("Bourgeois");
            });
            
            if (marxAxioms.length > 0) {
              // 서브그룹 구분선
              addPremiseToWorkbench({
                type: "separator",
                label: "",
                proposition: null,
                isSeparator: true
              });
              
              marxAxioms.forEach((axiomData) => {
                addPremiseToWorkbench({
                  ...axiomData,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              });
            }
            
            // 집단별 속성 대립 그룹 마지막 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        } else {
          // 기존 방식으로 공리 추가 (하위 호환성)
          axioms.forEach((propData) => {
            addPremiseToWorkbench({
              ...propData,
              label: currentLang.labels.axiom
            });
          });
          
          // 공리 마지막 구분선 추가
          if (axioms.length > 0) {
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        }
        
        // 공리가 아닌 명제들 추가
        nonAxioms.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });
        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");
        if (isThinkingTime) {
          modalTitle.textContent = currentLang.modals.eurekaTitleTheorem;
          confirmBtn.textContent = currentLang.modals.confirmTheoremButton;
          confirmBtn.onclick = addTheoremsToList;
        } else {
          modalTitle.textContent = currentLang.modals.eurekaTitleVictory;
          confirmBtn.textContent = currentLang.modals.confirmVictoryButton;
          confirmBtn.onclick = proveVictory;
        }
        renderModal();
        document.getElementById("inference-rule-select").onchange =
          updateConclusionPreview;
        updateConclusionPreview(); // Initialize preview
        modal.classList.add("visible");
      }

      function addAssumption() {
        if (currentAssumption) {
          showAlert(currentLang.alerts.oneAssumptionOnly);
          return;
        }
        showPrompt(
          currentLang.modals.promptInputPlaceholder,
          (propositionText) => {
            if (propositionText) {
              const parsedProp = parsePropositionFromString(propositionText);
              if (parsedProp) {
                currentAssumption = parsedProp;
                addPremiseToWorkbench({
                  proposition: parsedProp,
                  type: "assumption",
                  dependsOnAssumption: true,
                  isAssumption: true,
                  label: currentLang.labels.assumption,
                });
                renderModal();
                updateConclusionPreview();
              } else {
                showAlert(currentLang.alerts.parsingFailed);
              }
            }
          }
        );
      }

      function cancelAssumption() {
        if (inTutorialMode) return;
        currentAssumption = null;
        derivedPropositionsInModal = derivedPropositionsInModal.filter(
          (p) => !p.dependsOnAssumption
        );
        renderModal();
        updateConclusionPreview();
      }

      function addPremiseToWorkbench(propObject) {
        derivedPropositionsInModal.push(propObject);
      }

      function applyRule() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;

        // 이 증명에 직접적으로 사용된 전제 데이터 (이것이 부모 전제가 됨)
        const premisesData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );
        const premises = premisesData.map((data) => data.proposition);
        let conclusions = [];

        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "conditionalIntroduction",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (rule === "conditionalIntroduction") {
          if (premises.length !== 1) {
            showAlert(currentLang.alerts.premiseNeededForIntro);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForIntro);
            return;
          }
          const conclusionData = premisesData[0];
          if (!conclusionData.dependsOnAssumption) {
            showAlert(currentLang.alerts.premiseNotFromAssumption);
            return;
          }
          const newConditional = {
            type: "conditional",
            left: currentAssumption,
            right: conclusionData.proposition,
          };

          // '가정'과 그로부터 도출된 '결론' 모두를 source로 추적
          const assumptionData = derivedPropositionsInModal.find(
            (p) => p.isAssumption
          );
          const sourcePremisesForCI = [assumptionData, conclusionData];

          derivedPropositionsInModal = derivedPropositionsInModal.filter(
            (p) => !p.dependsOnAssumption
          );
          currentAssumption = null;
          addPremiseToWorkbench({
            proposition: newConditional,
            type: "theorem",
            dependsOnAssumption: false,
            isAssumption: false,
            label: currentLang.labels.ci_theorem,
            sourcePremises: sourcePremisesForCI, // source 정보 추가
          });
          // 조건부 도입 성공 시 사운드 재생
          audioManager.playSfx("pop");
        } else if (rule === "reductioAdAbsurdum") {
          if (premises.length !== 2) {
            showAlert(currentLang.alerts.contradictionNeededForRAA);
            return;
          }
          if (!currentAssumption) {
            showAlert(currentLang.alerts.assumptionNeededForRAA);
            return;
          }

          // '가정'과 모순을 이끌어낸 '두 전제' 모두를 source로 추적
          const assumptionData = derivedPropositionsInModal.find(
            (p) => p.isAssumption
          );
          const sourcePremisesForRAA = [assumptionData, ...premisesData];

          const result = reductioAdAbsurdum(
            premises[0],
            premises[1],
            currentAssumption
          );
          if (result) {
            derivedPropositionsInModal = derivedPropositionsInModal.filter(
              (p) => !p.dependsOnAssumption
            );
            currentAssumption = null;
            addPremiseToWorkbench({
              proposition: result,
              type: "theorem",
              dependsOnAssumption: false,
              isAssumption: false,
              label: currentLang.labels.raa_theorem,
              sourcePremises: sourcePremisesForRAA, // source 정보 추가
            });
            // 귀류법 성공 시 사운드 재생
            audioManager.playSfx("pop");
          } else {
            showAlert(currentLang.alerts.notAContradiction);
          }
        } else if (threePremiseRules.includes(rule)) {
          if (premises.length !== 3) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 3)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1], premises[2]);
          if (result) conclusions.push(result);
        } else if (twoPremiseRules.includes(rule)) {
          if (premises.length !== 2) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 2)
            );
            return;
          }
          const result = window[rule](premises[0], premises[1]);
          if (result) conclusions.push(result);
        } else if (onePremiseRules.includes(rule)) {
          if (premises.length !== 1) {
            showAlert(
              currentLang.alerts.premiseCountError.replace("{count}", 1)
            );
            return;
          }
          const result = window[rule](premises[0]);
          if (result) {
            if (Array.isArray(result)) conclusions.push(...result);
            else conclusions.push(result);
          }
        }

        if (conclusions.length > 0 && conclusions[0] != null) {
          const isDependent = premisesData.some((p) => p.dependsOnAssumption);
          conclusions.forEach((conc) => {
            addPremiseToWorkbench({
              proposition: conc,
              type: "theorem",
              dependsOnAssumption: isDependent,
              isAssumption: false,
              label: currentLang.labels.theorem,
              sourcePremises: premisesData, // source 정보 추가
            });
          });
          // 추론 규칙 적용 성공 시 사운드 재생
          audioManager.playSfx("pop");
        } else if (
          rule !== "reductioAdAbsurdum" &&
          rule !== "conditionalIntroduction" &&
          conclusions.length === 0
        ) {
          showAlert(currentLang.alerts.ruleFailed);
        }

        renderModal();
        updateConclusionPreview();
      }

      function addTheoremsToList() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        if (selectedLis.length === 0) {
          showAlert(currentLang.alerts.noTheoremsToAdd);
          return;
        }

        const selectedPropsData = selectedLis.map((chk) =>
          JSON.parse(chk.parentElement.dataset.propObject)
        );

        let potentialTheorems = selectedPropsData.filter(
          (p) => p.type === "theorem" && !p.dependsOnAssumption
        );

        const trulyNewTheorems = potentialTheorems.filter((theoremData) => {
          const isAxiom = parsedAxioms.some((a) =>
            arePropositionsEqual(a.proposition, theoremData.proposition)
          );
          const isAlreadyProven = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, theoremData.proposition)
          );
          return !isAxiom && !isAlreadyProven;
        });

        if (trulyNewTheorems.length === 0) {
          showAlert(currentLang.alerts.duplicateProposition);
          return;
        }

        let theoremsAdded = 0;
        for (const theoremData of trulyNewTheorems) {
          const verificationResult = verifyAndExpandTruths(
            theoremData.proposition
          );

          if (verificationResult.success) {
            truePropositions.push({
              propId: `prop_${Date.now()}_${Math.random()}`, // ✅ 이 줄이 추가되었습니다.
              type: "theorem",
              round: currentRound,
              proposition: theoremData.proposition,
            });
            internalTruthSet = verificationResult.expandedSet;
            theoremsAdded++;
          } else {
            console.error(
              "Contradiction detected while adding a new theorem.",
              theoremData.proposition
            );
            showAlert(currentLang.alerts.contradictionFound);
            break;
          }
        }

        if (theoremsAdded > 0) {
          document.getElementById("eureka-modal").classList.remove("visible");
          render();
        }
      }

      function populatePuzzleLevels() {
        const grid = document.getElementById("puzzle-level-grid");
        grid.innerHTML = ""; // 기존 레벨 버튼들 초기화

        const clearedPuzzles =
          JSON.parse(localStorage.getItem("logos_cleared_puzzles")) || {};

        Object.keys(PUZZLES).forEach((levelNum) => {
          const levelBtn = document.createElement("div");
          levelBtn.className = "puzzle-level-btn";
          levelBtn.textContent = levelNum;
          if (clearedPuzzles[levelNum]) {
            levelBtn.classList.add("cleared");
          }
          levelBtn.addEventListener("click", () => {
            audioManager.playSfx("hover");
            startPuzzle(levelNum, PUZZLES[levelNum]);
          });
          grid.appendChild(levelBtn);
        });
      }

      /**
       * 선택된 레벨 데이터로 퍼즐을 시작합니다.
       * @param {object} levelData - PUZZLES 객체에서 가져온 레벨 정보
       */
      function startPuzzle(levelNum, levelData) {
        currentPuzzleLevel = levelNum;

        const masterDeck = currentLang.cards;
        // '소크라테스는', '플라톤은' 카드를 기본 덱에서 찾습니다.
        const socratesCard = masterDeck.find(
          (c) => c.text === currentLang.keywords.socrates
        );
        const platoCard = masterDeck.find(
          (c) => c.text === currentLang.keywords.plato
        );
        // 모든 철학자 이름을 제외한 기본 카드 목록을 만듭니다.
        const allPhilosopherCardTexts = Object.values(PHILOSOPHERS).map(
          (p) => p.cardText[currentLang.langCode]
        );
        const baseDeck = masterDeck.filter(
          (card) => !allPhilosopherCardTexts.includes(card.text)
        );
        // 기본 카드 목록에 소크라테스와 플라톤 카드만 추가하여 fullDeck을 재설정합니다.
        fullDeck = [...baseDeck, socratesCard, platoCard];

        // 1. 퍼즐에 필요한 공리를 먼저 생성합니다. (튜토리얼 로직 재활용)
        const socratesSubject = currentLang.keywords.socrates;
        const platoSubject = currentLang.keywords.plato;
        currentAxioms = generateAxioms(
          socratesSubject,
          platoSubject,
          currentLang
        );
        parsedAxioms = currentAxioms
          .map((str) => ({
            type: "axiom",
            proposition: parsePropositionFromString(str),
          }))
          .filter((a) => a.proposition);

        inPuzzleMode = true;
        document
          .getElementById("puzzle-level-select-modal")
          .classList.remove("visible");

        // 퍼즐 목표 메시지 박스 표시 및 내용 채우기
        const goalBox = document.getElementById("puzzle-goal-box");
        const goalText = document.getElementById("puzzle-goal-text"); // p 태그를 선택

        goalText.innerHTML = levelData.goalDescription[currentLang.langCode]; // p 태그에 텍스트 설정
        goalBox.classList.remove("hidden"); // 전체 박스를 보이게 함

        // 퍼즐 데이터로 게임 상태 설정
        truePropositions = [];

        // 1. 승리 조건 설정
        const socratesVC_Text =
          levelData.victoryConditions.socrates[currentLang.langCode];
        const socratesVC_Parsed = parsePropositionFromString(socratesVC_Text);
        if (socratesVC_Parsed) {
          truePropositions.push({
            type: "victory",
            owner: "A",
            text: socratesVC_Text,
            proposition: socratesVC_Parsed,
            ultimate_target: {
              type: "atomic",
              subject: currentLang.keywords.socrates,
              predicate: currentLang.keywords.wins,
            },
          });
        }

        const platoVC_Text =
          levelData.victoryConditions.plato[currentLang.langCode];
        const platoVC_Parsed = parsePropositionFromString(platoVC_Text);
        if (platoVC_Parsed) {
          truePropositions.push({
            type: "victory",
            owner: "B",
            text: platoVC_Text,
            proposition: platoVC_Parsed,
            ultimate_target: {
              type: "atomic",
              subject: currentLang.keywords.plato,
              predicate: currentLang.keywords.wins,
            },
          });
        }

        // 2. 전제 명제 설정
        const premises = levelData.premises[currentLang.langCode];
        premises.forEach((pText) => {
          const parsed = parsePropositionFromString(pText);
          if (parsed) {
            truePropositions.push({ type: "user-made", proposition: parsed });
          }
        });

        // 3. 내부 진리 집합 재구성
        internalTruthSet = parsedAxioms.map((a) => a.proposition);
        truePropositions.forEach((p) => internalTruthSet.push(p.proposition));
        internalTruthSet = verifyAndExpandTruths(
          null,
          internalTruthSet
        ).expandedSet;

        // 4. 유레카 모달 바로 열기
        openEurekaModal();
      }

      function proveVictory() {
        if (isThinkingTime) return;

        if (inPuzzleMode) {
          const myVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === "A"
          );
          const opponentVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === "B"
          );

          if (!myVictoryCondition || !opponentVictoryCondition) return;

          const myUltimateTarget = myVictoryCondition.ultimate_target;
          const opponentLossCondition = {
            type: "negation",
            proposition: opponentVictoryCondition.ultimate_target,
          };

          const isMyVictoryProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, myUltimateTarget)
          );
          const isOpponentLossProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, opponentLossCondition)
          );

          if (isMyVictoryProven || isOpponentLossProven) {
            try {
              // 1. 기존 클리어 데이터 불러오기 (없으면 빈 객체)
              const clearedPuzzles =
                JSON.parse(localStorage.getItem("logos_cleared_puzzles")) || {};
              // 2. 현재 클리어한 퍼즐 번호 기록
              clearedPuzzles[currentPuzzleLevel] = true;
              // 3. 다시 로컬 스토리지에 저장
              localStorage.setItem(
                "logos_cleared_puzzles",
                JSON.stringify(clearedPuzzles)
              );
            } catch (e) {
              console.error("퍼즐 클리어 데이터 저장 실패:", e);
            }

            showAlert(currentLang.alerts.puzzleCleared, () => {
              document
                .getElementById("eureka-modal")
                .classList.remove("visible");
              document
                .getElementById("puzzle-goal-box")
                .classList.add("hidden");
              inPuzzleMode = false;
              populatePuzzleLevels();
              document
                .getElementById("puzzle-level-select-modal")
                .classList.add("visible");
            });
          } else {
            showAlert(
              currentLang.alerts.proofIncomplete
                .replace("{myGoal}", propositionToPlainText(myUltimateTarget))
                .replace(
                  "{opponentGoal}",
                  propositionToPlainText(opponentLossCondition)
                )
            );
          }
          return; // 퍼즐 모드일 경우 여기서 함수 종료
        }

        // --- 튜토리얼 마지막 단계 성공 처리 로직 (새로 추가된 부분) ---
        if (inTutorialMode && tutorialStep === 8) {
          const myVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === currentPlayer
          );
          const opponentPlayer = currentPlayer === "A" ? "B" : "A";
          const opponentVictoryCondition = truePropositions.find(
            (p) => p.type === "victory" && p.owner === opponentPlayer
          );

          if (!myVictoryCondition || !opponentVictoryCondition) return;

          const myUltimateTarget = myVictoryCondition.ultimate_target;
          const opponentLossCondition = {
            type: "negation",
            proposition: opponentVictoryCondition.ultimate_target,
          };

          const isMyVictoryProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, myUltimateTarget)
          );
          const isOpponentLossProven = derivedPropositionsInModal.some(
            (p) =>
              !p.dependsOnAssumption &&
              arePropositionsEqual(p.proposition, opponentLossCondition)
          );

          if (isMyVictoryProven || isOpponentLossProven) {
            // 성공 시, 새로 추가한 알림 메시지를 띄우고 확인을 누르면 튜토리얼을 종료합니다.
            showAlert(currentLang.alerts.tutorialVictory, endTutorial);
          } else {
            // 실패 시, 기존처럼 증명 미완료 메시지를 띄웁니다.
            showAlert(
              currentLang.alerts.proofIncomplete
                .replace("{myGoal}", propositionToPlainText(myUltimateTarget))
                .replace(
                  "{opponentGoal}",
                  propositionToPlainText(opponentLossCondition)
                )
            );
          }
          return; // 튜토리얼 케이스 처리가 끝나면 함수를 즉시 종료합니다.
        }
        // --- 튜토리얼 로직 끝 ---

        // --- 이하 기존의 일반 게임 승리 증명 로직 ---
        const myVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === currentPlayer
        );
        if (!myVictoryCondition) return;
        const myUltimateTarget = myVictoryCondition.ultimate_target;

        const opponentPlayer = currentPlayer === "A" ? "B" : "A";
        const opponentVictoryCondition = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        if (!opponentVictoryCondition) return;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentVictoryCondition.ultimate_target,
        };

        const isMyVictoryProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, myUltimateTarget)
        );
        const isOpponentLossProven = derivedPropositionsInModal.some(
          (p) =>
            !p.dependsOnAssumption &&
            arePropositionsEqual(p.proposition, opponentLossCondition)
        );

        if (isMyVictoryProven || isOpponentLossProven) {
          const newTheorems = derivedPropositionsInModal.filter(
            (p) =>
              p.type === "theorem" &&
              !p.dependsOnAssumption &&
              !truePropositions.some((existing) =>
                arePropositionsEqual(p.proposition, existing.proposition)
              )
          );

          for (const theoremData of newTheorems) {
            const verificationResult = verifyAndExpandTruths(
              theoremData.proposition
            );
            if (verificationResult.success) {
              internalTruthSet = verificationResult.expandedSet;
            } else {
              console.error(
                "치명적 오류: 승리 증명에 사용된 정리가 기존 사실과 모순됩니다.",
                theoremData
              );
              showAlert(currentLang.alerts.criticalErrorUndo);
              return;
            }
          }
          endGame(currentPlayer);
          return;
        }

        showAlert(
          currentLang.alerts.proofIncomplete
            .replace("{myGoal}", propositionToPlainText(myUltimateTarget))
            .replace(
              "{opponentGoal}",
              propositionToPlainText(opponentLossCondition)
            )
        );
      }

      function render() {
        if (playerA_Data && playerB_Data) {
          // 데이터가 있을 때만 실행
          const isMirrorMatch = playerA_Data.id === playerB_Data.id;
          if (isMirrorMatch) {
            // 미러전일 경우
            document.getElementById("player-a-title").innerHTML = `⚪️ ${
              playerA_Data.name[currentLang.langCode]
            }(백)`;
            document.getElementById("player-b-title").innerHTML = `⚫️ ${
              playerB_Data.name[currentLang.langCode]
            }(흑)`;
          } else {
            // 일반 대전일 경우
            document.getElementById("player-a-title").innerHTML = `⚪️ ${
              playerA_Data.name[currentLang.langCode]
            }`;
            document.getElementById("player-b-title").innerHTML = `⚫️ ${
              playerB_Data.name[currentLang.langCode]
            }`;
          }
        }
        document.getElementById("round-display").textContent =
          currentLang.ui.roundDisplay.replace("{round}", currentRound);
        const handA_El = document.getElementById("player-a-hand"),
          handB_El = document.getElementById("player-b-hand");
        handA_El.innerHTML = "";
        handB_El.innerHTML = "";
        playerA_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        playerB_Hand.sort(
          (a, b) =>
            cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
        );
        let lastTypeA = null;
        playerA_Hand.forEach((card) => {
          if (card.type !== lastTypeA) {
            if (lastTypeA !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handA_El.appendChild(br);
            }
            lastTypeA = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-white";
          cardEl.textContent = card.text;
          // 사유 시간에는 모든 카드를 비활성화
          if (isThinkingTime) {
            cardEl.classList.add("unplayable");
          } else {
            // 사유 시간이 아닐 때의 기존 로직
            if (gameMode === "AI" && aiPlayer === "A") {
              cardEl.classList.add("ai-hand");
            } else {
              if (currentPlayer === "A" && !gameIsOver) {
                if (cardsPlayedThisTurn["A"] >= 1) {
                  cardEl.classList.add("unplayable");
                } else {
                  if (isValidPlay(card, currentProposition)) {
                    cardEl.addEventListener("click", () => {
                      if (!inTutorialMode) playCard("A", card);
                    });
                  } else {
                    cardEl.classList.add("unplayable");
                  }
                }
              }
            }
          }
          handA_El.appendChild(cardEl);
        });
        let lastTypeB = null;
        playerB_Hand.forEach((card) => {
          if (card.type !== lastTypeB) {
            if (lastTypeB !== null) {
              const br = document.createElement("div");
              br.style.flexBasis = "100%";
              br.style.height = "0";
              handB_El.appendChild(br);
            }
            lastTypeB = card.type;
          }
          const cardEl = document.createElement("div");
          cardEl.className = "card card-black";
          cardEl.textContent = card.text;
          // 사유 시간에는 모든 카드를 비활성화
          if (isThinkingTime) {
            cardEl.classList.add("unplayable");
          } else {
            // 사유 시간이 아닐 때의 기존 로직
            if (gameMode === "AI" && aiPlayer === "B") {
              cardEl.classList.add("ai-hand");
            } else {
              if (currentPlayer === "B" && !gameIsOver) {
                if (cardsPlayedThisTurn["B"] >= 1) {
                  cardEl.classList.add("unplayable");
                } else {
                  if (isValidPlay(card, currentProposition)) {
                    cardEl.addEventListener("click", () => {
                      if (!inTutorialMode) playCard("B", card);
                    });
                  } else {
                    cardEl.classList.add("unplayable");
                  }
                }
              }
            }
          }
          handB_El.appendChild(cardEl);
        });
        const propositionEl = document.getElementById("proposition-display");
        propositionEl.innerHTML = "";
        currentProposition.forEach((info) => {
          const cardEl = document.createElement("div");
          const colorClass = info.player === "A" ? "card-white" : "card-black";
          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = info.card.text;
          propositionEl.appendChild(cardEl);
        });
        const trueList_El = document.getElementById("true-list");
        trueList_El.innerHTML = "";
        const liAxiom = document.createElement("li");
        liAxiom.className = "axiom-wrapper";
        const details = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = currentLang.ui.axiomTitle;
        details.appendChild(summary);
        const axiomContainer = document.createElement("div");
        axiomContainer.className = "axiom-list";

        // 공리들을 그룹별로 표시
        if (currentAxioms.groups) {
          const groups = currentAxioms.groups;

          // 정체성 공리
          if (groups.identity.length > 0) {
            groups.identity.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const separator = document.createElement("hr");
            separator.style.margin = "8px 0";
            separator.style.border = "none";
            separator.style.borderTop = "1px solid #ddd";
            axiomContainer.appendChild(separator);
          }

          // 개체별 속성 대립 - 세부 그룹으로 나누기
          if (groups.subjectOpposition.length > 0) {
            const templates = currentLang.axiom_templates;
            const subjectA = playerA_Data
              ? playerA_Data.cardText[currentLang.langCode]
              : "";
            const subjectB = playerB_Data
              ? playerB_Data.cardText[currentLang.langCode]
              : "";

            // 첫 번째 철학자 선악 공리
            templates.subject_good_evil.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectA);
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep1 = document.createElement("hr");
            sep1.style.margin = "4px 0";
            sep1.style.border = "none";
            sep1.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep1);

            // 첫 번째 철학자 지혜 공리
            templates.subject_wise_foolish.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectA);
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep2 = document.createElement("hr");
            sep2.style.margin = "4px 0";
            sep2.style.border = "none";
            sep2.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep2);

            // 두 번째 철학자 선악 공리
            templates.subject_good_evil.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectB);
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep3 = document.createElement("hr");
            sep3.style.margin = "4px 0";
            sep3.style.border = "none";
            sep3.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep3);

            // 두 번째 철학자 지혜 공리
            templates.subject_wise_foolish.forEach((template) => {
              const axiomText = template.replaceAll("{S}", subjectB);
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const separator = document.createElement("hr");
            separator.style.margin = "8px 0";
            separator.style.border = "none";
            separator.style.borderTop = "1px solid #ddd";
            axiomContainer.appendChild(separator);
          }

          // 집단별 속성 대립 - 세부 그룹으로 나누기
          if (groups.quantifierOpposition.length > 0) {
            const templates = currentLang.axiom_templates;

            // 새 집단 순방향
            templates.bird_good_evil_forward.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep4 = document.createElement("hr");
            sep4.style.margin = "4px 0";
            sep4.style.border = "none";
            sep4.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep4);

            // 새 집단 역방향
            templates.bird_good_evil_reverse.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep5 = document.createElement("hr");
            sep5.style.margin = "4px 0";
            sep5.style.border = "none";
            sep5.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep5);

            // 물고기 집단 순방향
            templates.fish_good_evil_forward.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep6 = document.createElement("hr");
            sep6.style.margin = "4px 0";
            sep6.style.border = "none";
            sep6.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep6);

            // 물고기 집단 역방향
            templates.fish_good_evil_reverse.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep7 = document.createElement("hr");
            sep7.style.margin = "4px 0";
            sep7.style.border = "none";
            sep7.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep7);

            // 개 집단 순방향
            templates.dog_good_evil_forward.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            const sep8 = document.createElement("hr");
            sep8.style.margin = "4px 0";
            sep8.style.border = "none";
            sep8.style.borderTop = "1px solid #ccc";
            axiomContainer.appendChild(sep8);

            // 개 집단 역방향
            templates.dog_good_evil_reverse.forEach((axiomText) => {
              const p = document.createElement("p");
              p.textContent = `• ${axiomText}`;
              axiomContainer.appendChild(p);
            });

            // 마르크스 공리가 있으면 추가
            if (
              currentAxioms.some(
                (axiom) =>
                  axiom.includes("브루주아") || axiom.includes("Bourgeois")
              )
            ) {
              const sep9 = document.createElement("hr");
              sep9.style.margin = "4px 0";
              sep9.style.border = "none";
              sep9.style.borderTop = "1px solid #ccc";
              axiomContainer.appendChild(sep9);

              currentAxioms
                .filter(
                  (axiom) =>
                    axiom.includes("브루주아") || axiom.includes("Bourgeois")
                )
                .forEach((axiomText) => {
                  const p = document.createElement("p");
                  p.textContent = `• ${axiomText}`;
                  axiomContainer.appendChild(p);
                });
            }
          }
        } else {
          // 기존 방식 (하위 호환성)
          currentAxioms.forEach((axiomText) => {
            const p = document.createElement("p");
            p.textContent = `• ${axiomText}`;
            axiomContainer.appendChild(p);
          });
        }

        details.appendChild(axiomContainer);
        liAxiom.appendChild(details);
        trueList_El.appendChild(liAxiom);

        truePropositions.forEach((propData) => {
          if (propData.source === "nietzsche_ability") {
            console.log("니체 명제 렌더링 시점: ", propData);
          }
          const li = document.createElement("li");

          // 이제 propData에 ID가 있는지, 그리고 그 ID가 비활성화 목록에 있는지 확인합니다.
          const isDisabled =
            propData.propId &&
            socratesDisabledProps.some((dp) => dp.propId === propData.propId);

          if (isDisabled) {
            li.classList.add("socrates-disabled");
          }

          if (propData.type === "victory") {
            li.classList.add("victory-condition");

            if (propData.source === "marx_revolution") {
              li.classList.add("marx-victory-condition");
            }
            const ownerName = getLastName(
              propData.owner === "A"
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data.name[currentLang.langCode]
            );
            const ownerPrefix =
              propData.owner === "A" ? `⚪️ ${ownerName}` : `⚫️ ${ownerName}`;
            li.innerHTML = currentLang.labels.victory_text
              .replace("{owner}", ownerPrefix)
              .replace("{text}", propData.text);
          } else if (propData.type === "user-made") {
            // 1. 모든 'user-made' 명제에 대해 단어 색상을 먼저 입힙니다.
            if (propData.original_cards && propData.original_cards.length > 0) {
              propData.original_cards.forEach((info) => {
                const wordSpan = document.createElement("span");
                wordSpan.textContent = info.card.text + " ";
                wordSpan.className = info.player === "A" ? "word-a" : "word-b";
                li.appendChild(wordSpan);
              });
            } else if (propData.proposition) {
              li.textContent = propositionToPlainText(propData.proposition);
            }

            // 2. 만약 니체의 능력으로 만들어진 명제라면, 스타일 클래스와 라벨을 추가합니다.
            if (propData.source === "nietzsche_ability") {
              li.classList.add("nietzsche-theorem"); // [추가] 니체 명제에 전용 클래스 추가

              const rawLabel = currentLang.labels.nietzsche_ability_source;
              const labelText = rawLabel.replace("{text}", "").trim();

              const labelSpan = document.createElement("span");
              labelSpan.textContent = ` ${labelText}`;
              li.appendChild(labelSpan);
            }
          } else if (propData.type === "theorem") {
            let theoremText = propositionToPlainText(propData.proposition);

            // 2. 정규식을 사용하여 모든 괄호를 제거합니다.
            let strippedText = theoremText.replace(/\(|\)/g, "");

            // 3. 능력의 종류에 따라 적절한 라벨을 붙여 최종 텍스트를 완성합니다.
            if (propData.source === "plato_ability") {
              li.classList.add("plato-theorem");
              li.textContent = currentLang.labels.plato_ability_source.replace(
                "{text}",
                strippedText // 괄호가 모두 제거된 텍스트 사용
              );
            } else if (propData.source === "wittgenstein_ability") {
              li.classList.add("wittgenstein-theorem");
              li.textContent =
                currentLang.labels.wittgenstein_ability_source.replace(
                  "{text}",
                  strippedText // 괄호가 모두 제거된 텍스트 사용
                );
            } else if (propData.source === "derrida_ability") {
              li.classList.add("derrida-theorem");
              li.textContent =
                currentLang.labels.derrida_ability_source.replace(
                  "{text}",
                  strippedText // 괄호가 모두 제거된 텍스트 사용
                );
            } else if (propData.source === "hume_ability") {
              li.classList.add("hume-theorem");
              li.textContent = currentLang.labels.hume_ability_source.replace(
                "{text}",
                strippedText // 괄호가 모두 제거된 텍스트 사용
              );
            } else if (propData.source === "kuhn_ability") {
              li.classList.add("kuhn-theorem");
              li.textContent = currentLang.labels.kuhn_ability_source.replace(
                "{text}",
                strippedText // 괄호가 모두 제거된 텍스트 사용
              );
            } else if (propData.source === "kant_ability") {
              li.classList.add("kant-theorem");
              li.textContent = currentLang.labels.kant_ability_source.replace(
                "{text}",
                strippedText // 괄호가 모두 제거된 텍스트 사용
              );
            } else {
              // 일반적인 정리일 경우
              li.classList.add("theorem");
              li.textContent = currentLang.labels.theorem_source
                .replace("{text}", strippedText) // 괄호가 모두 제거된 텍스트 사용
                .replace("{round}", propData.round);
            }
          }

          if (isDisabled) {
            li.textContent +=
              currentLang.langCode === "ko"
                ? " (무지의 자각)"
                : " (Awareness of Ignorance)";
          }

          trueList_El.appendChild(li);
        });

        const playerATitleBox = document.querySelector(
          "#player-a-area .player-title-box"
        );
        const playerBTitleBox = document.querySelector(
          "#player-b-area .player-title-box"
        );

        if (playerATitleBox && playerBTitleBox) {
          // 사유 시간인지 일반 턴인지에 따라 현재 활성화된 플레이어를 결정
          const activePlayer = isThinkingTime
            ? thinkingTimeTurn
            : currentPlayer;

          // 게임오버가 아닐 때, 활성화된 플레이어에게만 'active-turn' 클래스를 적용
          playerATitleBox.classList.toggle(
            "active-turn",
            activePlayer === "A" && !gameIsOver
          );
          playerBTitleBox.classList.toggle(
            "active-turn",
            activePlayer === "B" && !gameIsOver
          );
        }

        const statusEl = document.getElementById("status");
        const mainCenter = document.querySelector(".main-center-bg");

        if (mainCenter && !mainCenter.classList.contains("hidden")) {
          statusEl.innerHTML = "";
        } else {
          const playerAreaA = document.getElementById("player-a-area"),
            playerAreaB = document.getElementById("player-b-area");
          const eurekaBtnA = document.getElementById("eureka-a"),
            eurekaBtnB = document.getElementById("eureka-b");
          const completeBtn = document.getElementById("complete-btn"),
            undoBtn = document.getElementById("undo-btn"),
            endTurnBtn = document.getElementById("end-turn-btn");

          let winnerName = "";
          if (gameIsOver) {
            statusEl.style.color = "#c0392b";
            playerAreaA.classList.add("disabled");
            playerAreaB.classList.add("disabled");
            eurekaBtnA.disabled = true;
            eurekaBtnB.disabled = true;
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled = true;
          } else if (isThinkingTime) {
            // 1. 전용 UI의 제목과 설명을 업데이트합니다.
            document.getElementById("thinking-time-title").textContent =
              currentLang.ui.thinkingTimeTitle;
            document.getElementById("thinking-time-desc").innerHTML =
              currentLang.ui.thinkingTimeDesc;

            // 2. 하단 상태바에 현재 턴인 플레이어를 표시합니다.
            const thinkingPlayerName = getLastName(
              thinkingTimeTurn === "A"
                ? playerA_Data.name[currentLang.langCode]
                : playerB_Data.name[currentLang.langCode]
            );
            const thinkingPlayerColor =
              thinkingTimeTurn === "A" ? "⚪️" : "⚫️";
            statusEl.innerHTML = `<span class="turn-indicator">${thinkingPlayerColor} ${thinkingPlayerName}${currentLang.ui.thinkingTimeTurnMessage}</span>`;

            // 3. 현재 턴인 플레이어의 영역만 활성화합니다.
            if (thinkingTimeTurn === "A") {
              playerAreaA.classList.remove("disabled");
              playerAreaB.classList.add("disabled");
              eurekaBtnA.disabled = gameMode === "AI" && aiPlayer === "A";
              eurekaBtnB.disabled = true;
            } else {
              // thinkingTimeTurn === 'B'
              playerAreaA.classList.add("disabled");
              playerAreaB.classList.remove("disabled");
              eurekaBtnA.disabled = true;
              eurekaBtnB.disabled = gameMode === "AI" && aiPlayer === "B";
            }

            // '유레카!' 버튼 텍스트를 '정리 추가'로 변경합니다.
            eurekaBtnA.textContent = currentLang.ui.addTheoremButton;
            eurekaBtnB.textContent = currentLang.ui.addTheoremButton;

            // 4. 중앙 하단의 컨트롤 버튼 상태를 설정합니다.
            // '명제 완성', '되돌리기' 버튼은 비활성화하고, '턴 종료' 버튼은 활성화합니다.
            completeBtn.disabled = true;
            undoBtn.disabled = true;
            endTurnBtn.disabled =
              (gameMode === "AI" && thinkingTimeTurn === aiPlayer) ||
              (inTutorialMode && thinkingTimeTurn !== "A");
          } else {
            statusEl.style.color = "#333";
            eurekaBtnA.textContent = currentLang.ui.eurekaButton;
            eurekaBtnB.textContent = currentLang.ui.eurekaButton;
            const isAITurn = gameMode === "AI" && currentPlayer === aiPlayer;
            const isCompletable =
              currentProposition.length > 0 &&
              parsePropositionFromCards(currentProposition) !== null;

            if (isAITurn) {
              statusEl.innerHTML = `<span class="turn-indicator">${currentLang.ui.statusAITurn}</span>`;
              playerAreaA.classList.add("disabled");
              playerAreaB.classList.add("disabled");
              eurekaBtnA.disabled = true;
              eurekaBtnB.disabled = true;
              completeBtn.disabled = true;
              undoBtn.disabled = true;
              endTurnBtn.disabled = true;
            } else {
              if (currentPlayer === "A") {
                const playerAName = playerA_Data
                  ? getLastName(playerA_Data.name[currentLang.langCode])
                  : currentLang.ui.playerAName;
                statusEl.innerHTML = `<span class="turn-indicator">⚪️ ${playerAName}${currentLang.ui.statusTurn}</span>`;
                playerAreaA.classList.remove("disabled");
                playerAreaB.classList.add("disabled");
                // ⭐️ 핵심 수정: eurekaUsedInRound['A']가 true이면 버튼 비활성화
                eurekaBtnA.disabled = eurekaUsedInRound["A"];
                eurekaBtnB.disabled = true;
              } else {
                const playerBName = playerB_Data
                  ? getLastName(playerB_Data.name[currentLang.langCode])
                  : currentLang.ui.playerBName;
                statusEl.innerHTML = `<span class="turn-indicator">⚫️ ${playerBName}${currentLang.ui.statusTurn}</span>`;
                playerAreaB.classList.remove("disabled");
                playerAreaA.classList.add("disabled");
                eurekaBtnA.disabled = true;
                // ⭐️ 핵심 수정: eurekaUsedInRound['B']가 true이면 버튼 비활성화
                eurekaBtnB.disabled = eurekaUsedInRound["B"];
              }
              completeBtn.disabled =
                !isCompletable || lastCardPlayer === currentPlayer;
              undoBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
              endTurnBtn.disabled = cardsPlayedThisTurn[currentPlayer] === 0;
            }
          }
          updateAbilityButtonsState();
        }
      }

      function setupTutorialScenario(step) {
        if (step === 4) {
          // 4단계는 '사유 시간' 튜토리얼이므로, 사유 시간 음악으로 변경
          audioManager.fadeOut("game-play");
          audioManager.play("thinking-time");
        } else if (step === 5) {
          // 5단계는 다시 일반 게임 규칙으로 돌아오므로, 게임 음악으로 변경
          audioManager.fadeOut("thinking-time");
          audioManager.play("game-play");
        }
        if (step === 1) {
          playerA_Hand = [];
          playerB_Hand = [];
          truePropositions = [];

          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );

          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);

          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          const {
            if: ifKeyword,
            and: andKeyword,
            wins: winsKeyword,
            socrates: socratesKeyword,
            plato: platoKeyword,
          } = currentLang.keywords;

          const goodPredicate =
            currentLang.langCode === "ko" ? "선하다" : "is good";
          const evilPredicate =
            currentLang.langCode === "ko" ? "악하다" : "is evil";

          // 소크라테스 승리 조건
          const socratesVCText = `((${socratesKeyword} ${goodPredicate}) ${ifKeyword} (${socratesKeyword} ${winsKeyword})) ${andKeyword} ((${socratesKeyword} ${winsKeyword}) ${ifKeyword} (${socratesKeyword} ${goodPredicate}))`;
          const parsedSocratesVC = parsePropositionFromString(socratesVCText);
          if (parsedSocratesVC) {
            truePropositions.push({
              type: "victory",
              text: socratesVCText,
              owner: "A",
              proposition: parsedSocratesVC,
              ultimate_target: {
                type: "atomic",
                subject: socratesKeyword,
                predicate: winsKeyword,
              },
              core_goal: {
                type: "atomic",
                subject: socratesKeyword,
                predicate: goodPredicate,
              },
            });
            internalTruthSet.push(parsedSocratesVC);
          }

          // 플라톤 승리 조건
          const platoVCText = `((${platoKeyword} ${evilPredicate}) ${ifKeyword} (${platoKeyword} ${winsKeyword})) ${andKeyword} ((${platoKeyword} ${winsKeyword}) ${ifKeyword} (${platoKeyword} ${evilPredicate}))`;
          const parsedPlatoVC = parsePropositionFromString(platoVCText);
          if (parsedPlatoVC) {
            truePropositions.push({
              type: "victory",
              text: platoVCText,
              owner: "B",
              proposition: parsedPlatoVC,
              ultimate_target: {
                type: "atomic",
                subject: platoKeyword,
                predicate: winsKeyword,
              },
              core_goal: {
                type: "atomic",
                subject: platoKeyword,
                predicate: evilPredicate,
              },
            });
            internalTruthSet.push(parsedPlatoVC);
          }
          currentProposition = [];
          currentPlayer = "A";
          propositionStarter = "A";
          gameIsOver = false;
          currentRound = 1;
          isThinkingTime = false;
          lastPropositionMaker = null;
          currentAssumption = null;
          lastCardPlayer = null;
          cardsPlayedThisTurn = { A: 0, B: 0 };
          gameMode = "2P";

          // 튜토리얼을 위한 기본 철학자 데이터 설정
          playerA_Data = PHILOSOPHERS["socrates"];
          playerB_Data = PHILOSOPHERS["plato"];

          const portraitA_El = document.getElementById("player-a-portrait");
          if (portraitA_El) {
            portraitA_El.style.backgroundImage = `url('${playerA_Data.image.p1}')`;
          }
          const portraitB_El = document.getElementById("player-b-portrait");
          if (portraitB_El) {
            portraitB_El.style.backgroundImage = `url('${playerB_Data.image.p2}')`;
          }

          const socratesCardText = currentLang.keywords.socrates;
          const requiredA_CardTexts = [
            socratesCardText,
            currentLang.keywords.and,
            currentLang.keywords.or,
            currentLang.keywords.if,
            currentLang.keywords.not,
            currentLang.langCode === "ko" ? "개는" : "dog",
            currentLang.langCode === "ko" ? "새는" : "bird",
            currentLang.langCode === "ko" ? "물고기는" : "fish",
            currentLang.keywords.universal_q,
            currentLang.keywords.existential_q,
          ];
          playerA_Hand = fullDeck.filter((c) =>
            requiredA_CardTexts.includes(c.text)
          );

          const wiseCardText =
            currentLang.langCode === "ko" ? "지혜롭다" : "is wise";
          const requiredB_CardTexts = [
            wiseCardText,
            currentLang.keywords.plato,
          ];
          playerB_Hand = fullDeck.filter((c) =>
            requiredB_CardTexts.includes(c.text)
          );
          playerB_Hand.push(
            ...fullDeck
              .filter(
                (c) =>
                  !requiredB_CardTexts.includes(c.text) &&
                  c.type ===
                    (currentLang.langCode === "ko" ? "서술어" : "Predicate")
              )
              .slice(0, 2)
          );
        } else if (step === 2) {
          const socratesCardInfo = currentProposition.find(
            (info) => info.card.text === currentLang.keywords.socrates
          );
          const wiseCardText =
            currentLang.langCode === "ko" ? "지혜롭다" : "is wise";
          const wiseCardIndex = playerB_Hand.findIndex(
            (c) => c.text === wiseCardText
          );

          if (socratesCardInfo && wiseCardIndex > -1) {
            const [wiseCard] = playerB_Hand.splice(wiseCardIndex, 1);
            currentProposition = [
              socratesCardInfo,
              { card: wiseCard, player: "B" },
            ];
            lastCardPlayer = "B";
            currentPlayer = "A";
          }
        } else if (step === 4) {
          currentProposition = [];
          playerA_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "연산자" : "Operator") &&
              c.text !== currentLang.keywords.not
          );
          playerB_Hand = fullDeck.filter(
            (c) =>
              c.type ===
                (currentLang.langCode === "ko" ? "서술어" : "Predicate") &&
              c.text !== (currentLang.langCode === "ko" ? "개이다" : "is a dog")
          );

          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);

          const premises = [
            currentLang.langCode === "ko"
              ? "소크라테스는 개이다"
              : "Socrates is a dog",
            currentLang.langCode === "ko"
              ? "모든 개는 지혜롭다"
              : "Every dog is wise",
          ];
          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          startThinkingTime();
        } else if (step === 5) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises = [
            currentLang.langCode === "ko"
              ? "소크라테스는 선하다"
              : "Socrates is good",
            currentLang.langCode === "ko"
              ? "(소크라테스는 선하다) 라면 (소크라테스는 승리한다)"
              : "(Socrates is good) then (Socrates wins)",
            currentLang.langCode === "ko"
              ? "플라톤은 지혜롭다 는 거짓이다"
              : "Plato is wise is false",
            currentLang.langCode === "ko"
              ? "(플라톤은 승리한다) 라면 (플라톤은 지혜롭다)"
              : "(Plato wins) then (Plato is wise)",
            currentLang.langCode === "ko"
              ? "(어떤 새는 물고기이다) 또는 (어떤 새는 새이다)"
              : "(Some bird is a fish) or (Some bird is a bird)",
            currentLang.langCode === "ko"
              ? "어떤 새는 물고기이다 는 거짓이다"
              : "Some bird is a fish is false",
            currentLang.langCode === "ko"
              ? "(플라톤은 개이다) 라면 (플라톤은 선하다)"
              : "(Plato is a dog) then (Plato is good)",
            currentLang.langCode === "ko"
              ? "(플라톤은 선하다) 라면 (플라톤은 승리한다)"
              : "(Plato is good) then (Plato wins)",
            currentLang.langCode === "ko"
              ? "(소크라테스는 지혜롭다) 그리고 (플라톤은 어리석다)"
              : "(Socrates is wise) and (Plato is foolish)",
            currentLang.langCode === "ko"
              ? "어떤 물고기는 선하다 는 거짓이다 는 거짓이다"
              : "Some fish is good is false is false",
            currentLang.langCode === "ko"
              ? "모든 새는 선하다"
              : "Every bird is good",
            currentLang.langCode === "ko"
              ? "플라톤은 새이다"
              : "Plato is a bird",
            currentLang.langCode === "ko"
              ? "모든 개는 선하다"
              : "Every dog is good",
          ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
        } else if (step === 6) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          const premises =
            currentLang.langCode === "ko"
              ? [
                  "플라톤은 선하다 또는 플라톤은 악하다",
                  "(플라톤은 선하다) 라면 (플라톤은 지혜롭다)",
                  "(플라톤은 악하다) 라면 (플라톤은 지혜롭다)",
                ]
              : [
                  "Plato is good or Plato is evil",
                  "(Plato is good) then (Plato is wise)",
                  "(Plato is evil) then (Plato is wise)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 7) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(소크라테스는 지혜롭다) 라면 (플라톤은 개이다)",
                  "(플라톤은 개이다) 라면 (플라톤은 선하다)",
                ]
              : [
                  "(Socrates is wise) then (Plato is a dog)",
                  "(Plato is a dog) then (Plato is good)",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (parsed) {
              truePropositions.push({
                type: "user-made",
                text: propositionToNaturalText(parsed),
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 8) {
          truePropositions = [];
          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "(소크라테스는 악하다 는 거짓이다) 라면 (플라톤은 지혜롭다)",
                  "플라톤은 지혜롭다 는 거짓이다",
                ]
              : [
                  "(Socrates is evil is false) then (Plato is wise)",
                  "Plato is wise is false",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });
          openEurekaModalTutorial();
        } else if (step === 9) {
          // Stage 9 - Final Puzzle
          truePropositions = [];

          const socratesSubject = currentLang.keywords.socrates;
          const platoSubject = currentLang.keywords.plato;
          currentAxioms = generateAxioms(
            socratesSubject,
            platoSubject,
            currentLang
          );
          parsedAxioms = currentAxioms
            .map((str) => ({
              type: "axiom",
              proposition: parsePropositionFromString(str),
            }))
            .filter((a) => a.proposition);

          internalTruthSet = parsedAxioms.map((a) => a.proposition);
          currentPlayer = "A";
          isThinkingTime = false;
          document.getElementById("thinking-time-controls").style.display =
            "none";

          // 승리 조건 설정
          const socratesVC_Text =
            currentLang.langCode === "ko"
              ? "(소크라테스는 선하다 라면 소크라테스는 승리한다) 그리고 (소크라테스는 승리한다 라면 소크라테스는 선하다)"
              : "(Socrates is good then Socrates wins) and (Socrates wins then Socrates is good)";
          const socratesVC_Parsed = parsePropositionFromString(socratesVC_Text);
          if (socratesVC_Parsed) {
            truePropositions.push({
              type: "victory",
              owner: "A",
              text: propositionToPlainText(socratesVC_Parsed),
              proposition: socratesVC_Parsed,
              ultimate_target: {
                type: "atomic",
                subject: currentLang.keywords.socrates,
                predicate: currentLang.keywords.wins,
              },
              core_goal: {
                type: "atomic",
                subject: currentLang.keywords.socrates,
                predicate: currentLang.langCode === "ko" ? "선하다" : "is good",
              },
            });
            internalTruthSet.push(socratesVC_Parsed);
          }

          const platoVC_Text =
            currentLang.langCode === "ko"
              ? "(플라톤은 어리석다 라면 플라톤은 승리한다) 그리고 (플라톤은 승리한다 라면 플라톤은 어리석다)"
              : "(Plato is foolish then Plato wins) and (Plato wins then Plato is foolish)";
          const platoVC_Parsed = parsePropositionFromString(platoVC_Text);
          if (platoVC_Parsed) {
            truePropositions.push({
              type: "victory",
              owner: "B",
              text: propositionToPlainText(platoVC_Parsed),
              proposition: platoVC_Parsed,
              ultimate_target: {
                type: "atomic",
                subject: currentLang.keywords.plato,
                predicate: currentLang.keywords.wins,
              },
              core_goal: {
                type: "atomic",
                subject: currentLang.keywords.plato,
                predicate:
                  currentLang.langCode === "ko" ? "어리석다" : "is foolish",
              },
            });
            internalTruthSet.push(platoVC_Parsed);
          }

          // 전제 명제 설정
          const premises =
            currentLang.langCode === "ko"
              ? [
                  "소크라테스는 악하다 라면 모든 개는 어리석다",
                  "어떤 개는 지혜롭다 라면 플라톤은 개이다",
                  "모든 개는 지혜롭다",
                ]
              : [
                  "(Socrates is evil) then (Every dog is foolish)",
                  "(Some dog is wise) then (Plato is a dog)",
                  "Every dog is wise",
                ];

          premises.forEach((pText) => {
            const parsed = parsePropositionFromString(pText);
            if (
              parsed &&
              !internalTruthSet.some((p) => arePropositionsEqual(p, parsed))
            ) {
              truePropositions.push({
                type: "user-made",
                text: pText,
                proposition: parsed,
                original_cards: [],
              });
              internalTruthSet.push(parsed);
            }
          });

          openEurekaModalTutorial();
        }

        render();
      }

      function renderModal() {
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        const hasAssumption = !!currentAssumption;
        document.getElementById("add-assumption-btn").disabled = hasAssumption;
        document.getElementById("cancel-assumption-btn").style.display =
          hasAssumption ? "inline-block" : "none";

        derivedPropositionsInModal.forEach((propData) => {
          // 구분선인 경우 특별히 처리
          if (propData.isSeparator) {
            const li = document.createElement("li");
            li.style.height = "8px";
            li.style.background = "transparent";
            li.style.border = "none";
            li.style.padding = "0";
            li.style.margin = "4px 0";
            li.style.pointerEvents = "none"; // 클릭 불가능
            li.style.listStyle = "none";
            li.innerHTML = "<hr style='border: none; border-top: 1px solid rgba(221, 221, 221, 0.3); margin: 0;'>";
            premiseList.appendChild(li);
            return;
          }
          
          const li = document.createElement("li");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          li.dataset.propObject = JSON.stringify(propData);

          if (propData.isAssumption) li.classList.add("assumption-itself");
          else if (propData.dependsOnAssumption)
            li.classList.add("assumption-dependent");

          // 체크박스 비활성화는 handleTutorialRuleApplication에서 처리

          li.appendChild(checkbox);
          let tagClass = "";
          // propData.type에 따라 적절한 CSS 클래스를 할당합니다.
          switch (propData.type) {
            case "axiom":
              tagClass = "tag-axiom";
              break;
            case "victory":
              tagClass = "tag-victory";
              break;
            case "theorem":
              tagClass = "tag-theorem";
              break;
            case "assumption": // 가정을 위한 case 분리
              tagClass = "tag-assumption";
              break;
            default: // "user-made" 등 나머지는 "proposition"으로 처리
              tagClass = "tag-proposition";
              break;
          }

          // 클래스가 적용된 span 태그로 감싸서 HTML에 추가합니다.
          li.innerHTML += ` <span class="${tagClass}">${
            propData.label
          }</span> ${propositionToNaturalText(propData.proposition)}`;

          premiseList.appendChild(li);
        });
      }
      function updateConclusionPreview() {
        const titleEl = document.getElementById("conclusion-preview-title");
        const textEl = document.getElementById("conclusion-preview-text");

        // UI 텍스트 업데이트 (다국어 지원)
        titleEl.innerHTML =
          currentLang.langCode === "ko"
            ? "<strong>결론 미리보기</strong>"
            : "<strong>Conclusion Preview</strong>";

        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );
        const rule = document.getElementById("inference-rule-select").value;
        const premises = selectedLis
          .map((chk) => {
            const propString = chk.parentElement.dataset.propObject;
            return propString ? JSON.parse(propString).proposition : null;
          })
          .filter(Boolean);

        let conclusion = null;
        let requiredPremises = 0;

        // 각 규칙에 필요한 전제 개수 확인
        const onePremiseRules = [
          "conjunctionElimination",
          "doubleNegationElimination",
          "existentialInstantiation",
        ];
        const twoPremiseRules = [
          "modusPonens",
          "modusTollens",
          "hypotheticalSyllogism",
          "disjunctiveSyllogism",
          "universalApplication",
        ];
        const threePremiseRules = ["proofByCases"];

        if (onePremiseRules.includes(rule)) requiredPremises = 1;
        else if (twoPremiseRules.includes(rule)) requiredPremises = 2;
        else if (threePremiseRules.includes(rule)) requiredPremises = 3;
        else if (rule === "conditionalIntroduction") requiredPremises = 1;
        else if (rule === "reductioAdAbsurdum") requiredPremises = 2;

        if (premises.length === requiredPremises && requiredPremises > 0) {
          try {
            if (rule === "conditionalIntroduction") {
              if (currentAssumption) {
                conclusion = {
                  type: "conditional",
                  left: currentAssumption,
                  right: premises[0],
                };
              }
            } else if (rule === "reductioAdAbsurdum") {
              conclusion = reductioAdAbsurdum(
                premises[0],
                premises[1],
                currentAssumption
              );
            } else if (threePremiseRules.includes(rule)) {
              conclusion = window[rule](premises[0], premises[1], premises[2]);
            } else if (twoPremiseRules.includes(rule)) {
              conclusion = window[rule](premises[0], premises[1]);
            } else if (onePremiseRules.includes(rule)) {
              conclusion = window[rule](premises[0]);
            }
          } catch (e) {
            console.error("Preview calculation error:", e);
            conclusion = null;
          }
        }

        if (conclusion) {
          if (Array.isArray(conclusion)) {
            // 단순화 규칙처럼 결과가 여러 개일 경우
            textEl.innerHTML = conclusion
              .map((c) => propositionToNaturalText(c))
              .join("<br>");
          } else {
            textEl.innerHTML = propositionToNaturalText(conclusion);
          }
        } else {
          textEl.innerHTML = `<i>${
            currentLang.langCode === "ko"
              ? "규칙을 적용할 수 없습니다."
              : "Cannot apply rule."
          }</i>`;
        }
      }

      // --- 유레카 모달 리스트 클릭 편의성 개선 코드 ---
      const eurekaPremiseList = document.getElementById("premise-list");

      if (eurekaPremiseList) {
        eurekaPremiseList.addEventListener("click", function (event) {
          // 클릭된 지점에서 가장 가까운 <li> 요소를 찾습니다.
          const targetLi = event.target.closest("li");

          // <li> 요소 안에서 클릭이 발생했다면,
          if (targetLi) {
            // 그 <li> 안에 있는 체크박스를 찾습니다.
            const checkbox = targetLi.querySelector('input[type="checkbox"]');

            // 체크박스가 존재한다면,
            if (checkbox) {
              // 체크박스가 비활성화되어 있으면 클릭 무시
              if (checkbox.disabled) {
                return;
              }

              // 중요: 실제 클릭된 요소(event.target)가 체크박스 자체가 아닐 때만 코드로 상태를 변경합니다.
              // 이렇게 해야 체크박스를 직접 클릭했을 때 상태가 두 번 바뀌는 현상을 막을 수 있습니다.
              if (event.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
              }

              targetLi.classList.toggle("selected", checkbox.checked);

              updateConclusionPreview();
            }
          }
        });
        // --- 전체 화면 기능 로직 ---
        const fullscreenBtn = document.getElementById("fullscreen-btn");

        fullscreenBtn.addEventListener("click", toggleFullScreen);

        function toggleFullScreen() {
          // 부모 창(index.html)에 'toggle-fullscreen' 메시지를 보냄
          window.parent.postMessage("toggle-fullscreen", "*");
        }

        // --- UI 텍스트 업데이트 (다국어 지원) ---
        function updateUIText() {
          document.querySelectorAll("[data-i18n]").forEach((element) => {
            const key = element.getAttribute("data-i18n");
            if (TEXTS.hasOwnProperty(key)) {
              element.textContent =
                TEXTS[`${key}_${currentLanguage}`] || TEXTS[`${key}_ko`]; // 현재 언어 없으면 한국어 기본
            }
          });
        }

        // 초기 로드 시 텍스트 업데이트
        updateUIText();

        // 언어 변경 시 텍스트 업데이트 함수 호출 (기존 언어 변경 로직에 추가 필요)
        // 예시:
        // function changeLanguage(lang) {
        //     currentLanguage = lang;
        //     localStorage.setItem('languagePreference', lang);
        //     updateUIText(); // 텍스트 업데이트
        //     // ... 기존 언어 변경 로직 ...
        // }
      }
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // ✅ 1인 대전과 마찬가지로 새로운 캐릭터 선택 함수를 호출합니다.
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden"); // 메인 센터 숨김
        document.getElementById("credits-btn").classList.add("hidden");
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      function updateMainMenuBtnVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const mainMenuBtn = document.getElementById("main-menu-btn");
        if (mainCenter && mainMenuBtn) {
          if (!mainCenter.classList.contains("hidden")) {
            mainMenuBtn.style.display = "none";
          } else {
            mainMenuBtn.style.display = "";
          }
        }
      }

      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // ✅ 1인 대전과 마찬가지로 새로운 캐릭터 선택 함수를 호출합니다.
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");
        updateMainMenuBtnVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      function updateMainCenterVisibility() {
        const mainCenter = document.querySelector(".main-center-bg");
        const hideList = [
          "#player-a-area .player-title-box",
          "#player-a-area .hand",
          "#player-a-portrait",
          "#player-b-area .player-title-box",
          "#player-b-area .hand",
          "#player-b-portrait",
          "#status > *",
          "#round-display",
          "#new-game-btn",
          "#player-a-area .button-wrapper",
          "#player-b-area .button-wrapper",
        ];
        const shouldHide = !mainCenter.classList.contains("hidden");
        hideList.forEach((sel) => {
          const el = document.querySelector(sel);
          if (el) el.style.visibility = shouldHide ? "hidden" : "visible";
        });
      }
      document.getElementById("main-menu-btn").addEventListener("click", () => {
        // 1. 튜토리얼 중이었다면 튜토리얼을 종료하고 메인 메뉴로 갑니다.
        if (inTutorialMode) {
          endTutorial(); // endTutorial 함수가 음악 전환을 포함한 모든 것을 처리합니다.
          return;
        }
        isTestMode = false;

        // 2. 게임 상태를 초기화합니다.
        clearAllAITimeouts();
        aiPlayer = null;
        gameMode = null;
        gameIsOver = true; // 게임이 끝났음을 명시

        // 3. 메인 메뉴 UI를 표시하고 관련 음악을 재생합니다.
        // 이 함수가 게임 음악 fade-out과 메뉴 음악 fade-in을 모두 담당합니다.
        showMainMenu();
      });
      document.getElementById("vs-player-btn").addEventListener("click", () => {
        if (inTutorialMode) return;
        // ✅ 1인 대전과 마찬가지로 새로운 캐릭터 선택 함수를 호출합니다.
        startCharacterSelection("2P");
      });
      document.getElementById("vs-ai-btn").addEventListener("click", () => {
        if (inTutorialMode || gameMode === "AI") return;
        document.querySelector(".main-center-bg").classList.add("hidden");
        document.getElementById("credits-btn").classList.add("hidden");
        updateMainMenuBtnVisibility();
        updateMainCenterVisibility();
        document
          .getElementById("character-select-modal")
          .classList.add("visible");
      });

      // 초기화 시에도 호출
      updateMainCenterVisibility();

      // 초기화 시에도 호출
      updateMainMenuBtnVisibility();

      function clearAllAITimeouts() {
        if (aiTimeoutId) {
          clearTimeout(aiTimeoutId);
          aiTimeoutId = null;
        }
      }
      function goToMainMenu() {
        isTestMode = false;

        document
          .getElementById("character-selection-screen")
          .classList.add("hidden");
        document
          .getElementById("character-select-indicator")
          .classList.add("hidden");
        document.getElementById("turn-order-modal").classList.remove("visible");

        showMainMenu();

        tempSelections = { p1: null, p2: null };
        characterSelectionTurn = null;
        selectionMode = null;
        gameMode = null;
        aiPlayer = null;
        humanPlayerId = null;

        clearAllAITimeouts();
      }

      function promptAndSetupTestGame(selectedCharacters) {
        try {
          const victoryA = prompt(
            "플레이어 A(1P)의 승리 조건 서술어를 입력하세요. (예: 선하다, is wise)"
          );
          const victoryB = prompt(
            "플레이어 B(AI)의 승리 조건 서술어를 입력하세요. (예: 악하다, is evil)"
          );
          const handA = prompt(
            "플레이어 A의 초기 손패를 쉼표(,)로 구분하여 입력하세요. (예: 소크라테스는, 지혜롭다, 라면)"
          );
          const handB = prompt(
            "플레이어 B의 초기 손패를 쉼표(,)로 구분하여 입력하세요."
          );
          const trueProps = prompt(
            "초기 참 명제들을 세미콜론(;)으로 구분하여 입력하세요. (없으면 비워두세요)"
          );

          const testConfig = {
            victoryA: victoryA || null,
            victoryB: victoryB || null,
            handA: handA || null,
            handB: handB || null,
            trueProps: trueProps || null,
          };

          resetGame(selectedCharacters, testConfig); // 입력받은 설정으로 resetGame 호출
        } catch (e) {
          console.error("테스트 모드 설정 중 오류 발생:", e);
          alert(
            "테스트 모드 설정 중 오류가 발생했습니다. 메인 메뉴로 돌아갑니다."
          );
          goToMainMenu();
        }
      }
      function calculateStrategicValue(proposition, perspectivePlayer) {
        if (!proposition) return 0;

        // ★★★ 핵심 수정: 어떤 명제든 평가하기 전에 먼저 정규화합니다. ★★★
        const normalizedProp = normalizeProposition(proposition);

        const opponentPlayer = perspectivePlayer === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === perspectivePlayer
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );

        if (!myVictoryData || !opponentVictoryData) return 0;

        let score = 0;
        const myUltimateGoal = myVictoryData.ultimate_target;
        const opponentLossCondition = {
          type: "negation",
          proposition: opponentVictoryData.ultimate_target,
        };

        // 1. 직접적인 승/패 조건과 일치하는지 확인 (정규화된 명제로 비교)
        if (arePropositionsEqual(normalizedProp, myUltimateGoal))
          score += 50000;
        if (arePropositionsEqual(normalizedProp, opponentLossCondition))
          score += 50000;

        // 2. 전칭 양화문('모든')의 가치 평가 (정규화된 명제로 비교)
        if (normalizedProp.type === "universal") {
          const myWinPredicate = myVictoryData.core_goal.predicate;
          const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
          const predicatePairs = currentLang.contradictoryPredicates;
          const opponentDefeatPredicate =
            predicatePairs[opponentWinPredicate] ||
            Object.keys(predicatePairs).find(
              (key) => predicatePairs[key] === opponentWinPredicate
            );

          if (normalizedProp.predicate === myWinPredicate) score += 8000;
          if (
            opponentDefeatPredicate &&
            normalizedProp.predicate === opponentDefeatPredicate
          )
            score += 7000;
          if (normalizedProp.predicate === opponentWinPredicate) score -= 9000;
        }

        return score;
      }

      /**
       * 특정 계획(경로)을 수행했을 때의 위험성을 평가하는 함수
       * @param {Array<object>} path - findAllProofPaths가 반환한 계획 경로
       * @param {string} perspectivePlayer - 'A' 또는 'B', 누구의 관점에서 평가할지
       * @returns {boolean} 위험하면 true, 아니면 false
       */
      function isPlanTooRisky(path, perspectivePlayer) {
        if (!path || path.length === 0) return false;

        const opponentPlayer = perspectivePlayer === "A" ? "B" : "A";
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponentPlayer
        );
        if (!opponentVictoryData) return false;

        // 계획의 최종 목표를 달성했을 때의 가상 진리 집합을 만듭니다.
        const finalStep = path[path.length - 1];
        const { success, expandedSet } = verifyAndExpandTruths(
          finalStep,
          internalTruthSet
        );

        if (!success) return true; // 계획 자체가 모순을 일으키면 위험

        // 그 결과 상대의 승리가 증명된다면 이 계획은 위험합니다.
        if (aiFindProof(opponentVictoryData.ultimate_target, expandedSet)) {
          return true;
        }

        return false;
      }

      // --- 각 추론 규칙별 갬빗 평가자 정의 ---
      const GAMBIT_EVALUATORS = [
        {
          name: "Disjunctive Syllogism Gambit",
          trigger: () => {
            return truePropositions.filter(
              (p) => p.proposition && p.proposition.type === "disjunction"
            );
          },
          evaluate: (triggerPropositionData, perspectivePlayer) => {
            const prop = triggerPropositionData.proposition; // P ∨ Q
            const candidates = [];
            const path1 = {
              subGoal: { type: "negation", proposition: prop.left }, // ~P
              result: prop.right, // Q
            };
            const path2 = {
              subGoal: { type: "negation", proposition: prop.right }, // ~Q
              result: prop.left, // P
            };
            [path1, path2].forEach((path) => {
              const benefitScore = calculateStrategicValue(
                path.result,
                perspectivePlayer
              );
              if (benefitScore > 0) {
                candidates.push({
                  gambitName: "Disjunctive Syllogism Gambit",
                  subGoal: path.subGoal,
                  benefitScore: benefitScore,
                });
              }
            });
            return candidates;
          },
        },
        {
          name: "Modus Tollens Gambit",
          trigger: () => {
            return truePropositions.filter(
              (p) => p.proposition && p.proposition.type === "conditional"
            );
          },
          evaluate: (triggerPropositionData, perspectivePlayer) => {
            const prop = triggerPropositionData.proposition; // P → Q
            const candidates = [];
            const subGoal = { type: "negation", proposition: prop.right }; // ~Q
            const result = { type: "negation", proposition: prop.left }; // ~P
            const benefitScore = calculateStrategicValue(
              result,
              perspectivePlayer
            );
            if (benefitScore > 0) {
              candidates.push({
                gambitName: "Modus Tollens Gambit",
                subGoal: subGoal,
                benefitScore: benefitScore,
              });
            }
            return candidates;
          },
        },
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        // ★★★ 아래 '전건 긍정 갬빗' 객체가 새로 추가되었습니다 ★★★
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        {
          name: "Modus Ponens Gambit",
          /**
           * 참 명제 목록에서 '라면'으로 연결된 조건문을 찾아 반환합니다.
           */
          trigger: () => {
            return truePropositions.filter(
              (p) => p.proposition && p.proposition.type === "conditional"
            );
          },
          /**
           * 찾아낸 조건문에 대해 갬빗의 유효성을 평가합니다.
           * @param {object} triggerPropositionData - '라면' 명제를 포함한 데이터 객체
           * @param {string} perspectivePlayer - AI 플레이어 ('A' or 'B')
           * @returns {Array<object>} 평가된 갬빗 계획 후보 목록
           */
          evaluate: (triggerPropositionData, perspectivePlayer) => {
            const prop = triggerPropositionData.proposition; // P → Q
            const candidates = [];

            // 시나리오: P를 증명하여 Q를 얻는다.
            const subGoal = prop.left; // 증명해야 할 목표: P
            const result = prop.right; // 얻게 될 결과: Q

            // 이 갬빗으로 얻는 결과(Q)의 전략적 가치를 계산합니다.
            const benefitScore = calculateStrategicValue(
              result,
              perspectivePlayer
            );

            // 가치가 0보다 클 경우에만 유효한 갬빗 후보로 추가합니다.
            if (benefitScore > 0) {
              candidates.push({
                gambitName: "Modus Ponens Gambit",
                subGoal: subGoal,
                benefitScore: benefitScore,
              });
            }

            return candidates;
          },
        },
      ];

      /**
       * 모든 갬빗 평가자를 실행하여 현재 상황에서 가장 좋은 장기 계획을 찾는 함수
       * @param {string} perspectivePlayer - AI 플레이어 ('A' or 'B')
       * @returns {object | null} 가장 좋은 갬빗 계획 또는 null
       */
      function findBestGambitPlan(perspectivePlayer) {
        let allCandidateGambits = [];

        // 1. 모든 갬빗 평가자를 순회합니다.
        for (const evaluator of GAMBIT_EVALUATORS) {
          const triggers = evaluator.trigger();
          for (const trigger of triggers) {
            // 2. 각 트리거에 대해 유효한 갬빗들을 평가하여 목록에 추가합니다.
            const gambits = evaluator.evaluate(trigger, perspectivePlayer);
            allCandidateGambits.push(...gambits);
          }
        }

        if (allCandidateGambits.length === 0) return null;

        let viablePlans = [];
        // 3. 찾아낸 모든 갬빗 후보에 대해, 목표 달성 경로를 탐색합니다.
        for (const gambit of allCandidateGambits) {
          let proofPaths = [];
          // `findAllProofPaths`를 이용해 subgoal을 증명할 방법을 찾습니다.
          findAllProofPaths(gambit.subGoal, [], proofPaths, 0);

          if (proofPaths.length > 0) {
            // 가장 짧은 경로를 선택합니다.
            proofPaths.sort((a, b) => a.steps.length - b.steps.length);
            const bestPath = proofPaths[0].steps;

            // 4. 해당 경로가 너무 위험하지는 않은지 최종 확인합니다.
            if (!isPlanTooRisky(bestPath, perspectivePlayer)) {
              viablePlans.push({
                ...gambit,
                path: bestPath,
                // 최종 점수 = 이득 점수 - 경로 길이 (짧을수록 좋음)
                finalScore: gambit.benefitScore - bestPath.length * 100,
              });
            }
          }
        }

        if (viablePlans.length === 0) return null;

        // 5. 실행 가능한 모든 계획 중 가장 점수가 높은 것을 선택합니다.
        viablePlans.sort((a, b) => b.finalScore - a.finalScore);
        return viablePlans[0];
      }

      function activatePlatoAbility(player) {
        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "existential"
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "보편화할 수 있는 명제가 없습니다."
              : "There are no propositions to universalize."
          );
          return;
        }

        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.ui.platoAbilityTitle;
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.ui.platoConfirmButton;

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // 목록 초기화
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection"; // 공통 이름 사용
          radio.value = index;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 범용 모달의 닫기/확인 버튼에 *플라톤*의 로직을 연결
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmPlatoAbility;

        modal.classList.add("visible");
      }

      /**
       * 플라톤 능력 모달에서 '확인' 버튼을 눌렀을 때 실행되는 함수
       */
      function confirmPlatoAbility() {
        // 1. 선택된 라디오 버튼과 명제를 찾습니다.
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) {
          return;
        }

        const selectedIndex = parseInt(selectedRadio.value, 10);
        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "existential"
        );
        const selectedPropData = availablePropositions[selectedIndex];

        if (!selectedPropData) {
          console.error(
            "Plato Ability Error: Could not find the selected proposition."
          );
          return;
        }

        // 2. 선택된 '어떤' 명제를 '모든' 명제로 변환합니다.
        const originalProp = selectedPropData.proposition;
        const universalProp = {
          type: "universal",
          entity: originalProp.entity,
          predicate: originalProp.predicate,
        };

        // 3. 새로운 '모든' 명제가 기존 진리 체계와 모순되지 않는지 검증합니다.
        const verificationResult = verifyAndExpandTruths(universalProp);

        if (verificationResult.success) {
          // 4. 검증 성공 시, 능력 사용 상태를 기록하고 새 명제를 추가합니다.
          const philosopherId =
            thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
          abilityUsedState[thinkingTimeTurn].used = true;

          truePropositions.push({
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem", // 타입은 'theorem'으로 유지
            source: "plato_ability", // '이데아 회상' 출처 명시
            proposition: universalProp,
          });
          internalTruthSet = verificationResult.expandedSet;

          // 5. 모달을 닫고 게임 상태를 갱신합니다.
          document.getElementById("ability-modal").classList.remove("visible");
          showAlert(
            currentLang.langCode === "ko"
              ? "새로운 보편 명제가 참 목록에 추가되었습니다!"
              : "A new universal proposition has been added to the true list!"
          );
          render();
        } else {
          // 6. 모순 발생 시, 사용자에게 알립니다.
          showAlert(currentLang.alerts.contradictionFound);
        }
      }

      function activateSocratesAbility(player) {
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        const state = abilityUsedState[player];

        if (state && state.usedCount >= state.maxUses) {
          showAlert(
            currentLang.langCode === "ko"
              ? "이미 능력을 모두 사용했습니다."
              : "Ability has already been used up."
          );
          return;
        }
        const availablePropositions = truePropositions.filter((p) => {
          // 1. 타입이 'user-made' 또는 'theorem'이어야 함 (기존 조건)
          const isTargetType = p.type === "user-made" || p.type === "theorem";
          if (!isTargetType) return false;

          // 2. 해당 명제가 이미 비활성화 목록에 있는지 확인 (새로운 조건)
          const isDisabled = socratesDisabledProps.some(
            (disabledProp) => disabledProp.propId === p.propId
          );

          // 3. 비활성화되지 않은 명제만 최종 목록에 포함
          return !isDisabled;
        });

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "비활성화할 수 있는 명제가 없습니다."
              : "There are no propositions to disable."
          );
          return;
        }

        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.ui.socratesAbilityTitle;
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.ui.socratesConfirmButton;

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // 목록 초기화
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection"; // 공통 이름 사용
          radio.value = propData.propId;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 범용 모달의 닫기/확인 버튼에 *소크라테스*의 로직을 연결
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmSocratesAbility;

        modal.classList.add("visible");
      }
      function confirmSocratesAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;

        // socratesDisabledProps 배열에는 이제 propId만 저장합니다.
        // 더 이상 proposition 객체를 저장할 필요가 없습니다.
        socratesDisabledProps.push({
          propId: selectedPropId,
          reEnableRound: currentRound + 2,
        });

        // 능력 사용 처리
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].usedCount++;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "선택한 명제가 다음 라운드 동안 논증에서 제외됩니다."
            : "The selected proposition will be excluded from arguments for the next round."
        );
        render(); // UI 즉시 갱신
      }
      function activateDescartesAbility(player) {
        // 삭제 가능한 명제 (공리, 승리조건 제외) 목록을 준비합니다.
        const availablePropositions = truePropositions.filter(
          (p) => p.type === "user-made" || p.type === "theorem"
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "삭제할 수 있는 명제가 없습니다."
              : "There are no propositions to delete."
          );
          return;
        }

        // 범용 능력 모달창을 가져와 내용을 데카르트에 맞게 수정합니다.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko" ? "방법적 회의" : "Methodic Doubt";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "이 명제를 삭제하기"
            : "Delete this Proposition";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // 목록 초기화

        // 삭제 가능한 명제들로 선택 목록을 채웁니다.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          // propId를 값으로 사용하여 어떤 명제를 삭제할지 식별합니다.
          radio.value = propData.propId;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 모달의 닫기/확인 버튼에 데카르트 전용 함수를 연결합니다.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmDescartesAbility;

        modal.classList.add("visible");
      }

      function confirmDescartesAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;

        // 1. truePropositions 배열에서 삭제할 명제의 인덱스를 찾습니다.
        const propIndex = truePropositions.findIndex(
          (p) => p.propId === selectedPropId
        );

        if (propIndex === -1) {
          console.error("Descartes Ability Error: Proposition ID not found.");
          return;
        }

        // 2. 해당 명제를 배열에서 제거합니다.
        truePropositions.splice(propIndex, 1);

        // 3. ★★★ 핵심 단계 ★★★
        //    명제 하나가 사라졌으므로, 전체 논리 체계에 모순이 생겼을 수 있습니다.
        //    따라서 공리부터 시작하여 남아있는 명제들로 진리 집합(internalTruthSet)을 완전히 재구성합니다.
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after Descartes' ability: Inconsistency found while rebuilding truth set."
            );
            // 실제 게임에서는 이 오류를 더 견고하게 처리해야 할 수 있습니다.
          }
        }
        internalTruthSet = newTruthSet;

        // 4. 능력 사용 상태를 기록하고 UI를 갱신합니다.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "선택한 명제가 참 목록에서 삭제되었습니다."
            : "The selected proposition has been deleted from the true list."
        );
        render();
      }
      function activateWittgensteinAbility(player) {
        // 유레카 모달과 동일하게 내부 상태를 초기화합니다.
        derivedPropositionsInModal = [];
        currentAssumption = null;

        const modal = document.getElementById("eureka-modal");
        const premiseList = document.getElementById("premise-list");
        premiseList.innerHTML = "";

        // 유레카 모달과 똑같이 사용 가능한 모든 전제를 가져옵니다.
        const allSelectablePropositions = [
          ...parsedAxioms,
          ...truePropositions
            .map((p) => ({ ...p, proposition: p.proposition }))
            .filter((p) => p.proposition),
        ].filter(
          (propData) =>
            !propData.propId ||
            !socratesDisabledProps.some((dp) => dp.propId === propData.propId)
        );

        // 공리들을 그룹별로 분류하고 순서대로 추가 (openEurekaModal과 동일)
        const axioms = allSelectablePropositions.filter(p => p.type === "axiom");
        const nonAxioms = allSelectablePropositions.filter(p => p.type !== "axiom");
        
        // 공리를 그룹화하여 추가 - 작은 서브그룹별로 구분선 추가
        if (currentAxioms.groups && axioms.length > 0) {
          const groups = currentAxioms.groups;
          const templates = currentLang.axiom_templates;
          let axiomIndex = 0;
          
          // 정체성 공리 그룹
          if (groups.identity && groups.identity.length > 0) {
            for (let i = 0; i < groups.identity.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 정체성 그룹 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // 개체별 속성 대립 그룹 - 서브그룹별로 나누기
          if (groups.subjectOpposition && groups.subjectOpposition.length > 0) {
            // 첫 번째 철학자 선악 공리
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 첫 번째 철학자 지혜 공리
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 두 번째 철학자 선악 공리
            for (let i = 0; i < templates.subject_good_evil.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 두 번째 철학자 지혜 공리
            for (let i = 0; i < templates.subject_wise_foolish.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 개체별 속성 대립 그룹 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
          
          // 집단별 속성 대립 그룹 - 서브그룹별로 나누기
          if (groups.quantifierOpposition && groups.quantifierOpposition.length > 0) {
            // 새 집단 순방향
            for (let i = 0; i < templates.bird_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 새 집단 역방향
            for (let i = 0; i < templates.bird_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 물고기 집단 순방향
            for (let i = 0; i < templates.fish_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 물고기 집단 역방향
            for (let i = 0; i < templates.fish_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 개 집단 순방향
            for (let i = 0; i < templates.dog_good_evil_forward.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 서브그룹 구분선
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
            
            // 개 집단 역방향
            for (let i = 0; i < templates.dog_good_evil_reverse.length; i++) {
              if (axiomIndex < axioms.length) {
                addPremiseToWorkbench({
                  ...axioms[axiomIndex],
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              }
            }
            
            // 마르크스 공리가 있으면 추가
            const remainingAxioms = axioms.slice(axiomIndex);
            const marxAxioms = remainingAxioms.filter(a => {
              const text = propositionToNaturalText(a.proposition);
              return text.includes("브루주아") || text.includes("Bourgeois");
            });
            
            if (marxAxioms.length > 0) {
              // 서브그룹 구분선
              addPremiseToWorkbench({
                type: "separator",
                label: "",
                proposition: null,
                isSeparator: true
              });
              
              marxAxioms.forEach((axiomData) => {
                addPremiseToWorkbench({
                  ...axiomData,
                  label: currentLang.labels.axiom
                });
                axiomIndex++;
              });
            }
            
            // 집단별 속성 대립 그룹 마지막 구분선 추가
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        } else {
          // 기존 방식으로 공리 추가 (하위 호환성)
          axioms.forEach((propData) => {
            addPremiseToWorkbench({
              ...propData,
              label: currentLang.labels.axiom
            });
          });
          
          // 공리 마지막 구분선 추가
          if (axioms.length > 0) {
            addPremiseToWorkbench({
              type: "separator",
              label: "",
              proposition: null,
              isSeparator: true
            });
          }
        }
        
        // 공리가 아닌 명제들 추가
        nonAxioms.forEach((propData) => {
          let label;
          switch (propData.type) {
            case "victory":
              label = currentLang.labels.victory_condition;
              break;
            case "theorem":
              label = currentLang.labels.theorem;
              break;
            default:
              label = currentLang.labels.proposition;
          }
          addPremiseToWorkbench({
            proposition: propData.proposition,
            type: propData.type,
            propId: propData.propId, // propId도 함께 전달
            dependsOnAssumption: false,
            isAssumption: false,
            label: label,
          });
        });

        const modalTitle = document.getElementById("eureka-title");
        const confirmBtn = document.getElementById("modal-confirm-btn");

        // 모달의 제목과 버튼을 비트겐슈타인 전용으로 설정합니다.
        modalTitle.textContent = currentLang.ui.wittgensteinAbilityTitle;
        confirmBtn.textContent = currentLang.ui.wittgensteinConfirmButton;

        // 확인 버튼 클릭 시, 비트겐슈타인 전용 확인 함수를 호출하도록 연결합니다.
        confirmBtn.onclick = confirmWittgensteinAbility;

        renderModal();
        document.getElementById("inference-rule-select").onchange =
          updateConclusionPreview;
        updateConclusionPreview();

        modal.classList.add("visible");
      }
      function confirmWittgensteinAbility() {
        const selectedLis = Array.from(
          document.querySelectorAll(
            '#premise-list input[type="checkbox"]:checked'
          )
        );

        // 1. 유효성 검사: 반드시 하나의 '정리'만 선택해야 합니다.
        if (selectedLis.length !== 1) {
          showAlert(currentLang.alerts.selectOneTheoremOnly);
          return;
        }
        const finalTheoremData = JSON.parse(
          selectedLis[0].parentElement.dataset.propObject
        );
        if (
          finalTheoremData.type !== "theorem" ||
          finalTheoremData.dependsOnAssumption
        ) {
          showAlert(currentLang.alerts.selectOneTheoremOnly);
          return;
        }

        // 2. 재귀적으로 모든 상위 전제를 추적합니다.
        const premisesToKick = new Map(); // 중복 방지를 위해 Map 사용 (key: propId 또는 proposition 텍스트)

        function findAndAddSources(theoremData) {
          if (
            !theoremData.sourcePremises ||
            theoremData.sourcePremises.length === 0
          ) {
            return; // 더 이상 거슬러 올라갈 전제가 없으면 종료
          }

          for (const source of theoremData.sourcePremises) {
            // source.propId가 있는 경우 (원본 참 명제) 그것을 key로 사용
            const key = source.propId
              ? source.propId
              : propositionToText(source.proposition);
            if (!premisesToKick.has(key)) {
              premisesToKick.set(key, source);
              // 계속해서 상위 전제를 추적
              findAndAddSources(source);
            }
          }
        }

        findAndAddSources(finalTheoremData);

        // 3. 추적된 전제들을 '참 명제 목록'에서 삭제합니다.
        const idsToDelete = new Set();
        premisesToKick.forEach((source) => {
          // 원본 참 명제 목록에서 온 전제들만 ID가 있습니다.
          if (source.propId) {
            if (
              source.propId &&
              source.type !== "victory" &&
              source.type !== "axiom"
            ) {
              idsToDelete.add(source.propId);
            }
          }
        });

        truePropositions = truePropositions.filter(
          (p) => !idsToDelete.has(p.propId)
        );

        // 4. 최종적으로 도출된 새로운 정리를 참 목록에 추가합니다.
        truePropositions.push({
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem",
          round: currentRound,
          proposition: finalTheoremData.proposition,
          source: "wittgenstein_ability",
        });

        // 5. 전체 진리 집합을 재구성하여 논리적 일관성을 유지합니다.
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Wittgenstein ability critical error: Inconsistency found."
            );
          }
        }
        internalTruthSet = newTruthSet;

        // 6. 능력 사용 상태를 업데이트하고 마무리합니다.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        document.getElementById("eureka-modal").classList.remove("visible");
        showAlert(currentLang.alerts.wittgensteinSuccess);
        render();
      }
      function activateDerridaAbility(player) {
        // 1. 분해 가능한 명제(연결사로 이어진 명제)만 필터링합니다.
        const availablePropositions = truePropositions.filter(
          (p) =>
            p.type !== "victory" &&
            p.proposition &&
            (p.proposition.type === "conditional" ||
              p.proposition.type === "conjunction" ||
              p.proposition.type === "disjunction")
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "분해할 수 있는 명제가 없습니다."
              : "There are no compound propositions to deconstruct."
          );
          return;
        }

        // 2. 범용 능력 모달 UI를 설정합니다.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko" ? "해체" : "Deconstruction";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "이 명제를 해체하기"
            : "Deconstruct this Proposition";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // 목록 초기화

        // 3. 필터링된 명제로 선택 목록을 만듭니다.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          // propId를 값으로 저장하여 어떤 명제를 선택했는지 식별합니다.
          radio.value = propData.propId;
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 4. 확인/취소 버튼에 데리다 전용 함수를 연결하고 모달을 엽니다.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmDerridaAbility;

        modal.classList.add("visible");
      }

      /**
       * 데리다 능력 실행 및 검증 함수
       */
      function confirmDerridaAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;
        const selectedPropData = truePropositions.find(
          (p) => p.propId === selectedPropId
        );

        if (!selectedPropData) {
          console.error(
            "Derrida Ability Error: Selected proposition not found."
          );
          return;
        }

        const { left, right } = selectedPropData.proposition;

        // --- 핵심 로직: 삭제와 추가가 모두 가능한지 '미리' 검증하는 단계 ---

        // 1. 선택된 원본 명제를 '제외한' 나머지 명제 목록을 만듭니다.
        const propositionsWithoutOriginal = truePropositions.filter(
          (p) => p.propId !== selectedPropId
        );

        // 2. 이 임시 목록을 기반으로 진리 집합을 '재구성'하여, 원본 명제가 없었을 때의 상태를 만듭니다.
        let baseTruthSetForTest = parsedAxioms.map((a) => a.proposition);
        const propsToReverify = propositionsWithoutOriginal
          .filter((p) => p.proposition)
          .map((p) => p.proposition);
        for (const prop of propsToReverify) {
          const verification = verifyAndExpandTruths(prop, baseTruthSetForTest);
          if (verification.success) {
            baseTruthSetForTest = verification.expandedSet;
          } else {
            console.error(
              "Derrida Pre-check Error: Inconsistency found when creating base set."
            );
            showAlert(currentLang.alerts.criticalErrorUndo); // 내부 오류 알림
            return;
          }
        }

        // 3. '원본이 삭제된' 상태에서, 분해된 첫 번째(left) 명제를 추가했을 때 모순이 없는지 확인합니다.
        const verification1 = verifyAndExpandTruths(left, baseTruthSetForTest);
        if (!verification1.success) {
          showAlert(currentLang.alerts.contradictionFound);
          return;
        }

        // 4. 이어서 두 번째(right) 명제를 추가했을 때 모순이 없는지 최종 확인합니다.
        const verification2 = verifyAndExpandTruths(
          right,
          verification1.expandedSet
        );
        if (!verification2.success) {
          showAlert(currentLang.alerts.contradictionFound);
          return;
        }

        // 5. 모든 검증을 통과했으므로 능력 사용을 확정합니다.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        // 6. 검증이 모두 끝났으므로, 실제 게임 상태를 변경합니다.
        //    - 원본 복합 명제를 삭제합니다. (이미 만들어 둔 리스트 재활용)
        truePropositions = propositionsWithoutOriginal;
        //    - 분해된 두 명제를 추가합니다.
        const newProps = [
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: left,
          },
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: right,
          },
        ];
        truePropositions.push(...newProps);

        // 7. 최종적으로 검증된 진리 집합으로 내부 상태를 업데이트합니다.
        internalTruthSet = verification2.expandedSet;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "명제가 성공적으로 해체되었습니다."
            : "The proposition has been successfully deconstructed."
        );
        render();
      }
      function activateHumeAbility(player) {
        // 1. 교체 가능한 명제('모든'으로 시작하는 전칭 양화문)만 필터링합니다.
        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "universal"
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "교체할 수 있는 전칭 명제가 없습니다."
              : "There are no universal propositions to replace."
          );
          return;
        }

        // 2. 범용 능력 모달 UI를 흄에 맞게 설정합니다.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko"
            ? "귀납의 문제"
            : "Problem of Induction";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "이 명제를 교체하기"
            : "Replace this Proposition";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // 목록 초기화

        // 3. 필터링된 명제로 선택 목록을 채웁니다.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          radio.value = propData.propId; // propId를 값으로 저장
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 4. 모달의 버튼에 흄 전용 확인 함수를 연결하고 모달을 엽니다.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmHumeAbility;

        modal.classList.add("visible");
      }

      /**
       * 흄 능력 실행: 선택한 명제를 교체하고 게임 상태를 업데이트합니다.
       */
      function confirmHumeAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;
        const propIndex = truePropositions.findIndex(
          (p) => p.propId === selectedPropId
        );

        if (propIndex === -1) {
          console.error("Hume Ability Error: Proposition ID not found.");
          return;
        }

        const originalProp = truePropositions[propIndex].proposition;

        // 1. 선택된 전칭 명제를 존재 명제로 변환합니다.
        const newExistentialProp = {
          type: "existential",
          entity: originalProp.entity,
          predicate: originalProp.predicate,
        };

        // 2. 기존 '모든' 명제를 새로 만든 '어떤' 명제로 교체합니다.
        truePropositions[propIndex].proposition = newExistentialProp;

        // 💡 [버그 수정] 렌더링 문제를 해결하기 위해 기존 카드 정보를 제거합니다.
        // 이렇게 하면 render() 함수가 새로운 proposition 객체를 기반으로 텍스트를 그리게 됩니다.
        truePropositions[propIndex].original_cards = null;
        truePropositions[propIndex].type = "theorem";
        truePropositions[propIndex].source = "hume_ability";

        // 3. 데카르트 능력처럼, 강력한 전제가 약화되었으므로 전체 진리 집합을 재구성하여 논리적 일관성을 보장합니다.
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after Hume's ability: Inconsistency found."
            );
          }
        }
        internalTruthSet = newTruthSet;

        // 4. 능력 사용 횟수를 1 증가시킵니다.
        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].usedCount++;

        // 5. 모달을 닫고, 결과를 알리고, 화면을 새로고침합니다.
        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "선택한 명제가 존재 양화문으로 교체되었습니다."
            : "The selected proposition has been replaced with an existential one."
        );
        render();
      }

      function activateKuhnAbility(player) {
        // 1. '모든'으로 시작하는 보편 명제인지 확인합니다.
        // 2. getOppositePredicate 함수를 이용해 해당 명제의 술어에 반대 개념이 존재하는지 확인합니다.
        const availablePropositions = truePropositions.filter(
          (p) =>
            p.proposition &&
            p.proposition.type === "universal" &&
            getOppositePredicate(p.proposition.predicate) !== null
        );

        if (availablePropositions.length === 0) {
          showAlert(
            currentLang.langCode === "ko"
              ? "패러다임을 전환할 보편 명제가 없습니다."
              : "There are no universal propositions for a paradigm shift."
          );
          return;
        }

        // 2. 범용 능력 모달 UI를 쿤에 맞게 설정합니다.
        const modal = document.getElementById("ability-modal");
        document.getElementById("ability-title").textContent =
          currentLang.langCode === "ko" ? "패러다임 전환" : "Paradigm Shift";
        document.getElementById("ability-confirm-btn").textContent =
          currentLang.langCode === "ko"
            ? "패러다임 전환하기"
            : "Shift Paradigm";

        const listEl = document.getElementById("ability-list");
        listEl.innerHTML = ""; // 목록 초기화

        // 3. 필터링된 명제로 선택 목록을 채웁니다.
        availablePropositions.forEach((propData, index) => {
          const li = document.createElement("li");
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = "ability-selection";
          radio.value = propData.propId; // propId를 값으로 저장
          if (index === 0) radio.checked = true;

          const label = document.createElement("label");
          label.innerHTML = propositionToNaturalText(propData.proposition);

          li.appendChild(radio);
          li.appendChild(label);
          li.addEventListener("click", () => {
            radio.checked = true;
          });
          listEl.appendChild(li);
        });

        // 4. 모달의 버튼에 쿤 전용 확인 함수를 연결하고 모달을 엽니다.
        document.getElementById("close-ability-modal-btn").onclick = () =>
          modal.classList.remove("visible");
        document.getElementById("ability-confirm-btn").onclick =
          confirmKuhnAbility;

        modal.classList.add("visible");
      }

      function confirmKuhnAbility() {
        const selectedRadio = document.querySelector(
          'input[name="ability-selection"]:checked'
        );
        if (!selectedRadio) return;

        const selectedPropId = selectedRadio.value;
        const originalPropData = truePropositions.find(
          (p) => p.propId === selectedPropId
        );

        if (!originalPropData) {
          console.error("Kuhn Ability Error: Selected proposition not found.");
          return;
        }

        // --- (1) 새로운 패러다임 명제 생성 ---
        const originalPredicate = originalPropData.proposition.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;

        let newPredicate = null;
        for (const key in predicatePairs) {
          if (key === originalPredicate) {
            newPredicate = predicatePairs[key];
            break;
          }
          if (predicatePairs[key] === originalPredicate) {
            newPredicate = key;
            break;
          }
        }

        if (!newPredicate) {
          showAlert(
            currentLang.langCode === "ko"
              ? "이 명제의 반대 술어를 찾을 수 없습니다."
              : "Cannot find an opposite predicate for this proposition."
          );
          return;
        }

        const newParadigmProposition = {
          type: "universal",
          entity: originalPropData.proposition.entity,
          predicate: newPredicate,
        };

        const newParadigmPropForList = {
          propId: `prop_${Date.now()}_paradigm`,
          type: "theorem", // 새로운 패러다임은 '정리'로 취급
          source: "kuhn_ability",
          proposition: newParadigmProposition,
        };

        // --- (2) 기반 진리 목록 생성 및 사전 검증 ---
        const axioms = parsedAxioms.map((a) => a.proposition);
        const victoryConditions = truePropositions
          .filter((p) => p.type === "victory")
          .map((p) => p.proposition);

        const foundationOfTruths = [
          ...axioms,
          ...victoryConditions,
          newParadigmProposition,
        ];

        const preCheckResult = verifyAndExpandTruths(null, foundationOfTruths);

        if (!preCheckResult.success) {
          showAlert(
            currentLang.langCode === "ko"
              ? "새로운 패러다임이 기존 공리나 승리 조건과 모순되어 능력을 발동할 수 없습니다."
              : "The new paradigm contradicts basic axioms or win conditions and cannot be activated."
          );
          return;
        }

        let currentValidatedTruths = preCheckResult.expandedSet;
        let survivingPropositions = [
          ...truePropositions.filter((p) => p.type === "victory"),
          newParadigmPropForList,
        ];

        // --- (3) 기존 명제 재검증 ---
        const candidatesForRevalidation = truePropositions.filter(
          (p) =>
            (p.type === "user-made" || p.type === "theorem") &&
            p.propId !== selectedPropId
        );

        for (const candidate of candidatesForRevalidation) {
          const validationResult = verifyAndExpandTruths(
            candidate.proposition,
            currentValidatedTruths
          );

          if (validationResult.success) {
            // 모순 없음 (생존)
            currentValidatedTruths = validationResult.expandedSet;
            survivingPropositions.push(candidate);
          }
          // 모순 발생 시 (폐기), 아무것도 하지 않음.
        }

        // --- (4) 최종 목록 확정 및 UI 갱신 ---
        truePropositions = survivingPropositions;
        internalTruthSet = currentValidatedTruths;

        const philosopherId =
          thinkingTimeTurn === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[thinkingTimeTurn].used = true;

        document.getElementById("ability-modal").classList.remove("visible");
        showAlert(
          currentLang.langCode === "ko"
            ? "패러다임이 전환되었습니다!"
            : "Paradigm has shifted!"
        );
        render();
      }
      function renderKantModal(player) {
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        const handDisplay = document.getElementById("kant-hand-display");
        const propDisplay = document.getElementById("kant-proposition-display");

        const colorClass = player === "A" ? "card-white" : "card-black";

        handDisplay.innerHTML = "";
        propDisplay.innerHTML = "";

        // 1. 손패 영역 렌더링
        hand.forEach((card) => {
          const cardEl = document.createElement("div");

          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = card.text;
          cardEl.onclick = () => {
            const tempPropositionForValidation = kantProposition.map((c) => ({
              card: c,
              player: player,
            }));

            if (isValidPlay(card, tempPropositionForValidation)) {
              const cardIndex = hand.findIndex(
                (c) => c.text === card.text && c.type === card.type
              );
              if (cardIndex > -1) {
                const [movedCard] = hand.splice(cardIndex, 1);
                kantProposition.push(movedCard);
                renderKantModal(player);
              }
            } else {
              showAlert(currentLang.alerts.invalidCard);
            }
          };
          handDisplay.appendChild(cardEl);
        });

        // 2. 명제 구성 영역 렌더링
        kantProposition.forEach((card) => {
          const cardEl = document.createElement("div");

          cardEl.className = `card ${colorClass}`;
          cardEl.textContent = card.text;
          propDisplay.appendChild(cardEl);
        });

        // 3. 되돌리기 버튼 활성화/비활성화
        document.getElementById("kant-undo-btn").disabled =
          kantProposition.length === 0;
      }

      function confirmKantAbility(player) {
        // 1. 명제가 비어있는지 확인
        if (kantProposition.length === 0) {
          return;
        }

        // 2. 문법적 완결성 검사
        // parsePropositionFromCards는 {card: cardObject} 형태의 배열을 기대하므로 변환
        const parsedProp = parsePropositionFromCards(
          kantProposition.map((c) => ({ card: c }))
        );
        if (!parsedProp) {
          showAlert(currentLang.alerts.incompleteProposition);
          return;
        }

        // 4. 논리적 모순 검사
        const verificationResult = verifyAndExpandTruths(parsedProp);
        if (!verificationResult.success) {
          showAlert(currentLang.alerts.contradictionFound);
          return;
        }

        // 5. 모든 검사를 통과: 능력 사용 처리
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[player].used = true;

        // 6. 새로운 명제를 참 목록에 추가
        truePropositions.push({
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem", // 능력으로 만든 명제는 '정리'로 취급
          source: "kant_ability", // 칸트 능력 출처 명시
          proposition: parsedProp,
        });

        // 7. 내부 진리 집합 업데이트
        internalTruthSet = verificationResult.expandedSet;

        // 8. 마무리
        const modal = document.getElementById("kant-ability-modal");
        modal.classList.remove("visible");
        kantProposition = []; // 임시 명제 배열 비우기

        showAlert(currentLang.alerts.kantSuccess);
        render(); // 게임 화면 전체 갱신
      }

      /**
       * 칸트 능력 활성화: 모달창을 설정하고 띄웁니다.
       */
      function activateKantAbility(player) {
        kantProposition = []; // 명제 배열 초기화
        const modal = document.getElementById("kant-ability-modal");

        // UI 텍스트 설정
        document.getElementById("kant-ability-title").textContent =
          currentLang.langCode === "ko"
            ? "선험적 종합판단"
            : "Synthetic A Priori Judgment";
        document.getElementById("kant-current-proposition-title").textContent =
          currentLang.langCode === "ko"
            ? "구성중인 명제"
            : "Proposition under Construction";
        document.getElementById("kant-hand-title").textContent =
          currentLang.langCode === "ko"
            ? "사용 가능한 카드"
            : "Available Cards";
        document.getElementById("kant-undo-btn").textContent =
          currentLang.ui.undoButton;
        document.getElementById("kant-confirm-btn").textContent =
          currentLang.ui.completeButton;

        // 되돌리기 버튼 기능 연결
        document.getElementById("kant-undo-btn").onclick = () => {
          audioManager.playSfx("hover");
          if (kantProposition.length > 0) {
            const cardToReturn = kantProposition.pop();
            const hand = player === "A" ? playerA_Hand : playerB_Hand;
            hand.push(cardToReturn);
            // 손패 정렬을 다시 해주는 것이 좋습니다.
            hand.sort(
              (a, b) =>
                cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
            );
            renderKantModal(player);
          }
        };

        // 닫기 버튼 기능 연결 (중요: 취소 시 카드를 모두 손패로 되돌림)
        document.getElementById("close-kant-modal-btn").onclick = () => {
          audioManager.playSfx("hover");
          if (kantProposition.length > 0) {
            const hand = player === "A" ? playerA_Hand : playerB_Hand;
            hand.push(...kantProposition);
            kantProposition = [];
            hand.sort(
              (a, b) =>
                cardTypeOrder.indexOf(a.type) - cardTypeOrder.indexOf(b.type)
            );
          }
          modal.classList.remove("visible");
          render(); // 메인 게임 화면도 갱신
        };

        document.getElementById("kant-confirm-btn").onclick = () => {
          audioManager.playSfx("hover");
          confirmKantAbility(player);
        };

        // 초기 모달 렌더링 및 표시
        renderKantModal(player);
        modal.classList.add("visible");
      }
      function executePlatoAbilityCheck(player) {
        // 1. 사용 가능한 '어떤' 명제 찾기
        const availableExistentials = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "existential"
        );
        if (availableExistentials.length === 0) {
          return null;
        }

        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData) {
          return null;
        }
        const myGoalPredicate = myVictoryData.core_goal.predicate;
        const opponentGoalPredicate = opponentVictoryData
          ? opponentVictoryData.core_goal.predicate
          : null;

        const opponentDefeatPredicate = opponentGoalPredicate
          ? currentLang.contradictoryPredicates[opponentGoalPredicate] ||
            Object.keys(currentLang.contradictoryPredicates).find(
              (key) =>
                currentLang.contradictoryPredicates[key] ===
                opponentGoalPredicate
            )
          : null;

        const candidates = availableExistentials.map((propData) => {
          const originalProp = propData.proposition;
          const universalProp = {
            type: "universal",
            entity: originalProp.entity,
            predicate: originalProp.predicate,
          };
          const isAlreadyKnown = truePropositions.some(
            (p) =>
              p.proposition &&
              arePropositionsEqual(p.proposition, universalProp)
          );

          if (isAlreadyKnown) {
            return { newProp: universalProp, score: -1 };
          }
          let score = 100;
          if (universalProp.predicate === myGoalPredicate) {
            score += 10000;
          }
          if (
            opponentDefeatPredicate &&
            universalProp.predicate === opponentDefeatPredicate
          ) {
            score += 8000;
          }
          if (
            opponentGoalPredicate &&
            universalProp.predicate === opponentGoalPredicate
          ) {
            score -= 5000;
          }

          const verificationResult = verifyAndExpandTruths(
            universalProp,
            internalTruthSet
          );

          if (!verificationResult.success) {
            // 1. 직접적인 모순이 발생하면 즉시 제외
            score = -1;
          } else {
            // 2. 모순이 없다면, 능력 사용으로 확장된 진리 집합에서
            //    상대방의 승리가 증명되는지 '논리 연쇄'를 시뮬레이션
            if (
              opponentVictoryData &&
              aiFindProof(
                opponentVictoryData.ultimate_target,
                verificationResult.expandedSet // 확장된 미래를 기반으로 검증
              )
            ) {
              // 3. 상대방의 승리가 증명된다면, 이 수는 자살 행위이므로 막대한 페널티 부여
              console.warn(
                `[Plato AI] SUICIDE PREVENTION: Using ability on '${propositionToNaturalText(
                  originalProp
                )}' would prove opponent's victory. Massive penalty applied.`
              );
              score -= 999999;
            }
            const myOppositePredicate = myGoalPredicate
              ? currentLang.contradictoryPredicates[myGoalPredicate] ||
                Object.keys(currentLang.contradictoryPredicates).find(
                  (key) =>
                    currentLang.contradictoryPredicates[key] === myGoalPredicate
                )
              : null;

            if (myOppositePredicate) {
              const myDefeatCondition = {
                type: "atomic",
                subject: myVictoryData.core_goal.subject,
                predicate: myOppositePredicate,
              };

              if (
                aiFindProof(myDefeatCondition, verificationResult.expandedSet)
              ) {
                console.warn(
                  `[Plato AI] SUICIDE PREVENTION (Self Defeat): Using ability on '${propositionToNaturalText(
                    originalProp
                  )}' would prove its own defeat condition '${propositionToNaturalText(
                    myDefeatCondition
                  )}'. Massive penalty applied.`
                );
                score -= 900000;
              }
            }
          }

          return { newProp: universalProp, score: score };
        });

        const validCandidates = candidates.filter((c) => c.score > 0);
        if (validCandidates.length === 0) {
          return null;
        }

        validCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = validCandidates[0];

        const MINIMUM_SCORE_THRESHOLD = 150;
        if (bestCandidate.score < MINIMUM_SCORE_THRESHOLD) {
          return null;
        }

        // 능력 사용 실행
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[player].used = true;

        const newTheorem = {
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem",
          source: "plato_ability",
          proposition: bestCandidate.newProp,
        };
        truePropositions.push(newTheorem);

        const finalVerification = verifyAndExpandTruths(
          bestCandidate.newProp,
          internalTruthSet
        );
        if (finalVerification.success) {
          internalTruthSet = finalVerification.expandedSet;
        } else {
          console.error(
            "AI Plato Ability CRITICAL: Contradiction after final check."
          );
          return null;
        }

        return {
          type: "ability",
          description: currentLang.ui.platoAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.newProp)
          ),
        };
      }
      function executeSocratesAbilityCheck(player) {
        // 1. 능력 사용 기본 조건 확인
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (
          abilityUsedState[player].usedCount >= abilityUsedState[player].maxUses
        ) {
          return null;
        }
        const availablePropositions = truePropositions.filter((p) => {
          const isTargetType = p.type === "user-made" || p.type === "theorem";
          if (!isTargetType || !p.propId) return false;

          const isDisabled = socratesDisabledProps.some(
            (disabledProp) => disabledProp.propId === p.propId
          );
          return !isDisabled; // 비활성화되지 않은 것만 true
        });
        if (availablePropositions.length === 0) {
          return null;
        }

        // 2. AI와 상대방의 데이터 가져오기
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData || !opponentVictoryData) return null;

        const internalTruthSet = getTemporaryUsableTruths();

        // 3. 제거할 후보 명제들의 위협 점수 계산

        // 3-1. 경계해야 할 '위험한 전칭 양화문' 목록 생성
        const entities = currentLang.cards
          .filter(
            (c) =>
              c.type === (currentLang.langCode === "ko" ? "개체" : "Entity")
          )
          .map((c) => c.text);
        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        const dangerousUniversals = [];
        entities.forEach((entity) => {
          // 상대 승리에 도움이 되는 전칭 양화문
          dangerousUniversals.push({
            type: "universal",
            entity: entity,
            predicate: opponentWinPredicate,
          });
          // 내 승리에 방해가 되는 전칭 양화문
          if (myOppositePredicate) {
            dangerousUniversals.push({
              type: "universal",
              entity: entity,
              predicate: myOppositePredicate,
            });
          }
        });

        // 3-2. 각 후보 명제별 점수 계산
        const scoredCandidates = availablePropositions.map((propData) => {
          let score = 0;
          const candidateProp = propData.proposition;

          // --- PRIORITY 1: 패배 임박 상황 방어 ---
          const opponentWinsWithCurrentTruths = aiFindProof(
            opponentVictoryData.ultimate_target,
            internalTruthSet
          );
          if (opponentWinsWithCurrentTruths) {
            const tempTruthSetWithoutCandidate = internalTruthSet.filter(
              (p) => !arePropositionsEqual(p, candidateProp)
            );
            const opponentStillWins = aiFindProof(
              opponentVictoryData.ultimate_target,
              tempTruthSetWithoutCandidate
            );
            if (!opponentStillWins) {
              score += 10000;
            }
          }

          // --- PRIORITY 2: 상대 핵심 목표 직접 제거 ---
          const opponentCoreGoal = opponentVictoryData.core_goal;
          if (arePropositionsEqual(candidateProp, opponentCoreGoal)) {
            score += 6000;
          }

          // --- PRIORITY 3: 자기 보존 ---
          const myCoreGoalContradiction = {
            type: "negation",
            proposition: myVictoryData.core_goal,
          };
          if (arePropositionsEqual(candidateProp, myCoreGoalContradiction)) {
            score += 2000;
          }

          // --- PRIORITY 4: 위협적인 전칭 양화문 직접 제거 ---
          if (candidateProp.type === "universal") {
            if (candidateProp.predicate === opponentWinPredicate) {
              score += 3000;
            }
            if (
              myOppositePredicate &&
              candidateProp.predicate === myOppositePredicate
            ) {
              score += 2500;
            }
          }

          const otherTruthsOnBoard = internalTruthSet.filter(
            (p) => !arePropositionsEqual(p, candidateProp)
          );

          for (const otherProp of otherTruthsOnBoard) {
            // 1. 선언적 삼단논법 (사용자 요청 시나리오)
            const dsResult = disjunctiveSyllogism(candidateProp, otherProp);
            if (dsResult) {
              const isDangerous = dangerousUniversals.some((dangerousUniv) =>
                arePropositionsEqual(dsResult, dangerousUniv)
              );
              if (isDangerous) {
                console.log(
                  `%c[Socrates AI] DS threat detected! Keeping '${propositionToNaturalText(
                    candidateProp
                  )}' would allow proving a dangerous universal with another proposition. Threat score +7500.`,
                  "color: #ff4500"
                );
                score += 7500;
              }
            }

            // 2. 전건 긍정
            const mpResult = modusPonens(candidateProp, otherProp);
            if (mpResult) {
              const isDangerous = dangerousUniversals.some((dangerousUniv) =>
                arePropositionsEqual(mpResult, dangerousUniv)
              );
              if (isDangerous) {
                console.log(
                  `%c[Socrates AI] MP threat detected! Keeping '${propositionToNaturalText(
                    candidateProp
                  )}' would allow proving a dangerous universal with another proposition. Threat score +7500.`,
                  "color: #ff4500"
                );
                score += 7500;
              }
            }
            // (다른 다중 전제 추론 규칙도 여기에 추가 가능)
          }

          return {
            propData,
            score,
          };
        });

        // 4. 가장 위협적인 명제 선택 및 능력 실행
        scoredCandidates.sort((a, b) => b.score - a.score);

        if (scoredCandidates.length > 0 && scoredCandidates[0].score > 0) {
          console.log(
            "Socrates AI Top Candidates for Removal:",
            scoredCandidates.slice(0, 3).map((c) => ({
              prop: propositionToNaturalText(c.propData.proposition),
              score: c.score,
            }))
          );
        }

        const bestCandidate = scoredCandidates[0];

        const MINIMUM_THREAT_SCORE = 1500;
        if (!bestCandidate || bestCandidate.score < MINIMUM_THREAT_SCORE) {
          return null;
        }

        abilityUsedState[player].usedCount++;
        socratesDisabledProps.push({
          propId: bestCandidate.propData.propId,
          reEnableRound: currentRound + 2,
        });

        console.log(
          `%cAI Socrates used Awareness of Ignorance on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Threat Score: ${bestCandidate.score})`,
          "color: #8e44ad; font-weight: bold;"
        );

        return {
          type: "ability",
          description: currentLang.ui.socratesAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.propData.proposition)
          ),
        };
      }
      function executeDescartesAbilityCheck(player) {
        // --- 1. 기본 조건 확인 ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) {
          return null;
        }
        const availablePropositions = truePropositions.filter(
          (p) => (p.type === "user-made" || p.type === "theorem") && p.propId
        );
        if (availablePropositions.length === 0) {
          return null;
        }

        // --- 2. 위협 점수 산출 ---
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData || !opponentVictoryData) return null;

        const truthSetForScoring = getTemporaryUsableTruths();

        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        const scoredCandidates = availablePropositions.map((propData) => {
          let score = 0;
          const candidateProp = propData.proposition;

          // 점수 계산 시, 새로 명명한 'truthSetForScoring' 변수를 사용합니다.
          const opponentWinsWithCurrentTruths = aiFindProof(
            opponentVictoryData.ultimate_target,
            truthSetForScoring
          );
          if (opponentWinsWithCurrentTruths) {
            const tempTruthSetWithoutCandidate = truthSetForScoring.filter(
              (p) => !arePropositionsEqual(p, candidateProp)
            );
            const opponentStillWins = aiFindProof(
              opponentVictoryData.ultimate_target,
              tempTruthSetWithoutCandidate
            );
            if (!opponentStillWins) {
              score += 10000;
            }
          }
          if (
            arePropositionsEqual(candidateProp, opponentVictoryData.core_goal)
          ) {
            score += 6000;
          }
          if (
            myOppositePredicate &&
            candidateProp.predicate === myOppositePredicate
          ) {
            score += 2500;
          }
          if (
            candidateProp.type === "universal" &&
            candidateProp.predicate === opponentWinPredicate
          ) {
            score += 3000;
          }
          return { propData, score };
        });

        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate =
          scoredCandidates.length > 0 ? scoredCandidates[0] : null;

        // --- 3. 실행 결정 및 능력 발동 ---
        const MINIMUM_THREAT_SCORE = 1500;
        if (!bestCandidate || bestCandidate.score < MINIMUM_THREAT_SCORE) {
          return null;
        }

        console.log(
          `%cAI Descartes used Methodic Doubt on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Threat Score: ${bestCandidate.score})`,
          "color: #3498db; font-weight: bold;"
        );

        abilityUsedState[player].used = true;

        const propIndex = truePropositions.findIndex(
          (p) => p.propId === bestCandidate.propData.propId
        );
        if (propIndex > -1) {
          truePropositions.splice(propIndex, 1);
        }

        // 진리 집합 재구성 (이 부분은 문제가 없습니다)
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after AI Descartes' ability: Inconsistency found."
            );
          }
        }

        // ★★★ 전역 변수인 'internalTruthSet'에 최종 결과를 할당합니다.
        internalTruthSet = newTruthSet;

        return {
          type: "ability",
          description: currentLang.ui.descartesAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.propData.proposition)
          ),
        };
      }
      function executeHumeAbilityCheck(player) {
        // --- 1. 기본 조건 확인 ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (
          !abilityUsedState[player] ||
          abilityUsedState[player].usedCount >= abilityUsedState[player].maxUses
        ) {
          return null; // 사용 횟수 초과
        }

        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "universal" && p.propId
        );

        if (availablePropositions.length === 0) {
          return null; // 교체할 명제 없음
        }

        // --- 2. 위협 점수 산출을 위한 데이터 준비 ---
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        // --- 3. 각 후보의 '위협 점수' 계산 ---
        const scoredCandidates = availablePropositions.map((propData) => {
          let score = 0;
          const candidateProp = propData.proposition;

          // 상대 승리 조건과 직접적으로 관련될수록 위협적
          if (candidateProp.predicate === opponentWinPredicate) {
            score += 5000;
          }

          // 내 승리 조건에 반대될수록 위협적
          if (
            myOppositePredicate &&
            candidateProp.predicate === myOppositePredicate
          ) {
            score += 4000;
          }

          return { propData, score };
        });

        scoredCandidates.sort((a, b) => b.score - a.score);

        const bestCandidate =
          scoredCandidates.length > 0 ? scoredCandidates[0] : null;

        // --- 4. 실행 결정 및 능력 발동 ---
        const MINIMUM_THREAT_SCORE = 2000; // 기준 점수 설정
        if (!bestCandidate || bestCandidate.score < MINIMUM_THREAT_SCORE) {
          return null; // 사용할 가치가 있는 명제가 없음
        }

        console.log(
          `%cAI Hume used Problem of Induction on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Threat Score: ${bestCandidate.score})`,
          "color: #e67e22; font-weight: bold;"
        );

        const propIndex = truePropositions.findIndex(
          (p) => p.propId === bestCandidate.propData.propId
        );
        if (propIndex === -1) return null;

        const originalProp = truePropositions[propIndex].proposition;
        const newExistentialProp = {
          type: "existential",
          entity: originalProp.entity,
          predicate: originalProp.predicate,
        };

        // 실제 게임 상태 변경
        truePropositions[propIndex].proposition = newExistentialProp;
        truePropositions[propIndex].original_cards = null; // 렌더링을 위해 카드 정보 초기화
        truePropositions[propIndex].type = "theorem";
        truePropositions[propIndex].source = "hume_ability";

        abilityUsedState[player].usedCount++;

        // 진리 집합 재구성
        let newTruthSet = parsedAxioms.map((a) => a.proposition);
        const propositionsToReverify = truePropositions
          .filter((p) => p.proposition)
          .map((p) => p.proposition);

        for (const prop of propositionsToReverify) {
          const verificationResult = verifyAndExpandTruths(prop, newTruthSet);
          if (verificationResult.success) {
            newTruthSet = verificationResult.expandedSet;
          } else {
            console.error(
              "Critical error after AI Hume's ability: Inconsistency found."
            );
          }
        }
        internalTruthSet = newTruthSet;

        // 요약 정보 반환
        return {
          type: "ability",
          description: currentLang.ui.humeAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(originalProp)
          ),
        };
      }
      /**
       * 특정 명제가 AI에게 얼마나 위협적인지 점수로 평가하는 헬퍼 함수
       * @param {object} prop - 평가할 명제 객체
       * @param {string} perspectivePlayer - AI 플레이어 ('A' 또는 'B')
       * @param {object} myVictoryData - AI의 승리 조건 데이터
       * @param {object} opponentVictoryData - 상대의 승리 조건 데이터
       * @returns {number} 위협 점수
       */
      function scoreThreat(
        prop,
        perspectivePlayer,
        myVictoryData,
        opponentVictoryData
      ) {
        if (!prop || !myVictoryData || !opponentVictoryData) return 0;

        let score = 0;
        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const myWinPredicate = myVictoryData.core_goal.predicate;
        const predicatePairs = currentLang.contradictoryPredicates;
        const myOppositePredicate =
          predicatePairs[myWinPredicate] ||
          Object.keys(predicatePairs).find(
            (key) => predicatePairs[key] === myWinPredicate
          );

        // 1. 상대의 승리 조건과 직접적으로 연관되면 높은 점수
        if (prop.predicate === opponentWinPredicate) {
          score += prop.type === "universal" ? 5000 : 1000;
        }
        // 2. 나의 승리 조건과 반대되면 높은 점수
        if (myOppositePredicate && prop.predicate === myOppositePredicate) {
          score += prop.type === "universal" ? 4000 : 800;
        }
        // 3. 상대의 즉시 승리를 유발하는 명제라면 매우 높은 점수
        if (arePropositionsEqual(prop, opponentVictoryData.ultimate_target)) {
          score += 20000;
        }
        // 4. 나의 즉시 패배를 유발하는 명제라면 매우 높은 점수
        const myDefeatCondition = {
          type: "negation",
          proposition: myVictoryData.ultimate_target,
        };
        if (arePropositionsEqual(prop, myDefeatCondition)) {
          score += 18000;
        }

        return score;
      }

      /**
       * AI가 비트겐슈타인의 '사다리 걷어차기' 능력을 사용할지 결정하고 실행하는 함수
       * @param {string} player - 능력을 사용하려는 AI 플레이어 ('A' 또는 'B')
       * @returns {object|null} AI 행동 요약 객체 또는 null
       */
      function executeWittgensteinAbilityCheck(player) {
        // --- 0. 기본 조건 검사 ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) {
          return null; // 이미 능력을 사용했으면 종료
        }

        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        // --- 1단계: 제거할 '핵심 위협' 목록 생성 및 정렬 ---
        const allTruthsOnBoard = getTemporaryUsableTruths();
        const candidatePropositions = truePropositions.filter(
          (p) => (p.type === "user-made" || p.type === "theorem") && p.propId
        );

        if (candidatePropositions.length === 0) {
          return null; // 제거할 후보 명제가 없으면 종료
        }

        const scoredCandidates = candidatePropositions.map((propData) => {
          const threatScore = scoreThreat(
            propData.proposition,
            player,
            myVictoryData,
            opponentVictoryData
          );
          return { propData, score: threatScore };
        });

        // 위협 점수가 높은 순으로 후보들을 정렬
        scoredCandidates.sort((a, b) => b.score - a.score);

        // --- 2단계 & 3단계: 최우선 위협부터 순서대로 제거 방법 탐색 및 평가 ---

        // 모든 추론 규칙 목록
        const allRules = [
          { rule: modusPonens, arity: 2 },
          { rule: modusTollens, arity: 2 },
          { rule: hypotheticalSyllogism, arity: 2 },
          { rule: disjunctiveSyllogism, arity: 2 },
          { rule: universalApplication, arity: 2 },
          { rule: proofByCases, arity: 3 },
        ];

        // 가장 위협적인 후보부터 순회
        for (const candidate of scoredCandidates) {
          const MINIMUM_THREAT_SCORE = 1; // 최소 위협 점수 기준 설정
          if (candidate.score < MINIMUM_THREAT_SCORE) {
            continue; // 점수가 기준보다 낮으면 이 후보는 건너뜀
          }
          const targetPropData = candidate.propData;
          const targetProp = targetPropData.proposition;

          // 이 목표물을 제거할 파트너를 찾기 위해 다른 모든 명제를 순회
          for (const partnerData of truePropositions) {
            if (
              !partnerData.proposition ||
              targetPropData.propId === partnerData.propId
            )
              continue;
            const partnerProp = partnerData.proposition;

            // 모든 추론 규칙을 시도
            for (const { rule, arity } of allRules) {
              let premises = [];
              let newTheorem = null;

              if (arity === 2) {
                // 규칙에 따라 전제 순서가 중요할 수 있으므로 두 가지 경우 모두 시도
                premises = [targetProp, partnerProp];
                newTheorem = rule(premises[0], premises[1]);

                if (!newTheorem) {
                  premises = [partnerProp, targetProp];
                  newTheorem = rule(premises[0], premises[1]);
                }
              }
              // (필요 시 arity 3 이상 규칙에 대한 로직 추가)

              if (!newTheorem) continue; // 이 조합으로는 새로운 정리가 안 나오면 다음 규칙으로

              // --- 3-1. 계획 평가: 안전성 및 효율성 검사 ---
              const premisesToKickData = [targetPropData, partnerData];
              const idsToKick = new Set(
                premisesToKickData.map((p) => p.propId).filter(Boolean)
              );

              // 가상 시나리오: 전제들을 제거하고 새 정리를 추가
              const remainingPropositions = truePropositions.filter(
                (p) => !idsToKick.has(p.propId)
              );
              const hypotheticalTruths = remainingPropositions
                .map((p) => p.proposition)
                .filter(Boolean);

              const verificationResult = verifyAndExpandTruths(
                newTheorem,
                hypotheticalTruths
              );
              if (!verificationResult.success) continue; // 모순 발생 시 기각

              const finalTruthSet = verificationResult.expandedSet;

              // 안전성 검사: 능력 사용 후 내가 지거나 상대가 이기는지 확인
              if (
                aiFindProof(
                  opponentVictoryData.ultimate_target,
                  finalTruthSet
                ) ||
                aiFindProof(
                  {
                    type: "negation",
                    proposition: myVictoryData.ultimate_target,
                  },
                  finalTruthSet
                )
              ) {
                continue; // 치명적 결과가 발생하면 기각
              }

              // 효율성 검사: 제거하려던 위협(targetProp)이 다시 증명되는지 확인
              if (aiFindProof(targetProp, finalTruthSet)) {
                continue; // 사다리가 제거되지 않으면 기각
              }

              // --- 4단계: 모든 검사를 통과한 첫 번째 계획을 즉시 실행 ---
              console.log(
                `%c[AI Wittgenstein] Target Acquired: ${propositionToNaturalText(
                  targetProp
                )} (Threat: ${candidate.score})`,
                "color: #2ecc71; font-weight: bold;"
              );
              console.log(
                `%c[AI Wittgenstein] Justification Found: Using partner '${propositionToNaturalText(
                  partnerProp
                )}' to derive '${propositionToNaturalText(newTheorem)}'`,
                "color: #2ecc71;"
              );

              abilityUsedState[player].used = true;
              truePropositions = remainingPropositions; // 전제들이 제거된 목록으로 교체

              truePropositions.push({
                propId: `prop_${Date.now()}_${Math.random()}`,
                type: "theorem",
                round: currentRound,
                proposition: newTheorem,
                source: "wittgenstein_ability",
              });

              internalTruthSet = finalTruthSet; // 재구성된 진리 집합으로 업데이트

              return {
                type: "ability",
                description:
                  currentLang.ui.wittgensteinAbilityDescription.replace(
                    "{newTheorem}",
                    propositionToNaturalText(newTheorem)
                  ),
              };
            }
          }
        }

        // 모든 위협적인 명제에 대해 유효한 제거 계획을 찾지 못함
        return null;
      }
      function getOppositePredicate(predicate) {
        const predicatePairs = currentLang.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === predicate) return predicatePairs[key];
          if (predicatePairs[key] === predicate) return key;
        }
        return null;
      }

      function simulateKuhnsAbility(propIdToChange) {
        const originalPropData = truePropositions.find(
          (p) => p.propId === propIdToChange
        );
        if (!originalPropData) return null;

        const newPredicate = getOppositePredicate(
          originalPropData.proposition.predicate
        );
        if (!newPredicate) return null;

        const newParadigmProposition = {
          type: "universal",
          entity: originalPropData.proposition.entity,
          predicate: newPredicate,
        };

        const newParadigmPropForList = {
          propId: `sim_${Date.now()}`,
          type: "theorem",
          source: "kuhn_ability",
          proposition: newParadigmProposition,
        };

        const axioms = parsedAxioms.map((a) => a.proposition);
        const victoryConditions = truePropositions
          .filter((p) => p.type === "victory")
          .map((p) => p.proposition);
        const foundationOfTruths = [
          ...axioms,
          ...victoryConditions,
          newParadigmProposition,
        ];

        const preCheckResult = verifyAndExpandTruths(null, foundationOfTruths);
        if (!preCheckResult.success) return null;

        let currentValidatedTruths = preCheckResult.expandedSet;
        let survivingPropositions = [
          ...truePropositions.filter((p) => p.type === "victory"),
          newParadigmPropForList,
        ];

        const candidatesForRevalidation = truePropositions.filter(
          (p) =>
            (p.type === "user-made" || p.type === "theorem") &&
            p.propId !== propIdToChange
        );

        for (const candidate of candidatesForRevalidation) {
          const validationResult = verifyAndExpandTruths(
            candidate.proposition,
            currentValidatedTruths
          );
          if (validationResult.success) {
            currentValidatedTruths = validationResult.expandedSet;
            survivingPropositions.push(candidate);
          }
        }

        return {
          success: true,
          finalTruthSet: currentValidatedTruths,
          finalPropList: survivingPropositions,
        };
      }

      function executeKuhnsAbility(propIdToChange, player) {
        const simResult = simulateKuhnsAbility(propIdToChange);
        if (!simResult || !simResult.success) {
          console.error(
            "AI Kuhn CRITICAL: Simulation passed but execution failed."
          );
          return null;
        }

        truePropositions = simResult.finalPropList;
        internalTruthSet = simResult.finalTruthSet;

        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        abilityUsedState[player].used = true;

        const newParadigmProp = simResult.finalPropList.find(
          (p) => p.source === "kuhn_ability"
        ).proposition;
        return {
          type: "ability",
          description: currentLang.ui.kuhnAbilityDescription.replace(
            "{newParadigm}",
            propositionToNaturalText(newParadigmProp)
          ),
        };
      }

      function executeKuhnAbilityCheck(player) {
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) return null;

        const userMadePropsCount = truePropositions.filter(
          (p) => p.type === "user-made"
        ).length;
        if (userMadePropsCount < 15) return null;

        const availablePropositions = truePropositions.filter(
          (p) => p.proposition && p.proposition.type === "universal" && p.propId
        );
        if (availablePropositions.length === 0) return null;

        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );
        if (!myVictoryData || !opponentVictoryData) return null;

        const myUltimateGoal = myVictoryData.ultimate_target;

        for (const propData of availablePropositions) {
          const simResult = simulateKuhnsAbility(propData.propId);
          if (simResult && simResult.success) {
            if (aiFindProof(myUltimateGoal, simResult.finalTruthSet)) {
              console.log(
                `%c[AI Kuhn] PRIORITY 1 WIN DETECTED! Shifting paradigm on: ${propositionToNaturalText(
                  propData.proposition
                )}`,
                "color: #f1c40f; font-weight: bold;"
              );
              return executeKuhnsAbility(propData.propId, player);
            }
          }
        }

        const scoredCandidates = availablePropositions
          .map((propData) => {
            let score = 0;
            const originalPredicate = propData.proposition.predicate;
            const newPredicate = getOppositePredicate(originalPredicate);
            if (!newPredicate) return { propData, score: -1 };

            const simResult = simulateKuhnsAbility(propData.propId);
            if (!simResult || !simResult.success)
              return { propData, score: -1 };
            if (
              aiFindProof(
                opponentVictoryData.ultimate_target,
                simResult.finalTruthSet
              )
            ) {
              return { propData, score: -1 };
            }

            if (newPredicate === myVictoryData.core_goal.predicate) {
              score = 5000;
            } else {
              const opponentOppositePredicate = getOppositePredicate(
                opponentVictoryData.core_goal.predicate
              );
              if (
                opponentOppositePredicate &&
                newPredicate === opponentOppositePredicate
              ) {
                score = 3000;
              }
            }
            return { propData, score };
          })
          .filter((c) => c.score > 0);

        if (scoredCandidates.length === 0) return null;

        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = scoredCandidates[0];

        console.log(
          `%c[AI Kuhn] Strategic move selected. Shifting paradigm on: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Score: ${bestCandidate.score})`,
          "color: #f1c40f;"
        );
        return executeKuhnsAbility(bestCandidate.propData.propId, player);
      }
      /**
       * AI가 데리다의 '해체' 능력을 사용할지 결정하고 실행하는 함수
       * @param {string} player - 능력을 사용하려는 AI 플레이어 ('A' 또는 'B')
       * @returns {object|null} AI 행동 요약 객체 또는 null
       */
      function executeDerridaAbilityCheck(player) {
        // --- 기본 조건 검사 ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        if (abilityUsedState[player]?.used) {
          return null; // 이미 능력을 사용했으면 종료
        }

        // --- 0. '그리고'를 제외한 연결사로 연결된 명제 찾기 ---
        const availablePropositions = truePropositions.filter(
          (p) =>
            p.propId && // ID가 있어 추적 및 삭제가 가능한 명제만
            p.proposition &&
            (p.proposition.type === "conditional" ||
              p.proposition.type === "disjunction")
        );

        if (availablePropositions.length === 0) {
          return null; // 해체할 후보 명제가 없으면 종료
        }

        // AI와 상대방의 승리 조건 데이터 가져오기
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        let scoredCandidates = [];

        // 모든 후보 명제를 순회하며 평가
        for (const propData of availablePropositions) {
          const originalProp = propData.proposition;
          const { left, right } = originalProp;

          // --- 1. 알아서 분해되는 명제 거르기 (전건 긍정) ---
          if (originalProp.type === "conditional") {
            // (참인 명제) -> A 형태인지 검사
            if (aiFindProof(originalProp.left, internalTruthSet)) {
              continue; // 이미 참인 조건이므로, 일반 추론으로도 분해 가능. 능력 낭비 방지.
            }
          }

          // --- 2. 안전성 검사: 해체 시 상대 이득/모순 발생 여부 확인 ---
          // 원본 명제를 제외한 진리 집합을 시뮬레이션용으로 생성
          const propositionsWithoutOriginal = truePropositions.filter(
            (p) => p.propId !== propData.propId
          );
          let tempTruthSet = parsedAxioms.map((a) => a.proposition);
          propositionsWithoutOriginal.forEach((p) => {
            if (p.proposition) tempTruthSet.push(p.proposition);
          });

          const baseVerification = verifyAndExpandTruths(null, tempTruthSet);
          if (!baseVerification.success) continue; // 기반 집합부터 모순이면 스킵
          let truthSetAfterDeconstruction = baseVerification.expandedSet;

          // 해체된 첫 번째 부분(left)을 추가했을 때 모순 검사
          const verification1 = verifyAndExpandTruths(
            left,
            truthSetAfterDeconstruction
          );
          if (!verification1.success) continue;

          // 이어서 두 번째 부분(right)을 추가했을 때 모순 검사
          const verification2 = verifyAndExpandTruths(
            right,
            verification1.expandedSet
          );
          if (!verification2.success) continue;

          // 최종적으로 확장된 진리 집합
          const finalTruthSet = verification2.expandedSet;

          // 상대가 승리하게 되는지 검사 (치명적 패널티)
          if (aiFindProof(opponentVictoryData.ultimate_target, finalTruthSet)) {
            continue; // 상대 승리를 유발하는 해체는 절대 금지
          }

          // --- 3. 기회 검사: 자신에게 유리한 명제가 나오는지 점수화 ---
          let currentScore = 0;
          const myUltimateGoal = myVictoryData.ultimate_target;
          const myWinPredicate = myVictoryData.core_goal.predicate;

          // 3-1. 필승 검사
          if (aiFindProof(myUltimateGoal, finalTruthSet)) {
            currentScore += 100000; // 해체 즉시 승리하면 압도적인 점수
          } else {
            // 3-2. 유리한 명제(전칭/존재)가 나오는지 검사
            const scoreComponent = (component) => {
              let score = 0;
              // 유리한 전칭 양화문
              if (
                component.type === "universal" &&
                component.predicate === myWinPredicate
              ) {
                score += 5000;
              }
              // 유리한 존재 양화문
              else if (
                component.type === "existential" &&
                component.predicate === myWinPredicate
              ) {
                score += 2000;
              }
              return score;
            };
            currentScore += scoreComponent(left);
            currentScore += scoreComponent(right);
          }

          if (currentScore > 0) {
            scoredCandidates.push({
              propData,
              score: currentScore,
              finalTruthSet,
            });
          }
        }

        if (scoredCandidates.length === 0) return null;

        // --- 4. 최종 선택: 점수가 가장 높고, 최소 기준을 넘는 명제 해체 ---
        scoredCandidates.sort((a, b) => b.score - a.score);
        const bestCandidate = scoredCandidates[0];

        // 최소 점수 기준: 유리한 존재 양화문 보너스(2000)보다 높아야 함
        const MINIMUM_SCORE_THRESHOLD = 2001;
        if (bestCandidate.score < MINIMUM_SCORE_THRESHOLD) {
          return null; // 최소 기준 미달 시 능력 사용 안 함
        }

        // --- 능력 실행 ---
        console.log(
          `%c[AI Derrida] Target Acquired: ${propositionToNaturalText(
            bestCandidate.propData.proposition
          )} (Score: ${bestCandidate.score})`,
          "color: #9b59b6; font-weight: bold;"
        );

        abilityUsedState[player].used = true;

        // 원본 명제 삭제
        truePropositions = truePropositions.filter(
          (p) => p.propId !== bestCandidate.propData.propId
        );

        // 해체된 두 명제 추가
        const { left, right } = bestCandidate.propData.proposition;
        const newProps = [
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: left,
          },
          {
            propId: `prop_${Date.now()}_${Math.random()}`,
            type: "theorem",
            source: "derrida_ability",
            proposition: right,
          },
        ];
        truePropositions.push(...newProps);

        // 최종 진리 집합으로 업데이트
        internalTruthSet = bestCandidate.finalTruthSet;

        // 요약 정보 반환
        return {
          type: "ability",
          description: currentLang.ui.derridaAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.propData.proposition)
          ),
        };
      }
      /**
       * AI가 칸트의 '선험적 종합판단' 능력을 요청된 우선순위에 따라 결정하고 실행하는 함수
       * @param {string} player - 능력을 사용하려는 AI 플레이어 ('A' 또는 'B')
       * @returns {object|null} AI 행동 요약 객체 또는 null (능력을 사용하지 않을 경우)
       */
      function executeKantAbilityCheck(player) {
        // --- 1단계: 기본 조건 검사 및 후보 생성 ---
        const philosopherId =
          player === "A" ? playerA_Data.id : playerB_Data.id;
        const hand = player === "A" ? playerA_Hand : playerB_Hand;
        if (hand.length === 0) return null;

        const candidatePropositions = [];
        function generatePropositionsFromHand(
          currentProposition,
          remainingHand
        ) {
          const parsed = parsePropositionFromCards(
            currentProposition.map((c) => ({ card: c }))
          );
          if (parsed) {
            if (
              !candidatePropositions.some((p) =>
                arePropositionsEqual(p, parsed)
              )
            ) {
              candidatePropositions.push(parsed);
            }
          }
          if (remainingHand.length === 0) return;
          for (let i = 0; i < remainingHand.length; i++) {
            const nextCard = remainingHand[i];
            const connectiveKeywords = [
              currentLang.keywords.if,
              currentLang.keywords.and,
              currentLang.keywords.or,
            ];
            if (connectiveKeywords.includes(nextCard.text)) {
              continue;
            }
            const tempPropositionForValidation = currentProposition.map(
              (c) => ({ card: c })
            );
            if (isValidPlay(nextCard, tempPropositionForValidation)) {
              const nextProposition = [...currentProposition, nextCard];
              const nextRemainingHand = remainingHand.filter(
                (_, index) => index !== i
              );
              generatePropositionsFromHand(nextProposition, nextRemainingHand);
            }
          }
        }
        generatePropositionsFromHand([], hand);

        if (candidatePropositions.length === 0) return null;

        // --- 2단계: 우선순위에 따른 후보 평가 ---
        const evaluatedCandidates = [];
        const opponent = player === "A" ? "B" : "A";
        const myVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === player
        );
        const opponentVictoryData = truePropositions.find(
          (p) => p.type === "victory" && p.owner === opponent
        );

        if (!myVictoryData || !opponentVictoryData) return null;

        const myWinPredicate = myVictoryData.core_goal.predicate;
        const opponentWinPredicate = opponentVictoryData.core_goal.predicate;
        const opponentAntiWinPredicate =
          getOppositePredicate(opponentWinPredicate);

        for (const candidate of candidatePropositions) {
          const verificationResult = verifyAndExpandTruths(
            candidate,
            internalTruthSet
          );
          if (!verificationResult.success) continue;

          const finalTruthSet = verificationResult.expandedSet;
          const myLossCondition = {
            type: "negation",
            proposition: myVictoryData.ultimate_target,
          };

          if (
            aiFindProof(opponentVictoryData.ultimate_target, finalTruthSet) ||
            aiFindProof(myLossCondition, finalTruthSet)
          ) {
            continue;
          }

          if (aiFindProof(myVictoryData.ultimate_target, finalTruthSet)) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 1,
              finalTruthSet,
            });
            continue;
          }
          if (
            candidate.type === "universal" &&
            candidate.predicate === myWinPredicate
          ) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 2,
              finalTruthSet,
            });
            continue;
          }
          if (
            opponentAntiWinPredicate &&
            candidate.type === "universal" &&
            candidate.predicate === opponentAntiWinPredicate
          ) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 3,
              finalTruthSet,
            });
            continue;
          }
          if (
            opponentAntiWinPredicate &&
            candidate.type === "existential" &&
            candidate.predicate === opponentAntiWinPredicate
          ) {
            evaluatedCandidates.push({
              proposition: candidate,
              priority: 4,
              finalTruthSet,
            });
            continue;
          }
        }

        // --- 3단계: 최적 후보 선정 및 능력 실행 ---
        if (evaluatedCandidates.length === 0) return null;

        const bestPriority = Math.min(
          ...evaluatedCandidates.map((c) => c.priority)
        );
        const bestOptions = evaluatedCandidates.filter(
          (c) => c.priority === bestPriority
        );
        const bestCandidate =
          bestOptions[Math.floor(Math.random() * bestOptions.length)];

        console.log(
          `%c[AI Kant] Priority ${
            bestCandidate.priority
          } Action Selected: ${propositionToNaturalText(
            bestCandidate.proposition
          )}`,
          "color: #1abc9c; font-weight: bold;"
        );

        abilityUsedState[player].used = true;

        const cardsToCreate = propositionToNaturalText(
          bestCandidate.proposition
        ).split(" ");
        let tempHand = [...hand];
        cardsToCreate.forEach((cardText) => {
          const cardIndex = tempHand.findIndex((c) => c.text === cardText);
          if (cardIndex > -1) tempHand.splice(cardIndex, 1);
        });
        if (player === "A") playerA_Hand = tempHand;
        else playerB_Hand = tempHand;

        truePropositions.push({
          propId: `prop_${Date.now()}_${Math.random()}`,
          type: "theorem",
          source: "kant_ability",
          proposition: bestCandidate.proposition,
        });

        internalTruthSet = bestCandidate.finalTruthSet;

        return {
          type: "ability",
          description: currentLang.ui.kantAbilityDescription.replace(
            "{proposition}",
            propositionToNaturalText(bestCandidate.proposition)
          ),
        };
      }

      // 헬퍼 함수 (다른 AI 로직에서도 필요할 수 있으므로 전역에 정의)
      function getOppositePredicate(predicate) {
        const predicatePairs = currentLang.contradictoryPredicates;
        for (const key in predicatePairs) {
          if (key === predicate) return predicatePairs[key];
          if (predicatePairs[key] === predicate) return key;
        }
        return null;
      }
      function saveSettings() {
        const settings = {
          bgmVolume: bgmVolume,
          sfxVolume: sfxVolume,
        };
        localStorage.setItem("logos_settings", JSON.stringify(settings));
      }

      function loadSettings() {
        const savedSettings = localStorage.getItem("logos_settings");
        if (savedSettings) {
          const settings = JSON.parse(savedSettings);
          bgmVolume =
            settings.bgmVolume !== undefined ? settings.bgmVolume : 0.4;
          sfxVolume =
            settings.sfxVolume !== undefined ? settings.sfxVolume : 0.6;
        }

        // 로드된 값으로 오디오 및 UI 업데이트
        audioManager.setVolume(bgmVolume);
        audioManager.setSfxVolume(sfxVolume);

        const bgmSlider = document.getElementById("bgm-volume-slider");
        const bgmValueSpan = document.getElementById("bgm-volume-value");
        const sfxSlider = document.getElementById("sfx-volume-slider");
        const sfxValueSpan = document.getElementById("sfx-volume-value");

        if (bgmSlider) {
          bgmSlider.value = bgmVolume;
          bgmValueSpan.textContent = `${Math.round(bgmVolume * 100)}%`;
        }
        if (sfxSlider) {
          sfxSlider.value = sfxVolume;
          sfxValueSpan.textContent = `${Math.round(sfxVolume * 100)}%`;
        }
      }
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const closeSettingsBtn = document.getElementById(
        "close-settings-modal-btn"
      );

      if (settingsBtn) {
        settingsBtn.addEventListener("click", () => {
          if (settingsModal) settingsModal.classList.add("visible");
        });
      }
      if (closeSettingsBtn) {
        closeSettingsBtn.addEventListener("click", () => {
          if (settingsModal) settingsModal.classList.remove("visible");
        });
      }

      const creditsBtn = document.getElementById("credits-btn");
      const creditsModal = document.getElementById("credits-modal");
      const closeCreditsBtn = document.getElementById(
        "close-credits-modal-btn"
      );

      if (creditsBtn) {
        creditsBtn.addEventListener("click", () => {
          if (creditsModal) creditsModal.classList.add("visible");
        });
      }
      if (closeCreditsBtn) {
        closeCreditsBtn.addEventListener("click", () => {
          if (creditsModal) creditsModal.classList.remove("visible");
        });
      }

      // --- 볼륨 슬라이더 이벤트 리스너 ---
      const bgmSlider = document.getElementById("bgm-volume-slider");
      const bgmValueSpan = document.getElementById("bgm-volume-value");
      const sfxSlider = document.getElementById("sfx-volume-slider");
      const sfxValueSpan = document.getElementById("sfx-volume-value");

      if (bgmSlider) {
        bgmSlider.addEventListener("input", (e) => {
          bgmVolume = parseFloat(e.target.value);
          audioManager.setVolume(bgmVolume);
          bgmValueSpan.textContent = `${Math.round(bgmVolume * 100)}%`;
          saveSettings();
        });
      }

      if (sfxSlider) {
        sfxSlider.addEventListener("input", (e) => {
          sfxVolume = parseFloat(e.target.value);
          audioManager.setSfxVolume(sfxVolume); // 새로운 함수 호출
          sfxValueSpan.textContent = `${Math.round(sfxVolume * 100)}%`;
        });

        sfxSlider.addEventListener("change", () => {
          audioManager.playSfx("hover"); // 새로운 함수 호출
          saveSettings();
        });
      }
      // 튜토리얼 '다음' 버튼 Enter 키 지원
      window.addEventListener("keydown", (event) => {
        // 튜토리얼 모드가 아니거나, 게임오버 상태이면 아무것도 하지 않음
        if (!inTutorialMode || gameIsOver) return;

        const nextBtn = document.getElementById("tutorial-next-btn");

        // Enter 키를 눌렀고, '다음' 버튼이 화면에 보일 때 (hidden 클래스가 없을 때) 동작
        if (event.key === "Enter" && !nextBtn.classList.contains("hidden")) {
          // Enter 키의 기본 동작(예: 폼 제출)을 막아 다른 기능과의 충돌을 방지
          event.preventDefault();

          // '다음' 버튼에 클릭 이벤트를 발생시킴
          nextBtn.click();
        }
      });
    </script>
  </body>
</html>
