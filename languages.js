const TEXTS = {
  ko: {
    langCode: "ko",
    ui: {
      title: "LOGOS ORGANON",
      tutorialButton: "튜토리얼",
      tutorialPuzzleButton: "튜토리얼 퍼즐",
      exitGameButton: "게임 종료",
      creditsButton: "크레딧",
      endTutorialButton: "튜토리얼 종료",
      newGameButton: "새 게임",
      vsAIButton: "1인 대전",
      vsPlayerButton: "2인 대전",
      puzzleButton: "퍼즐",
      fullscreenButton: "전체화면",
      settingsButton: "환경설정",
      settingsTitle: "환경설정",
      bgmLabel: "배경음악",
      sfxLabel: "효과음",
      playerAName: "소크라테스",
      playerAColor: "⚪️ 백",
      playerBName: "플라톤",
      playerBColor: "⚫️ 흑",
      currentPropositionTitle: "현재 명제",
      completeButton: "명제 완성",
      undoButton: "되돌리기",
      endTurnButton: "턴 종료",
      truePropositionsTitle: "참 명제 목록",
      eurekaButton: "유레카!",
      addTheoremButton: "정리 추가 ➕",
      roundDisplay: "제 {round} 라운드",
      axiomTitle: "기본 공리 (펼쳐보기)",
      statusTurn: "의 턴입니다.",
      statusAITurn: "AI가 생각 중입니다...",
      thinkingTimeStatus: "사유 시간입니다. 새로운 정리를 도출하세요.",
      thinkingTimeTitle: "사유(思惟) 시간",
      thinkingTimeDesc:
        "새로운 정리를 도출하고 '정리 추가' 버튼으로 목록에 반영하세요.",
      endThinkingTimeButton: "사유 시간 종료 & 다음 라운드 시작",
      victoryMessage: "플레이어의 승리!",
      victorySubMessage: "논리적인 증명에 성공했습니다!",
      okButton: "확인",
      cancelButton: "취소",
      nextButton: "다음",
      yesButton: "예",
      noButton: "아니오",
      cancelAssumptionButton: "가정 취소",
      confirmSelectionButton: "확인",
      pressAnyKeyText: "아무 키나 마우스를 누르세요",
      selectP1Philosopher: "1P, 철학자를 선택하세요",
      selectP2Philosopher: "2P, 철학자를 선택하세요",
      selectYourPhilosopher: "당신의 철학자를 선택하세요",
      selectAIPhilosopher: "AI의 철학자를 선택하세요",
      gameStartingSoon: "곧 게임이 시작됩니다...",
      turnOrderTitle: "대전 순서를 선택하세요",
      selectFirstPlayer: "선공",
      selectSecondPlayer: "후공",
      skillTitle: "고유 능력",
      thinkingTimeTurnMessage: "의 사유 시간입니다.",
      useAbilityButton: "능력 사용",
      platoAbilityTitle: "이데아 회상",
      platoConfirmButton: "이 명제를 보편화하기",
      socratesAbilityTitle: "무지의 자각",
      socratesConfirmButton: "이 명제를 다음 라운드까지 제외",
      wittgensteinAbilityTitle: "사다리 걷어차기",
      wittgensteinConfirmButton: "정리 도출 및 전제 삭제",
      vsAIBattleButton: "AI 대전", // AI 대전 버튼
      selectAIP1Philosopher: "AI 1P, 철학자를 선택하세요", // AI 1P 선택 안내
      selectAIP2Philosopher: "AI 2P, 철학자를 선택하세요", // AI 2P 선택 안내
      aiSummaryTitleDefault: "AI의 턴 결과",
      aiSummaryTitleTheorem: "AI가 새로운 정리를 도출했습니다.",
      aiSummaryTitleAbility: "AI가 능력을 사용했습니다.",
      abilityLabel: "[능력]",
      theoremLabel: "[정리]",
      platoAbilityDescription:
        "[이데아 회상] 능력으로 '{proposition}' 명제를 도출했습니다.",
      socratesAbilityDescription:
        "[무지의 자각] 능력으로 '{proposition}' 명제를 다음 라운드까지 논증에서 제외합니다.",
      descartesAbilityDescription:
        "[방법적 회의] 능력으로 '{proposition}' 명제를 참 목록에서 삭제했습니다.",
      humeAbilityDescription:
        "[귀납의 문제] 능력으로 '{proposition}' 명제를 약화시켰습니다.",
      wittgensteinAbilityDescription:
        "[사다리 걷어차기] 능력으로 '{newTheorem}' 정리를 도출하고, 사용된 전제들을 삭제했습니다.",
      kuhnAbilityDescription:
        "[패러다임 전환] 능력으로 새로운 패러다임인 '{newParadigm}'를 수립했습니다.",
      derridaAbilityDescription:
        "[해체] 능력으로 '{proposition}' 명제를 해체했습니다.",
      kantAbilityDescription:
        "[선험적 종합판단] 능력으로 '{proposition}' 명제를 도출했습니다.",
      vsPlayerDesc: "두 플레이어가 한 컴퓨터 앞에 앉아<br>대결합니다.",
      vsAIDesc: "AI를 상대하며 게임을 연습할 수 있습니다.",
      tutorialDesc:
        "게임의 기본 규칙과 논리적 추론 규칙을<br>배울 수 있습니다.",
      puzzleDesc:
        "경쟁 없이, 미리 준비된 논리 추론 퍼즐을<br>풀어볼 수 있습니다.",
      proofReviewButton: "논증 다시보기",
    },
    modals: {
      characterSelectTitle: "철학자 선택",
      selectSocrates: "소크라테스 (백) ⚪️",
      selectPlato: "플라톤 (흑) ⚫️",
      eurekaTitleVictory: "유레카! 논증 구성",
      eurekaTitleTheorem: "사유 시간: 정리 구성",
      premiseSelectionTitle: "사용 가능한 전제 목록",
      applyRuleButton: "규칙 적용",
      addAssumptionButton: "가정하기",
      confirmVictoryButton: "이 논증으로 승리 증명!",
      confirmTheoremButton: "선택한 정리들을 참 목록에 추가 ➕",
      tutorialTitle: "LOGOS ORGANON 튜토리얼",
      promptInputPlaceholder: "명제를 입력하세요...",
      puzzleTitle: "레벨 선택",
      proofReviewTitle: "승리 논증 다시보기",
    },

    inferenceRules: {
      basic: "기본 규칙",
      modusPonens: "전건 긍정 (P, P 라면 Q ∴ Q)",
      modusTollens: "후건 부정 (Q 는 거짓이다, P 라면 Q ∴ P 는 거짓이다)",
      hypotheticalSyllogism: "가설적 삼단논법 (P 라면 Q, Q 라면 R ∴ P 라면 R)",
      disjunctiveSyllogism: "선언적 삼단논법 (P 또는 Q, P 는 거짓이다 ∴ Q)",
      universalApplication: "보편 적용 (A는 P다, 모든 P는 Q다 ∴ A는 Q다)",
      existentialInstantiation: "존재화 (모든 P는 Q다 ∴ 어떤 P는 Q다)",
      conjunctionElimination: "단순화 (P 그리고 Q ∴ P, Q)",
      doubleNegationElimination:
        "이중 부정 제거 (P 는 거짓이다 는 거짓이다 ∴ P)",
      assumptionBased: "가정 기반 규칙",
      conditionalIntroduction: "조건문 도입 (P 가정, Q 도출 ∴ P 라면 Q)",
      reductioAdAbsurdum: "귀류법 (P 가정, 모순 도출 ∴ P 는 거짓이다)",
      advanced: "고급 규칙",
      proofByCases: "경우 논증 (P 또는 Q, P 라면 R, Q 라면 R ∴ R)",
    },

    alerts: {
      invalidCard: "규칙에 맞지 않는 카드입니다!",
      incompleteProposition: "완성되지 않은 명제이거나 파싱에 실패했습니다.",
      duplicateProposition: "같은 명제가 이미 존재합니다.",
      assumptionDependentNotAllowed: "가정 의존 명제는 추가할 수 없습니다.",
      contradictionFound:
        "모순이 발견되었습니다!<br>이 명제는 기존의 참 명제들과 양립할 수 없습니다.",
      undoLastCard: "마지막으로 놓은 카드를 되돌렸습니다.",
      undoLastProposition: "마지막으로 완성된 명제를 되돌렸습니다.",
      nothingToUndo: "되돌릴 수 있는 완성된 명제가 없습니다.",
      roundEndNoMoves:
        "'{player}' 플레이어가 더 이상 낼 수 있는 카드가 없어 사유 시간으로 전환합니다.",
      criticalErrorUndo:
        "진리 체계를 재구성하는 중 심각한 오류가 발생했습니다. 게임을 새로 시작해야 할 수 있습니다.",
      oneAssumptionOnly: "가정은 한 번에 하나만 할 수 있습니다.",
      parsingFailed: "명제를 파싱할 수 없습니다. 올바른 형식으로 입력해주세요.",
      premiseNeededForIntro:
        "조건문 도입 규칙은 가정으로부터 도출된 '결론' 명제 하나만 선택해야 합니다.",
      assumptionNeededForIntro:
        "조건문 도입 규칙을 사용하려면 먼저 '가정하기'를 통해 가정을 해야 합니다.",
      premiseNotFromAssumption:
        "선택한 명제는 현재 가정과 무관합니다. 가정으로부터 파생된 명제를 선택하세요.",
      premiseCountError: "이 규칙은 {count}개의 전제가 필요합니다.",
      contradictionNeededForRAA:
        "귀류법은 서로 모순되는 2개의 전제가 필요합니다.",
      assumptionNeededForRAA:
        "귀류법을 적용하려면 먼저 '가정하기'를 통해 가정을 해야 합니다.",
      notAContradiction: "모순 관계가 아닙니다. 귀류법을 적용할 수 없습니다.",
      ruleFailed: "규칙 적용에 실패했습니다. 전제들을 확인해주세요.",
      noTheoremsToAdd: "추가할 새로운 정리가 없습니다.",
      proofIncomplete:
        "증명이 완료되지 않았습니다.\n자신의 승리 [{myGoal}] 또는\n상대의 패배 [{opponentGoal}] 를 도출해야 합니다.",
      oneCardPerTurn: "한 턴에 한 장의 카드만 낼 수 있습니다.",
      aiEurekaDeclared: "AI가 '유레카!'를 선언했습니다!",
      selectOneTheoremOnly: "하나의 최종 정리만 선택해야 합니다.",
      wittgensteinSuccess:
        "새로운 정리가 추가되었고, 증명에 사용된 전제들이 삭제되었습니다.",
      kantSuccess: "새로운 명제가 참 목록에 추가되었습니다!",
      confirmCloseEureka:
        "유레카! 선언은 한 라운드에 한 번만 할 수 있습니다.<br>정말 창을 닫으시겠습니까?",
      confirmExit: "정말로 종료하시겠습니까?",
      tutorialVictory:
        "잘 하셨습니다.<br>이제 논리 대결에 참여하여 당신의 지혜를 증명해 보세요!",
      puzzleCleared: "축하합니다! 클리어하셨습니다!",
      confirmDeclareEureka:
        "유레카! 선언은 한 라운드에 한 번만 가능합니다.<br>선언하시겠습니까?",
    },
    keywords: {
      if: "라면",
      and: "그리고",
      or: "또는",
      not: "는 거짓이다",
      wins: "승리한다",
      socrates: "소크라테스는",
      plato: "플라톤은",
      universal_q: "모든",
      existential_q: "어떤",
    },
    cards: [
      { type: "양화사", text: "어떤" },
      { type: "양화사", text: "모든" },
      { type: "연산자", text: "라면" },
      { type: "연산자", text: "그리고" },
      { type: "연산자", text: "또는" },
      { type: "연산자", text: "는 거짓이다" },
      { type: "개체", text: "새는" },
      { type: "개체", text: "물고기는" },
      { type: "개체", text: "개는" },
      { type: "고유명사", text: "소크라테스는" },
      { type: "고유명사", text: "플라톤은" },
      { type: "서술어", text: "선하다" },
      { type: "서술어", text: "악하다" },
      { type: "서술어", text: "지혜롭다" },
      { type: "서술어", text: "어리석다" },
      { type: "서술어", text: "새이다" },
      { type: "서술어", text: "물고기이다" },
      { type: "서술어", text: "개이다" },
      { type: "서술어", text: "승리한다" },
    ],
    cardTypes: ["고유명사", "양화사", "개체", "서술어", "연산자"],
    axiom_templates: {
      identity: [
        "어떤 새는 새이다",
        "모든 새는 새이다",
        "어떤 물고기는 물고기이다",
        "모든 물고기는 물고기이다",
        "어떤 개는 개이다",
        "모든 개는 개이다",
      ],
      subject_good_evil: [
        "{S} 선하다 또는 {S} 악하다",
        "{S} 선하다 라면 {S} 악하다 는 거짓이다",
      ],
      subject_wise_foolish: [
        "{S} 지혜롭다 또는 {S} 어리석다",
        "{S} 지혜롭다 라면 {S} 어리석다 는 거짓이다",
      ],
      bird_good_evil_forward: [
        "모든 새는 선하다 라면 어떤 새는 악하다 는 거짓이다",
        "모든 새는 악하다 라면 어떤 새는 선하다 는 거짓이다",
        "모든 새는 지혜롭다 라면 어떤 새는 어리석다 는 거짓이다",
        "모든 새는 어리석다 라면 어떤 새는 지혜롭다 는 거짓이다",
      ],
      bird_good_evil_reverse: [
        "어떤 새는 선하다 는 거짓이다 라면 모든 새는 악하다",
        "어떤 새는 악하다 는 거짓이다 라면 모든 새는 선하다",
        "어떤 새는 지혜롭다 는 거짓이다 라면 모든 새는 어리석다",
        "어떤 새는 어리석다 는 거짓이다 라면 모든 새는 지혜롭다",
      ],
      fish_good_evil_forward: [
        "모든 물고기는 선하다 라면 어떤 물고기는 악하다 는 거짓이다",
        "모든 물고기는 악하다 라면 어떤 물고기는 선하다 는 거짓이다",
        "모든 물고기는 지혜롭다 라면 어떤 물고기는 어리석다 는 거짓이다",
        "모든 물고기는 어리석다 라면 어떤 물고기는 지혜롭다 는 거짓이다",
      ],
      fish_good_evil_reverse: [
        "어떤 물고기는 선하다 는 거짓이다 라면 모든 물고기는 악하다",
        "어떤 물고기는 악하다 는 거짓이다 라면 모든 물고기는 선하다",
        "어떤 물고기는 지혜롭다 는 거짓이다 라면 모든 물고기는 어리석다",
        "어떤 물고기는 어리석다 는 거짓이다 라면 모든 물고기는 지혜롭다",
      ],
      dog_good_evil_forward: [
        "모든 개는 선하다 라면 어떤 개는 악하다 는 거짓이다",
        "모든 개는 악하다 라면 어떤 개는 선하다 는 거짓이다",
        "모든 개는 지혜롭다 라면 어떤 개는 어리석다 는 거짓이다",
        "모든 개는 어리석다 라면 어떤 개는 지혜롭다 는 거짓이다",
      ],
      dog_good_evil_reverse: [
        "어떤 개는 선하다 는 거짓이다 라면 모든 개는 악하다",
        "어떤 개는 악하다 는 거짓이다 라면 모든 개는 선하다",
        "어떤 개는 지혜롭다 는 거짓이다 라면 모든 개는 어리석다",
        "어떤 개는 어리석다 는 거짓이다 라면 모든 개는 지혜롭다",
      ],
    },
    victoryPredicates: ["선하다", "악하다", "지혜롭다", "어리석다"],
    contradictoryPredicates: { 선하다: "악하다", 지혜롭다: "어리석다" },
    labels: {
      victory: "[승리]",
      proposition: "[명제]",
      axiom: "[공리]",
      victory_condition: "[승리 조건]",
      theorem: "[정리]",
      assumption: "[가정]",
      ci_theorem: "[조건문 도입]",
      raa_theorem: "[귀류법 증명]",
      theorem_source: "[정리] {text} (R{round} 사유)",
      victory_text: "{owner} 승리 조건: <strong>{text}</strong>",
      plato_ability_source: "{text} (이데아 회상)",
      nietzsche_ability_source: "{text} (영원 회귀)",
      wittgenstein_ability_source: "{text} (사다리 걷어차기)",
      derrida_ability_source: "{text} (해체)",
      hume_ability_source: "{text} (귀납의 문제)",
      kuhn_ability_source: "{text} (패러다임 전환)",
      kant_ability_source: "{text} (선험적 종합판단)",
    },
  },
  en: {
    langCode: "en",
    ui: {
      title: "LOGOS ORGANON",
      tutorialButton: "Tutorial",
      tutorialPuzzleButton: "Tutorial Puzzle",
      puzzleButton: "Puzzle",
      exitGameButton: "Exit Game",
      creditsButton: "Credits",
      endTutorialButton: "End Tutorial",
      newGameButton: "New Game",
      fullscreenButton: "Fullscreen",
      settingsButton: "Settings",
      settingsTitle: "Settings",
      bgmLabel: "BGM",
      sfxLabel: "SFX",
      vsAIButton: "1P vs AI",
      vsPlayerButton: "1P vs 2P",
      playerAName: "Socrates",
      playerAColor: "⚪️ White",
      playerBName: "Plato",
      playerBColor: "⚫️ Black",
      currentPropositionTitle: "Current Proposition",
      completeButton: "Complete",
      undoButton: "Undo",
      endTurnButton: "End Turn",
      truePropositionsTitle: "True Propositions",
      eurekaButton: "Eureka!",
      addTheoremButton: "Add Theorem ➕",
      roundDisplay: "Round {round}",
      axiomTitle: "Basic Axioms (Click to expand)",
      statusTurn: "'s Turn",
      statusAITurn: "AI is thinking...",
      thinkingTimeStatus: "Thinking Time. Derive new theorems.",
      thinkingTimeTitle: "Thinking Time",
      thinkingTimeDesc:
        "Derive new theorems and add them to the list using the 'Add Theorem' button.",
      endThinkingTimeButton: "End Thinking Time & Start Next Round",
      victoryMessage: "Player Wins!",
      victorySubMessage: "Succeeded with a logical proof!",
      okButton: "OK",
      cancelButton: "Cancel",
      nextButton: "Next",
      yesButton: "Yes",
      noButton: "No",
      cancelAssumptionButton: "Cancel",
      confirmSelectionButton: "Confirm",
      pressAnyKeyText: "Press any key or click to start",
      selectP1Philosopher: "1P, Select Your Philosopher",
      selectP2Philosopher: "2P, Select Your Philosopher",
      selectYourPhilosopher: "Select Your Philosopher",
      selectAIPhilosopher: "Select AI's Philosopher",
      gameStartingSoon: "Game starting soon...",
      turnOrderTitle: "Choose Turn Order",
      selectFirstPlayer: "Go First",
      selectSecondPlayer: "Go Second",
      skillTitle: "Unique Ability",
      thinkingTimeTurnMessage: "'s Thinking Time.",
      useAbilityButton: "Use Ability",
      platoAbilityTitle: "Recollection of Forms",
      platoConfirmButton: "Universalize this Proposition",
      socratesAbilityTitle: "Awareness of Ignorance",
      socratesConfirmButton: "Exclude this proposition from arguments",
      wittgensteinAbilityTitle: "Kicking Away the Ladder",
      wittgensteinConfirmButton: "Derive Theorem & Delete Premises",
      vsAIBattleButton: "AI vs AI",
      selectAIP1Philosopher: "Select AI 1P's Philosopher",
      selectAIP2Philosopher: "Select AI 2P's Philosopher",
      aiSummaryTitleDefault: "AI's Turn Result",
      aiSummaryTitleTheorem: "AI has derived a new theorem.",
      aiSummaryTitleAbility: "AI has used an ability.",
      abilityLabel: "[Ability]",
      theoremLabel: "[Theorem]",
      platoAbilityDescription:
        "[Recollection of Forms] ability was used to derive '{proposition}'.",
      socratesAbilityDescription:
        "[Awareness of Ignorance] ability was used to exclude '{proposition}' from arguments for the next round.",
      descartesAbilityDescription:
        "[Methodic Doubt] ability was used to delete '{proposition}' from the list of true propositions.",
      humeAbilityDescription:
        "[Problem of Induction] ability was used to weaken '{proposition}'.",
      wittgensteinAbilityDescription:
        "[Kicking Away the Ladder] ability was used to derive the theorem '{newTheorem}' and delete its premises.",
      kuhnAbilityDescription:
        "[Paradigm Shift] ability was used to establish a new paradigm: '{newParadigm}'.",
      derridaAbilityDescription:
        "[Deconstruction] ability was used to deconstruct the proposition '{proposition}'.",
      kantAbilityDescription:
        "[Synthetic A Priori Judgment] ability was used to derive '{proposition}'.",
      vsPlayerDesc: "Two players face off on a single computer.",
      vsAIDesc: "Practice the game by playing against the AI.",
      tutorialDesc:
        "Learn the basic rules of the game and the rules of inference.",
      puzzleDesc:
        "Solve pre-made logical reasoning puzzles without competition.",
      proofReviewButton: "Review Proof",
    },
    modals: {
      characterSelectTitle: "Select Your Philosopher",
      selectSocrates: "Socrates (White) ⚪️",
      selectPlato: "Plato (Black) ⚫️",
      eurekaTitleVictory: "Eureka! Construct Proof",
      eurekaTitleTheorem: "Thinking Time: Construct Theorem",
      premiseSelectionTitle: "Available Premises List",
      applyRuleButton: "Apply",
      addAssumptionButton: "Assume",
      confirmVictoryButton: "Prove Victory with this Argument!",
      confirmTheoremButton: "Add Selected Theorems to True List ➕",
      tutorialTitle: "LOGOS ORGANON Tutorial",
      promptInputPlaceholder: "Enter proposition...",
      puzzleTitle: "Select Level",
      proofReviewTitle: "Victory Proof Review",
    },

    inferenceRules: {
      basic: "Basic Rules",
      modusPonens: "Modus Ponens (P, P then Q ∴ Q)",
      modusTollens: "Modus Tollens (Q is false, P then Q ∴ ~P)",
      hypotheticalSyllogism:
        "Hypothetical Syllogism (P then Q, Q then R ∴ P then R)",
      disjunctiveSyllogism: "Disjunctive Syllogism (P or Q, P is false ∴ Q)",
      universalApplication:
        "Universal Application (A is P, Every P are Q ∴ A is Q)",
      existentialInstantiation:
        "Existential Instantiation (Every P is Q ∴ Some P is Q)",
      conjunctionElimination: "Simplification (P and Q ∴ P, Q)",
      doubleNegationElimination:
        "Double Negation Elimination (P is false is false ∴ P)",
      assumptionBased: "Assumption-Based Rules",
      conditionalIntroduction:
        "Conditional Introduction (Assume P, derive Q ∴ P then Q)",
      reductioAdAbsurdum:
        "Reductio ad Absurdum (Assume P, derive contradiction ∴ P is false)",
      advanced: "Advanced Rules",
      proofByCases: "Proof by Cases (P or Q, P then R, Q then R ∴ R)",
    },
    alerts: {
      invalidCard: "This card cannot be played here.",
      incompleteProposition:
        "The proposition is incomplete or could not be parsed.",
      duplicateProposition: "The same proposition already exists.",
      assumptionDependentNotAllowed: "Assumption-dependent propositions cannot be added.",
      contradictionFound:
        "Contradiction found!<br>This proposition is not compatible with the set of true propositions.",
      undoLastCard: "Reverted the last played card.",
      undoLastProposition: "Reverted the last completed proposition.",
      nothingToUndo: "There are no completed propositions to undo.",
      roundEndNoMoves:
        "Player '{player}' has no valid moves. Entering thinking time.",
      criticalErrorUndo:
        "A critical error occurred while rebuilding the truth set. You may need to restart the game.",
      oneAssumptionOnly: "You can only have one assumption at a time.",
      parsingFailed:
        "Could not parse the proposition. Please check the format.",
      premiseNeededForIntro:
        "For Conditional Introduction, you must select exactly one conclusion derived from the assumption.",
      assumptionNeededForIntro:
        "You must make an assumption first to use Conditional Introduction.",
      premiseNotFromAssumption:
        "The selected proposition does not depend on the current assumption.",
      premiseCountError: "This rule requires {count} premises.",
      contradictionNeededForRAA:
        "Reductio ad Absurdum requires 2 contradictory premises.",
      assumptionNeededForRAA:
        "You must make an assumption first to use Reductio ad Absurdum.",
      notAContradiction: "The selected premises are not a contradiction.",
      ruleFailed: "Failed to apply the rule. Please check your premises.",
      noTheoremsToAdd: "There are no new, non-dependent theorems to add.",
      proofIncomplete:
        "Proof incomplete.\nYou must derive your victory [{myGoal}] or your opponent's defeat [{opponentGoal}].",
      oneCardPerTurn: "You can only play one card per turn.",
      aiEurekaDeclared: "AI has declared 'Eureka!'",
      selectOneTheoremOnly: "You must select exactly one final theorem.",
      wittgensteinSuccess:
        "The new theorem has been added, and the premises used for its proof have been deleted.",
      kantSuccess: "A new proposition has been added to the true list!",
      confirmCloseEureka:
        "Eureka! can only be declared once per round.<br>Are you sure you want to close this window?",
      confirmExit: "Are you sure you want to exit?",
      tutorialVictory:
        "Well done!<br>Now, engage in a battle of wits and prove your wisdom!",
      puzzleCleared: "Congratulations! You cleared the puzzle!",
      confirmDeclareEureka:
        "Eureka! can only be declared once per round.<br>Do you want to proceed?",
    },
    keywords: {
      if: "then",
      and: "and",
      or: "or",
      not: "is false",
      wins: "wins",
      socrates: "Socrates",
      plato: "Plato",
      universal_q: "Every",
      existential_q: "Some",
    },
    cards: [
      { type: "Quantifier", text: "Some" },
      { type: "Quantifier", text: "Every" },
      { type: "Operator", text: "then" },
      { type: "Operator", text: "and" },
      { type: "Operator", text: "or" },
      { type: "Operator", text: "is false" },
      { type: "Entity", text: "bird" },
      { type: "Entity", text: "fish" },
      { type: "Entity", text: "dog" },
      { type: "Proper Noun", text: "Socrates" },
      { type: "Proper Noun", text: "Plato" },
      { type: "Predicate", text: "is good" },
      { type: "Predicate", text: "is evil" },
      { type: "Predicate", text: "is wise" },
      { type: "Predicate", text: "is foolish" },
      { type: "Predicate", text: "is a bird" },
      { type: "Predicate", text: "is a fish" },
      { type: "Predicate", text: "is a dog" },
      { type: "Predicate", text: "wins" },
    ],
    cardTypes: ["Proper Noun", "Quantifier", "Entity", "Predicate", "Operator"],
    axiom_templates: {
      identity: [
        "Some bird is a bird",
        "Every bird is a bird",
        "Some fish is a fish",
        "Every fish is a fish",
        "Some dog is a dog",
        "Every dog is a dog",
      ],
      subject_good_evil: [
        "{S} is good or {S} is evil",
        "{S} is good then {S} is evil is false",
      ],
      subject_wise_foolish: [
        "{S} is wise or {S} is foolish",
        "{S} is wise then {S} is foolish is false",
      ],
      bird_good_evil_forward: [
        "Every bird is good then Some bird is evil is false",
        "Every bird is evil then Some bird is good is false",
        "Every bird is wise then Some bird is foolish is false",
        "Every bird is foolish then Some bird is wise is false",
      ],
      bird_good_evil_reverse: [
        "Some bird is good is false then Every bird is evil",
        "Some bird is evil is false then Every bird is good",
        "Some bird is wise is false then Every bird is foolish",
        "Some bird is foolish is false then Every bird is wise",
      ],
      fish_good_evil_forward: [
        "Every fish is good then Some fish is evil is false",
        "Every fish is evil then Some fish is good is false",
        "Every fish is wise then Some fish is foolish is false",
        "Every fish is foolish then Some fish is wise is false",
      ],
      fish_good_evil_reverse: [
        "Some fish is good is false then Every fish is evil",
        "Some fish is evil is false then Every fish is good",
        "Some fish is wise is false then Every fish is foolish",
        "Some fish is foolish is false then Every fish is wise",
      ],
      dog_good_evil_forward: [
        "Every dog is good then Some dog is evil is false",
        "Every dog is evil then Some dog is good is false",
        "Every dog is wise then Some dog is foolish is false",
        "Every dog is foolish then Some dog is wise is false",
      ],
      dog_good_evil_reverse: [
        "Some dog is good is false then Every dog is evil",
        "Some dog is evil is false then Every dog is good",
        "Some dog is wise is false then Every dog is foolish",
        "Some dog is foolish is false then Every dog is wise",
      ],
    },
    victoryPredicates: ["is good", "is evil", "is wise", "is foolish"],
    contradictoryPredicates: {
      "is good": "is evil",
      "is wise": "is foolish",
    },
    labels: {
      victory: "[Victory]",
      proposition: "[Prop]",
      axiom: "[Axiom]",
      victory_condition: "[WinCon]",
      theorem: "[Thm]",
      assumption: "[Asmp]",
      ci_theorem: "[CI Thm]",
      raa_theorem: "[RAA Thm]",
      theorem_source: "[Thm] {text} (R{round} Thinking)",
      victory_text: "{owner} Win Condition: {text}",
      plato_ability_source: "{text} (Recollection of Forms)",
      nietzsche_ability_source: "{text} (Eternal Recurrence)",
      wittgenstein_ability_source: "{text} (Kicking Away the Ladder)",
      derrida_ability_source: "{text} (Deconstruction)",
      hume_ability_source: "{text} (Problem of Induction)",
      kuhn_ability_source: "{text} (Paradigm Shift)",
      kant_ability_source: "{text} (Synthetic A Priori Judgment)",
    },
  },
};
